#lang racket/base
(require "parse.rkt"
         "A.rkt"
         "small-step.rkt")

(define p0
  '(letrec ([(fac) (λ (n)
                     (if (= n 0)
                         1
                         (* (- 0 n) (fac (- n 1)))))])
     (let ([(fac-rec) (chaperone-operator fac
                                          (λ (n)
                                            (if (integer? n)
                                                (if (not (< n 0))
                                                    (values (λ (n)
                                                              (if (integer? n)
                                                                  (if (not (< n 1))
                                                                      n
                                                                      (raise))
                                                                  (raise)))
                                                            n)
                                                    (raise))
                                                (raise))))])
       (fac-rec 7))))

(define p1
  '(letrec ([(fac) (chaperone-operator
                    (λ (n)
                      (if (= n 0)
                          -1
                          (* n (fac (- n 1)))))
                    (λ (n)
                      (if (not (integer? n))
                          (raise)    
                          (if (< n 0)
                              (raise)
                              (values (λ (n)
                                        (if (not (integer? n))
                                            (raise)
                                            (if (< n 1)
                                                (raise)
                                                n)))
                                      n)))))])
     (fac 5)))

(define p2
  '(let ([(->) (λ (neg pos) (λ (f) (chaperone-operator f (λ (v) (values pos (neg v))))))])
     (let ([(any/c) (λ (x) x)])
       (let ([(any) values])
         (let ([(boolean/c) (λ (p)
                              (if (not (boolean? p))
                                  (raise)
                                  p))])
           (let ([(nat/c) (λ (n)
                            (if (not (integer? n))
                                (raise)
                                (if (< n 0)
                                    (raise)
                                    n)))])
             (let ([(church/c) (-> (-> any/c any)
                                   (-> any/c any))])
               (letrec ([(n->f) ((-> nat/c church/c)
                                 (λ (n)
                                   (if (= n 0)
                                       (λ (f) (λ (x) x))
                                       (let ([(n-1) (n->f (- n 1))])
                                         (λ (f)
                                           (let ([(fn-1) (n-1 f)])
                                             (λ (x) (f (fn-1 x)))))))))])
                 (let ([(f->n) ((-> church/c nat/c)
                                (λ (c)
                                  ((c (λ (x) (+ x 1))) 0)))])
                   (let ([(c:*) ((-> church/c (-> church/c church/c))
                                 (λ (n1)
                                   (λ (n2)
                                     (λ (f)
                                       (n1 (n2 f))))))])
                     (let ([(c:zero?) ((-> church/c boolean/c)
                                       (λ (c) ((c (λ (x) #f)) #t)))])
                       (let ([(c:sub1) ((-> church/c church/c)
                                        (λ (n)
                                          (λ (f)
                                            (let ([(X) (λ (g) (λ (h) (h (g f))))])
                                              (λ (x)
                                                (((n X)
                                                  (λ (u) x))
                                                 (λ (u) u)))))))])
                         (letrec ([(c:!) ((-> church/c church/c)
                                          (λ (n)
                                            (if (c:zero? n)
                                                (λ (f) f)
                                                ((c:* n) (c:! (c:sub1 n))))))])
                           (f->n (c:! (n->f 3))))))))))))))))

(define p3
  '(let ([(->) (λ (neg pos) (λ (f) (chaperone-operator f (λ (v) (values pos (neg v))))))])
     (let ([(any/c) (λ (x) x)])
       (let ([(any) values])
         (let ([(boolean/c) (λ (p)
                              (if (not (boolean? p))
                                  (raise)
                                  p))])
           (let ([(nat/c) (λ (n)
                            (if (not (integer? n))
                                (raise)
                                (if (< n 0)
                                    (raise)
                                    n)))])
             (let ([(church/c) (-> (-> any/c any)
                                   (-> any/c any))])
               (letrec ([(n->f) ((-> nat/c church/c)
                                 (λ (n)
                                   (if (= n 0)
                                       (λ (f) (λ (x) x))
                                       (let ([(n-1) (n->f (- n 1))])
                                         (λ (f)
                                           (let ([(fn-1) (n-1 f)])
                                             (λ (x) (f (fn-1 x)))))))))])
                 (n->f 0)))))))))

(define p4
  '(let ([(->) (λ (neg pos) (λ (f) (chaperone-operator f (λ (v) (values pos (neg v))))))])
     (let ([(any/c) (λ (x) x)])
       (let ([(any) values])
         (let ([(f) ((-> (-> any/c any) (any/c any))
                     (λ (x) x))])
           (f f))))))



(define p5
  '(let ([(->) (λ (neg pos) (λ (f) (chaperone-operator f (λ (v) (values pos (neg v))))))])
     (let ([(nat/c) (λ (n)
                      (if (not (integer? n))
                          (raise)
                          (if (< n 0)
                              (raise)
                              n)))])
       (let ([(positive-nat/c) (λ (n)
                                 (if (not (integer? n))
                                     (raise)
                                     (if (< n 1)
                                         (raise)
                                         n)))])
         (letrec ([(fact) ((-> nat/c positive-nat/c)
                           (λ (n)
                             (if (= n 0)
                                 1
                                 (* n (fact (- n 1))))))])
           (fact 7))))))

(require racket/match)

(match (eval (A (parse p5)))
  [(cons σ v)
   v]
  [e
   e])


