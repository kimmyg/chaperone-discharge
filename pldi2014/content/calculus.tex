\section{Chaperone Calculus}

In order to explicate a static analysis of higher-order interposition, we define \chapcalc, or \emph{chaperone calculus}, an extension of the A-normalized $\lambda$-calculus with interposition facilities.

%As only a moderate extension of the $\lambda$-calculus, \chapcalc\ lacks many Racket features.
%Mutation, in particular, is conspicuously absent.
%We discuss the integration of other language features in Section \ref{sec:limitations}.


\subsection{\chapcalc\ Syntax}

The syntax of \chapcalc\ can be seen in Figure \ref{fig:syntax}.

\chapcalc\ inherits application, abstraction, and variable terms from the $\lambda$-calculus.
It includes simple values from the domain of integers and booleans as well as a set of first-class primitive procedures which operate over these values.
The inclusion of primitive procedures and introduction of impersonators and chaperones enriches the class of operators formerly inhabited only by closures.
This enrichment is masked somewhat in the language behind a single discriminator---\scheme{operator?}---for any members of the class.

The syntactic class \ae\ signifies \emph{atomic expressions} and includes $\lambda$-terms, variables, and the simple values of booleans, integers, and primitive procedures, which include \scheme{imp-op} and \scheme{chap-op}.
Expressions classified as such will never produce an error or diverge.

The syntactic class $c$ denotes procedure application sites which are formed by an atomic operator expression followed by a sequence of atomic operand expressions.

The syntatic class of expressions, denoted $e$, includes \scheme{let}, and \scheme{if} expressions.
Concrete syntax in examples may include \scheme{letrec} which is defined simply in terms of \scheme{let} and the \scheme{Y} combinator, as well as \scheme{and} and \scheme{or} defined in terms of \scheme{if}.

Every term is annotated with a unique label $\ell$ to keep otherwise identical terms distinguishable, but labels will be made explicit only for application sites.

A program is a term in the grammar with no free variables and in which all identifiers in the same binding form are pairwise distinct.

\newcommand{\vx}[0]{\mathbf{x}}

\newcommand{\appe}[2]{(#1\,#2)^\ell}
\newcommand{\lame}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\chae}[2]{(\mathit{chaperone\mhyphen operator}\,#1\,#2)^\ell}
\newcommand{\impe}[2]{(\mathit{impersonate\mhyphen operator}\,#1\,#2)}
\newcommand{\lete}[3]{(\mathbf{let}\,((#1)\,#2)\,#3)}
\newcommand{\ife}[3]{(\mathbf{if}\,#1\,#2\,#3)}

\newcommand{\true}[0]{\mathrm{\#t}}
\newcommand{\false}[0]{\mathrm{\#f}}

\newcommand{\stxclass}[4]{$#1\in\mathbf{#2}$ &::=& #3 & #4}
\newcommand{\stxclasscont}[2]{&$|$& #1 & #2}

\setspecialsymbol{ae}{$\ae$}

\setlength{\tabcolsep}{1pt}
\begin{figure}
\label{fig:syntax}

\begin{tabular}{ r r l l }
\stxclass{e}{Exp}{\scheme|(let ((x ...) c) e)|}{let}\\
\stxclasscont{\scheme|(if ae e e)|}{if}\\
\stxclasscont{$c$}{}\\
\stxclasscont{\ae}{}\\
\stxclass{c}{Call}{\scheme|(ae ae ...)|$^\ell$}{application}\\
\stxclass{\ae}{AExp}{$\mathit{lam}$ $|$ $p$ $|$ $x$ $|$ $n$ $|$ $t$}{atomic expressions}\\
\stxclass{\mathit{lam}}{Lam}{\scheme|(LAMBDA (x ...) e)|}{lambda terms}\\
\stxclass{p}{Prim}{\scheme|imp-op| $|$ \scheme|chap-op| $|$ \scheme|values| $|$ \scheme|raise|}{primitives}\\
\stxclasscont{\scheme|<| $|$ \scheme|>| $|$ \scheme|=| $|$ \scheme|+| $|$ \scheme|-| $|$ \scheme|not|}{}\\
\stxclasscont{\scheme|operator?| $|$ \scheme|integer?| $|$ \scheme|boolean?|}{}\\
\stxclass{x}{Var}{an infinite set of variables}{}\\
\stxclass{n}{Int}{$0\,|\,1\,|\,-1\,|\,2\,|\,-2\,|\,\dots$}{integers}\\
\stxclass{t}{Bool}{$\true\,|\,\false$}{booleans}\\
\stxclass{\ell}{Lab}{an infinite set of labels}{}
\end{tabular}

\caption{The syntax of \chapcalc.}
\end{figure}



% results are:
% values: closures, chaperones, impersonators, primitives, integers, booleans
% errors: error, blame L, blame +L, blame -L

% (e e1 ... en),\rho,\sigma,\kappas
% v = A(e,\rho,\sigma), vi = A(ei,\rho,\sigma)
% case v
%   ((lambda s e'),\rho')
%   if s compatible with n
%     (e',\rho'',\sigma',\kappas) where \rho'' and \sigma' bind vis according to s
%     error
%   primitive
%   if primitive arity compatible with n
%     \delta(primitive,v1,...,vn)
%     error
%   (chaperone L f neg pos)
%   (lambda vs
%     (let ([vs' (app-values neg vs)])
%       (if (= (length vs)
%              (length vs'))
%           (if (and-map chaperone-of? vs' vs)
%               (let ([rs' (app-values f vs')])
%                 (if (arity-comp? pos rs')
%                     (let ([rs (app-values pos rs')])
%                       (if (= (length rs')
%                              (length rs))
%                           (if (and-map chaperone-of? rs rs')
%                               (app-values values rs)
%                               (error)) (blame + guard)
%                           (error))) (blame + guard)
%                     (error))) (blame + guard)
%               (error)) (blame - guard)
%           (error)))) (blame - guard)

\newcommand{\A}[3]{\mathcal{A}(#1,#2,#3)}
\newcommand{\arity}[1]{\ensuremath{\mathrm{arity}(#1)}}


\newcommand{\dynbla}[1]{\mathrm{dynamic\mhyphen blame}(#1)}

\newcommand{\nttwo}[3]{\ensuremath{\mathbf{#1}(#2,#3)}}
\newcommand{\ntthr}[4]{\ensuremath{\mathbf{#1}(#2,#3,#4)}}
\newcommand{\ntfou}[5]{\ensuremath{\mathbf{#1}(#2,#3,#4,#5)}}

\newcommand{\ks}[0]{\gamma^*}
\newcommand{\vv}[0]{\mathbf{v}}
\newcommand{\vvp}[0]{\mathbf{v'}}
\newcommand{\sexp}[4]{\mathbf{eval}(#1,#2,#3,#4)}
\newcommand{\sval}[3]{\mathbf{value}(#1,#2,#3)}
\newcommand{\sapp}[4]{\mathbf{apply}(#1,#2,\ell,#3,#4)}
\newcommand{\simpz}[6]{\mathbf{imp_0}(#1,#2,#3,#4,#5,#6)}
\newcommand{\simpo}[5]{\mathbf{imp_1}(#1,#2,#3,#4,#5)}
\newcommand{\schaz}[6]{\mathbf{chap_0}(#1,#2,#3,#4,#5,#6)}
\newcommand{\schao}[5]{\mathbf{chap_1}(#1,#2,#3,#4,#5)}
\newcommand{\serr}[3]{\mathbf{error}(#1,#2,#3)}
\newcommand{\sbla}[2]{\mathrm{blame}_{#1}(#2)}
\newcommand{\app}[4]{\mathrm{apply}(#1,#2,#3,#4)}
\newcommand{\redta}[3]{\begin{equation}\begin{aligned}& #1\\\rr\, & #2\end{aligned}\tag{#3}\end{equation}}
\newcommand{\red}[2]{\begin{equation}#1\rr#2\end{equation}}
\newcommand{\redt}[3]{\begin{equation}#1\rr#2#3\end{equation}}
\newcommand{\redtwo}[5]{\begin{math}#1\rr\begin{cases}#2 & #3\\ #4 & #5\end{cases}\end{math}}
\newcommand{\redtwot}[6]{\begin{equation}#1\rr\begin{cases}#2 & #3\\ #4 & #5\end{cases}#6\end{equation}}
\newcommand{\redthr}[7]{\begin{math}#1\rr\begin{cases}#2 & #3\\ #4 & #5\\#6 & #7\end{cases}\end{math}}
\newcommand{\redthrt}[7]{\begin{equation}#1\rr\begin{cases}#2 & #3\\ #4 & #5\\#6 & #7\end{cases}\end{equation}}


\newcommand{\clo}[2]{\nttwo{clos}{#1}{#2}}
\newcommand{\imp}[2]{\ntthr{imp}{\ell}{#1}{#2}}
\newcommand{\cha}[2]{\ntthr{chap}{\ell}{#1}{#2}}

\newcommand{\letk}[3]{\ntthr{let}{#1}{#2}{#3}}

\newcommand{\impcwk}[2]{\ntthr{imp\mhyphen neg}{\ell}{#1}{#2}}
\newcommand{\impcfk}[1]{\nttwo{imp\mhyphen fun}{\ell}{#1}}
\newcommand{\impcrk}[1]{\nttwo{imp\mhyphen pos}{\ell}{#1}}

\newcommand{\chacwk}[2]{\ntthr{chap\mhyphen neg}{\ell}{#1}{#2}}
\newcommand{\chacfk}[1]{\nttwo{chap\mhyphen fun}{\ell}{#1}}
\newcommand{\chacrk}[1]{\nttwo{chap\mhyphen pos}{\ell}{#1}}

\newcommand{\impblame}[1]{\ensuremath{\mathrm{imp\mhyphen blame}(#1)}}
\newcommand{\chablame}[1]{\ensuremath{\mathrm{cha\mhyphen blame}(#1)}}
\newcommand{\blame}[1]{\ensuremath{\mathrm{blame}(#1)}}
\newcommand{\noblame}[0]{\ensuremath{\mathrm{empty\mhyphen blame}}}

\newcommand{\rr}{\longrightarrow}
\newcommand{\rrs}{\longrightarrow^{*}}

\subsection{$\chapcalc$ Semantics}

We define the semantics of \chapcalc\ in terms of an abstract machine similar to Felleisen's CESK machine~\cite{felleisen1987calculus} to facilitate the eventual pushdown analysis.
Figure~\ref{fig:states} presents the definition of the abstract machine space.

We use boldface to denote a vector of objects in that category; e.g., $\vv$ denotes a vector $\langle v_1,\dots,v_n\rangle$ for some natural number $n$.
We use a star ($^*$) for the same purpose when boldface is not available; e.g., $\gamma^*$ denotes a vector $\langle\gamma_1,\dots,\gamma_n\rangle$.
The notation $x::\vx$ denotes the prepend of $x$ to the vector $\vx$.
(If $\vx=\langle x_1,x_2,\dots,x_n\rangle$, then $x::\vx=\langle x,x_1,x_2,\dots,x_n\rangle$.)
For a vector $\vv=\langle x_1, x_2, \dots, x_n\rangle$, $|\vv|$ denotes the size of the vector $n$.

First we define a set of metafunctions that the semantics relies on.

\subsubsection{Program Injection}

A program is injected into a machine state with the function $\mathcal{I} : e\rightarrow\mathbf{State}$ defined as $\mathcal{I}(p)=\sexp{\langle\rangle}{\perp}{\perp}{p}$.

\subsubsection{Atomic Expression Evaluation}

\newcommand{\Aeval}[1]{\ensuremath{\mathcal{A}(\sigma,\rho,#1)}}

The metafunction $\mathcal{A}$ is used to evaluate atomic expressions and is defined by
\begin{tabular}{ r l l }
\Aeval{\mathit{lam}} &= \clo{\mathit{lam}}{\rho} & $\lambda$-terms\\
\Aeval{x}            &= $\sigma(\rho(x))$ & variables\\
\Aeval{n}            &= $n$ & integers\\
\Aeval{t}            &= $t$ & booleans\\
\Aeval{p}            &= $p$ & primitives\\
\end{tabular}

\subsubsection{Variable Binding}

\newcommand{\bind}[2]{\ensuremath{\mathrm{bind}(\sigma,\rho,#1,#2)}}
\newcommand{\alloc}[1]{\ensuremath{\mathrm{alloc}(#1)}}

Rather than an environment binding a variable to a value, it binds a variable to an address which is bound to a value by the store.
(This indirection will make later semantic changes more subdued.)
In consequence, the a new variable-value binding touches both the environment and the store.

We define $\bind{x}{v}=(\sigma',\rho')$ where $\sigma'=\sigma[a\rightarrow v]$, $\rho'=\rho[x\rightarrow a]$, and $a=\alloc{x}$ where $\alloc{x}$ simply returns a fresh address for $x$.
We also fold $\mathrm{bind}$ over identically-sized variable vectors $\vx$ and value vectors $\vv$.

\subsubsection{chaperone-of?}

\newcommand{\chapof}[2]{\ensuremath{\mathrm{chaperone\mhyphen of?}(#1,#2)}}

The relation \chapof{v}{v'} holds when parts of $v$ can be derived from corresponding parts of $v'$ through \scheme{chap-op}.
We lift $\mathrm{chaperone\mhyphen of?}$ element-wise over vectors.

%It holds if any of the following hold.
%(This definition is not given in terms of sequential pattern matching. Two chaperones satisfy the relation if they meet the conditions of the first clause \emph{or} the second clause.)

\begin{itemize}
\item[] \chapof{\cha{f}{w}}{\cha{f'}{w'}}\\
\begin{tabular}{ r l }
   & if \chapof{f}{f'} and \chapof{w}{w'}\\
or & if \chapof{f}{\cha{f'}{w'}}
\end{tabular}
\item[] \chapof{\cha{f}{w}}{f'} if \chapof{f}{f'}
\item[] \chapof{f}{f} if \scheme{operator?(f)}
\end{itemize}

%\begin{verbatim}
%chaperone-of? (chaperone f w) (chaperone f' w')
%if (chaperone-of? f f') and (chaperone-of? w w')
%;or (chaperone-of? f (chaperone f' w'))
%chaperone-of? (chaperone f w) f'
%if (chaperone-of? f f')
%chaperone-of? (e_LAMBDA,\rho) (e_LAMBDA',\rho')
%if e_LAMBDA=e_LAMBDA' and \rho=\rho'
%\end{verbatim}



\subsubsection{Operator Arity}

The arity of an operator in \chapcalc\ is a set of natural numbers each indicating a number of arguments the operator will accept.
For most operators in \chapcalc\, this arity is a singleton.
To wit, the arity of closures is simply the number of formal parameters of the $\lambda$-term.
\begin{itemize}
\item[] $\arity{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}=\{n\}$
\end{itemize}
The arity of impersonators (including chaperones) is the arity of the impersonated operator.
\begin{itemize}
\item[] $\arity{\imp{f}{w}}=\arity{f}$
\end{itemize}
The arity of each primitive procedure is straightforward with two exceptions:
\begin{itemize}
\item[] $\arity{\mathit{values}}=\arity{\mathit{raise}}=\{0,1,2,\dots\}$
\end{itemize}


\newcommand{\funarr}[2]{$\mathbf{#1}\rightarrow\mathbf{#2}$}
\newcommand{\finarr}[2]{$\mathbf{#1}\rightharpoonup\mathbf{#2}$}

\begin{figure}
\label{fig:states}

\begin{tabular}{ r r l l }
\stxclass{\varsigma}{State}{$\sexp{\ks}{\sigma}{\rho}{e}$}{evaluation}\\
\stxclasscont{$\sapp{\ks}{\sigma}{f}{\vv}$}{apply}\\
\stxclasscont{$\sval{\ks}{\sigma}{\vv}$}{value}\\
\stxclasscont{$\serr{\ks}{\sigma}{b}$}{error}\\
\stxclasscont{$\simpz{\ks}{\sigma}{\ell}{f}{w}{\vv}$}{imp0}\\
\stxclasscont{$\simpo{\ks}{\sigma}{\ell}{w}{\vv}$}{imp1}\\
\stxclasscont{$\schaz{\ks}{\sigma}{\ell}{f}{w}{\vv}$}{chap0}\\
\stxclasscont{$\schao{\ks}{\sigma}{\ell}{w}{\vv}$}{chap1}\\
\stxclass{\gamma}{Frame}{\letk{\vx}{\rho}{e}}{let}\\
\stxclasscont{\impcwk{f}{\vv}}{negative guard}\\
\stxclasscont{\impcfk{w}}{impersonated procedure}\\
\stxclasscont{\impcrk{\vv}}{positive guard}\\
\stxclasscont{\chacwk{f}{\vv}}{chaperone negative}\\
\stxclasscont{\chacfk{w}}{chaperone function}\\
\stxclasscont{\chacrk{\vv}}{chaperone positive}\\
\stxclass{v}{Val}{$f\,|\,n\,|\,t$}{values}\\
\stxclass{\sigma}{Store}{\finarr{Addr}{Val}}{stores}\\
\stxclass{\rho}{Env}{\finarr{Var}{Addr}}{environments}\\
\stxclass{f,w}{Op}{\nttwo{clos}{\mathit{lam}}{\rho}}{closures}\\
\stxclasscont{\ntthr{imp}{\ell}{f}{w}}{impersonators}\\
\stxclasscont{\ntthr{chap}{\ell}{f}{w}}{chaperones}\\
\stxclasscont{$p$}{primitives}\\
\stxclass{a}{Addr}{an infinite set of addresses}{}\\
\stxclass{b}{Blame}{$\impblame{\ell}\,|\,\chablame{\ell}$}{blame}\\
\stxclasscont{$\blame{\ell}\,|\,\noblame$}{}
\end{tabular}

\caption{Abstract machine state space for \chapcalc}
\end{figure}

\subsection{Abstract Machine States}

An $\mathbf{eval}$ state corresponds to a traditional CESK state, that is, the evaluation of an expression.
(The order of the components is reversed, however, to aid factoring out common components from among the variants.)

An $\mathbf{apply}$ state represents a point of application and dispatches on the operator type (closure, impersonator, or primitive).

A $\mathbf{value}$ state represents a point of return and dispatches on the type of the top continuation frame.
If the continuation is empty, the constituent values are the results of the program.

An $\mathbf{error}$ state represents the arisal of an error and, as the result of the program, may include blame information.

Finally, the $\mathbf{imp_0}$, $\mathbf{imp_1}$, $\mathbf{chap_0}$, and $\mathbf{chap_1}$ states each split a transition which would otherwise pop and push a frame simulaneously into a sequence of two transitions which performs each separately.
(These are for convenience for the eventual static analysis.)

\subsection{Reduction relation}

Figure~\ref{fig:redrec} contains the definition of the reduction relation of abstract machine states.



%It is significant that the most specific blame is assigned first.
%For instance, when a negative chaperone guard returns an extra result, the remaining results are checked to be $\mathrm{chaperone\mhyphen of?}$ the arguments before the extra result is checked to be a procedure.
%If the order were reversed, our analysis might erroneously judge a chaperone as well-behaved which is not.
%[It's actually not significant because if the transformation preserves the semantics, then that value will raise the error as an impersonator also. It is as if the well-behavedness is vacuous.]

\begin{figure*}

\redt{\sexp{\ks}{\sigma}{\rho}{\lete{x_1\,\dots\, x_n}{c}{e}}}
     {\sexp{\letk{\vx}{\rho}{e}::\ks}{\sigma}{\rho}{c}}
     {\mbox{ where }\vx=\langle x_1,\dots,x_n\rangle\mbox{.}}

\redt{\sexp{\ks}{\sigma}{\rho}{\appe{\ae_f}{\ae_1\,\dots\,\ae_n}}}
     {\sapp{\ks}{\sigma}{f}{\langle v_1,\dots,v_n\rangle}}
     {\mbox{ where }f=\A{\sigma}{\rho}{\ae_f}\mbox{ and }v_i=\A{\sigma}{\rho}{\ae_i}\mbox{ for }i=1,\dots,n\mbox{.}}

\redtwot{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}
        {\sexp{\ks}{\sigma'}{\rho'}{e_1}}{\mbox{if }|\vx|=|\vv|}
        {\serr{\ks}{\sigma}{\noblame}}{\mbox{if }|\vx|\ne|\vv|}
        {\mbox{ where }(\sigma',\rho')=\bind{\vx}{\vv}\mbox{.}}    

\redtwot{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}
        {\sexp{\ks}{\sigma}{\rho}{e_c}}{\mbox{if }v_t\ne\false}
        {\sexp{\ks}{\sigma}{\rho}{e_a}}{\mbox{if }v_t=\false}
        {\mbox{ where }v_t=\A{\sigma}{\rho}{\ae_t}\mbox{.}}

\redtwot{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}
        {\sexp{\ks}{\sigma'}{\rho'}{e}}{\mbox{if }|\vx|=|\vv|}
        {\serr{\ks}{\sigma}{\blame{\ell}}}{\mbox{if }|\vx|\ne|\vv|}
        {\mbox{ where }\vx=\langle x_1,\dots,x_n\rangle\mbox{ and }(\sigma',\rho')=\bind{\vx}{\vv}\mbox{.}}

\redt{\sapp{\ks}{\sigma}{\imp{f}{w}}{\vv}}
     {\sapp{\impcwk{f}{\vv}::\ks}{\sigma}{w}{\vv}}
     {}

\redtwot{\sval{\impcwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}
       {\simpz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}{\mbox{if }|\vv|=|\vvp|\mbox{ and } \mathrm{operator?}(w)\mbox{,}}
       {\serr{\ks}{\sigma}{\impblame{\ell}}}{\mbox{if }|\vv|=|\vvp|\mbox{ but not }\mathrm{operator?}(w)\mbox{.}}
       {}

\redtwot{\sval{\impcwk{f}{\vv}::\ks}{\sigma}{\vvp}}
        {\sapp{\ks}{\sigma}{f}{\vvp}}{\mbox{if }|\vv|=|\vvp|\mbox{,}}
        {\serr{\ks}{\sigma}{\impblame{\ell}}}{\mbox{if }|\vv|\ne|\vvp|\mbox{.}}
        {}
        
\redt{\simpz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}
     {\sapp{\impcfk{w}::\ks}{\sigma}{f}{\vvp}}
     {}

\redt{\sval{\impcfk{w}::\ks}{\sigma}{\vv}}
     {\simpo{\ks}{\sigma}{w}{\vv}{\ell}}
     {}
     
\redt{\simpo{\ks}{\sigma}{w}{\vv}{\ell}}
     {\sapp{\impcrk{\vv}::\ks}{\sigma}{w}{\vv}}
     {}

\redtwot{\sval{\impcrk{\vv}::\ks}{\sigma}{\vvp}}
        {\sval{\ks}{\sigma}{\vvp}}{\mbox{if }|\vv|=|\vvp|\mbox{,}}
        {\serr{\ks}{\sigma}{\impblame{\ell}}}{\mbox{if }|\vv|\ne|\vvp|\mbox{ and }|\vv|+1\ne|\vvp|\mbox{.}}
        {}
        
\redt{\sapp{\ks}{\sigma}{\cha{f}{w}}{\vv}}
     {\sapp{\chacwk{f}{\vv}::\ks}{\sigma}{w}{\vv}}
     {}

\redthrt{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}
        {\schaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}{\mbox{if }|\vv|=|\vvp|\mbox{, } \chapof{\vvp}{\vv}\mbox{, and }\mathrm{operator?}(w)\mbox{,}}
        {\serr{\ks}{\sigma}{\chablame{\ell}}}{\mbox{if }|\vv|=|\vvp|\mbox{ but not }\chapof{\vvp}{\vv}\mbox{,}}
        {\serr{\ks}{\sigma}{\impblame{\ell}}}{\mbox{if }|\vv|=|\vvp|\mbox{ and }\chapof{\vvp}{\vv}\mbox{ but not }\mathrm{operator?}(w)\mbox{.}}

\redthrt{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}
        {\sapp{\ks}{\sigma}{f}{\vvp}}{\mbox{if }|\vv|=|\vvp|\mbox{ and }\chapof{\vvp}{\vv}\mbox{,}}
        {\serr{\ks}{\sigma}{\chablame{\ell}}}{\mbox{if }|\vv|=|\vvp|\mbox{ but not }\chapof{\vvp}{\vv}\mbox{,}}
        {\serr{\ks}{\sigma}{\impblame{\ell}}}{\mbox{if }|\vv|\ne|\vvp|\mbox{ and }|\vv|+1\ne|\vvp|\mbox{.}}

\redt{\schaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}
     {\sapp{\chacfk{w}::\ks}{\sigma}{f}{\vvp}}
     {}

\redt{\sval{\chacfk{w}::\ks}{\sigma}{\vv}}
     {\schao{\ks}{\sigma}{w}{\vv}{\ell}}
     {}

\redt{\schao{\ks}{\sigma}{w}{\vv}{\ell}}
     {\sapp{\chacrk{\vv}::\ks}{\sigma}{w}{\vv}}
     {}

\redthrt{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}
        {\sval{\ks}{\sigma}{\vvp}}{\mbox{if }|\vv|=|\vvp|\mbox{ and }\chapof{\vvp}{\vv}\mbox{,}}
        {\serr{\ks}{\sigma}{\chablame{\ell}}}{\mbox{if }|\vv|=|\vvp|\mbox{ but not }\chapof{\vvp}{\vv}\mbox{,}}
        {\serr{\ks}{\sigma}{\impblame{\ell}}}{\mbox{if }|\vv|\ne|\vvp|\mbox{.}}

\redtwot{\sapp{\ks}{\sigma}{p}{\vv}}
        {\sval{\ks}{\sigma}{\vvp}}{\mbox{if }\delta(p,\vv)=\vvp\mbox{ for some }\vvp\mbox{,}}
        {\serr{\ks}{\sigma}{b}}{\mbox{if }\delta(p,\vv)=b\mbox{ for some }b\mbox{.}}
        {}

\caption{\chapcalc\ reduction relation}
\label{fig:redrec}
\end{figure*}

Rule 5 represents closure application which proceeds straightforwardly by extending its environment and evaluating its body.
If the number of values applied is incompatible with the arity of the closure, blame is assigned to the call site.
Rules 6 and 13 represent impersonator application which recurs on its guard and augments the context to complete the interposition when its guard returns.
The enlarged context is annotated with the label of the applied impersonator (which itself is the label of its installment site).
If the guard operator provides an operator as an additional result, as in rules 7 and 14, this operator is situated to intercept the results of the impersonated operator.
If no additional result is provided, as in rules 8 and 15, the impersonated operator is invoked with the continuation of its impersonator, i.e., the interposition ceases for that invocation.
The rules pertinent to chaperones augment this protocol, ensuring that guard results are $\mathrm{chaperone\mhyphen of?}$ their arguments.
Rule 20 represents primitive application defined by the $\delta$ function.
The label of the call site is passed implicitly to each primitive with which the \scheme{imp-op} and \scheme{chap-op} primitives imbue the newly-created impersonator.
Otherwise, it is used to blame the call site in case of error.

\subsubsection{Blame}

There are four variants of blame.
\begin{itemize}
\item
$\chablame{\ell}$ represents blame circumstances exclusive to chaperones.
The only such circumstances are when the results of a guard are not $\mathrm{chaperone\mhyphen of?}$ its arguments.

\item
$\impblame{\ell}$ represents blame circumstances exclusive to impersonators (which includes chaperones).
These include when a guard returns an unacceptable number of results or the extra result is not a procedure.

\item
$\blame{\ell}$ represents blame at a call site and disqualifies the call site from being transformed.

\item
$\noblame$ represents blame independent of a call site or impersonator.
Such situations include when the number of results to a \scheme{let} continuation is incompatible with the number of formal parameters.
\end{itemize}

\newcommand{\primonl}[4]{$\delta$(#1,$#2$) &= $#3$ & #4}
\newcommand{\primone}[4]{$\delta$(#1,$\langle #2 \rangle$) &= $\langle #3 \rangle$ & #4}
\newcommand{\primtwo}[5]{$\delta$(#1,$\langle #2, #3 \rangle$) &= $\langle #4 \rangle$ & #5}
\newcommand{\primtwe}[4]{$\delta$(#1,$\langle #2, #3 \rangle$) &= $\blame{\ell}$ & #4}
\newcommand{\primfou}[7]{$\delta$(#1,$\langle #2, #3, #4, #5\rangle$) &= $\langle #6 \rangle$ & #7}
\newcommand{\primfoe}[6]{$\delta$(#1,$\langle #2, #3, #4, #5\rangle$) &= $\blame{\ell}$ & #6}

\subsubsection{Primitive operators}

The evaluation of a primitive operator application is given by the definition of the $\delta$ function which is seen in Figure~\ref{fig:delta}.
Most primitive operators accept a specific number of arguments with specific types.
If the number or type of the arguments is not as defined, the result is blame on the originating site (which label is provided implicitly).
The class $n$ of variables indicate integers, the class $f$ operators, the class $t$ booleans, and the class $v$ a union of all value types.

\begin{figure}
\begin{tabular}{ r l l }
\primtwo{\scheme|<|}{n_1}{n_2}{\true}{if $n_1 < n_2$}\\
\primtwo{\scheme|<|}{n_1}{n_2}{\false}{otherwise}\\
\primtwo{\scheme|>|}{n_1}{n_2}{\true}{if $n_1 > n_2$}\\
\primtwo{\scheme|>|}{n_1}{n_2}{\false}{otherwise}\\
\primtwo{\scheme|=|}{n_1}{n_2}{\true}{if $n_1 = n_2$}\\
\primtwo{\scheme|=|}{n_1}{n_2}{\false}{otherwise}\\
\primtwo{\scheme|+|}{n_1}{n_2}{\lceil n_1 + n_2\rceil}{}\\
\primtwo{\scheme|-|}{n_1}{n_2}{\lceil n_1 - n_2\rceil}{}\\
\primtwo{\scheme|imp-op|}{f_1}{f_2}{\imp{f_1}{f_2}}{if $\arity{f_2}\supseteq\arity{f_1}$}\\
\primtwe{\scheme|imp-op|}{f_1}{f_2}{otherwise}\\
\primtwo{\scheme|chap-op|}{f_1}{f_2}{\cha{f_1}{f_2}}{if $\arity{f_2}\supseteq\arity{f_1}$}\\
\primtwe{\scheme|chap-op|}{f_1}{f_2}{otherwise}\\
\primonl{\scheme|values|}{\vv}{\vv}{}\\
\primonl{\scheme|raise|}{\vv}{\blame{\ell}}{}\\
\primone{\scheme|not|}{v}{\true}{if $v = \false$}\\
\primone{\scheme|not|}{v}{\false}{otherwise}\\
\primone{\scheme|operator?|}{f}{\true}{}\\
\primone{\scheme|operator?|}{v}{\false}{for $v$ not an operator}\\
\primone{\scheme|integer?|}{n}{\true}{}\\
\primone{\scheme|integer?|}{v}{\false}{for $v$ not an integer}\\
\primone{\scheme|boolean?|}{t}{\true}{}\\
\primone{\scheme|boolean?|}{v}{\false}{for $v$ not a boolean}\\
\end{tabular}
\caption{\chapcalc\ $\delta$ function}
\label{fig:delta}
\end{figure}

The \scheme{values} and \scheme{raise} operators are distinct.
The \scheme{values} accepts any number of arguments and returns them to the providing context.
The \scheme{raise} discards any number of arguments and raises an error.
The arity of each of these operators then includes the arity of any other operator, so the installation \scheme{(chap-op values values)} is legal, if superfluous.

\subsection{Program evaluation}

\begin{itemize}
\item If $I(p)\longrightarrow^{*}\sval{\langle\rangle}{\sigma}{\vv}$, the program evaluates to the values $\vv$ which we write as $p\Downarrow\vv$.
\item If $I(p)\longrightarrow^{*}\serr{\langle\gamma_1,\dots,\gamma_n\rangle}{\sigma}{b}$, $p$ the program results in an error with blame $b$ and we write $p\Uparrow b$.
\item If, for all $\varsigma$ such that $I(p)\longrightarrow^{*}\varsigma$, there exists $\varsigma'$ such that $\varsigma\longrightarrow\varsigma'$, then $p$ diverges and we write $p\Uparrow$.
\end{itemize}
