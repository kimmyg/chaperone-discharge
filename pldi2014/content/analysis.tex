\section{Static Analysis}

In order to build an approximation of the creation relation and misbehaving set across all possible executions, we perform an abstract interpretation of the program.
Introspective pushdown analysis~\cite{earl2012introspective} is a recent development in the abstract interpretation of higher-order programs which characterizes the control flow graph in terms of a pushdown system.
In this characterization, pushdown system states represent abstract control states and the pushdown system stack represents the abstract control stack of the program interpretation.
An abstract interpretation then ultimately takes the form of a directed graph in which edges are labelled with stack changes.

The analysis is deemed introspective because it maintains a conservative approximation of active stack frames for each control state as the abstract control graph is constructed.
This set of frames is used to root an abstract garbage collector that discards stale bindings increasing both the precision and performance of the analysis.
We use this set to build approximations of both the creation relation and misbehaving set of chaperones.

To perform this analysis, we must abstract our abstract machine state space (and it is here that this representation choice is justified)~\cite{van2010abstracting}.
%In addition to modifying the state space, we must alter some of the reduction rules and metafunctions.

The definition of the abstract abstract state space can be seen in Figure~\ref{fig:abstract-states}.
We follow Might's strategy of lifting abstractions component-, element- member-, and point-wise across the structure of machine states.

\newcommand{\astxclass}[4]{$#1\in\widehat{\mathbf{#2}}$ &::=& #3 & #4}
%\newcommand{\stxclasscont}[2]{&$|$& #1 & #2}
\newcommand{\aks}[0]{\hat{\gamma}^*}
%\newcommand{\vv}[0]{\mathbf{v}}
%\newcommand{\vvp}[0]{\mathbf{v'}}
%\newcommand{\sexp}[4]{\mathbf{eval}(#1,#2,#3,#4)}
%\newcommand{\sval}[3]{\mathbf{value}(#1,#2,#3)}
%\newcommand{\sapp}[4]{\mathbf{apply}(#1,#2,\ell,#3,#4)}
%\newcommand{\scha}[6]{\Sigma_d(#1,#2,#3,#4,#5,#6)}
%\newcommand{\simpz}[6]{\mathbf{imp_0}(#1,#2,#3,#4,#5,#6)}
%\newcommand{\simpo}[5]{\mathbf{imp_1}(#1,#2,#3,#4,#5)}
%\newcommand{\schaz}[6]{\mathbf{chap_0}(#1,#2,#3,#4,#5,#6)}
%\newcommand{\schao}[5]{\mathbf{chap_1}(#1,#2,#3,#4,#5)}
%\newcommand{\serr}[3]{\mathbf{error}(#1,#2,#3)}
%\newcommand{\sbla}[2]{\mathrm{blame}_{#1}(#2)}
%\newcommand{\app}[4]{\mathrm{apply}(#1,#2,#3,#4)}
%\newcommand{\red}[2]{\begin{align*}& #1\\\rr\, & #2\end{align*}}

%\newcommand{\bind}[4]{\mathrm{bind}(#1,#2,#3,#4)}

%\newcommand{\clo}[2]{\nttwo{clos}{#1}{#2}}
%\newcommand{\imp}[2]{\ntthr{imp}{\ell}{#1}{#2}}
%\newcommand{\cha}[2]{\ntthr{chap}{\ell}{#1}{#2}}

%\newcommand{\letk}[3]{\mathrm{let}_\kappa(#1,#2,#3)}

%\newcommand{\impcwk}[2]{\ntthr{imp\mhyphen neg}{\ell}{#1}{#2}}
%\newcommand{\impcfk}[1]{\nttwo{imp\mhyphen fun}{\ell}{#1}}
%\newcommand{\impcrk}[1]{\nttwo{imp\mhyphen pos}{\ell}{#1}}

%\newcommand{\chacwk}[2]{\ntthr{chap\mhyphen neg}{\ell}{#1}{#2}}
%\newcommand{\chacfk}[1]{\nttwo{chap\mhyphen fun}{\ell}{#1}}
%\newcommand{\chacrk}[1]{\nttwo{chap\mhyphen pos}{\ell}{#1}}

%\newcommand{\rr}{\longrightarrow}
%\newcommand{\rrs}{\longrightarrow^{*}}

\newcommand{\aaa}[0]{\ensuremath{\hat{a}}}
\newcommand{\af}[0]{\ensuremath{\hat{f}}}
\newcommand{\aw}[0]{\ensuremath{\hat{w}}}
\newcommand{\arho}[0]{\ensuremath{\hat{\rho}}}
\newcommand{\asigma}[0]{\ensuremath{\hat{\sigma}}}

The superposition of concrete interpretation paths within a single abstract interpretation path is afforded by the abstract store representation.
Portions of the semantics that interact with the store must be modified accordingly.

\subsection{Atomic Expression Evaluation}

\newcommand{\Aaval}[1]{\ensuremath{\hat{\mathcal{A}}(\sigma,\rho,#1)}}

%Stores in the abstract space map abstract addresses to the power set of possible program values.
%Abstract evaluation of variables merely accesses this mapping.
%Abstract evaluation of concrete values must be imaged through the abstraction function and lifted into superposition.
%The finitization of the store address space finitizes the domain of closures and the other domains, save the integers, are finite already.
%The abstraction function $\alpha$ parameterize the analysis.
%Accordingly, the evaluation of atomic expressions is altered to facilitate a superposition of execution paths in the abstract interpretation.
In the abstract semantics, $\hat{\mathcal{A}}$ is defined by

\begin{tabular}{ r l l }
\Aaval{\mathit{lam}} &= $\{\clo{\mathit{lam}}{\rho}\}$ & $\lambda$-terms\\
\Aaval{x}            &= $\asigma(\arho(x))$ & variables\\
\Aaval{n}            &= $\{\alpha(n)\}$ & integers\\
\Aaval{t}            &= $\{t\}$ & booleans\\
\Aaval{p}            &= $\{p\}$ & primitives\\
\end{tabular}


\subsection{Variable Binding}

\newcommand{\abind}[2]{\ensuremath{\widehat{\mathrm{bind}}(\asigma,\arho,#1,#2)}}
\newcommand{\aalloc}[1]{\ensuremath{\widehat{\mathrm{alloc}}(#1)}}

We define $\abind{x}{v}=(\asigma',\arho')$ where $\asigma'=\sigma[\aaa\rightarrow v]$, $\arho'=\arho[x\rightarrow \aaa]$, and $\aaa=\aalloc{x}$ where $\aalloc{x}$ simply returns a fresh address for $x$.
We also fold $\mathrm{bind}$ over identically-sized variable vectors $\vx$ and value vectors $\vv$.

\begin{figure}
\label{fig:abstract-states}

\begin{tabular}{ r r l l }
\astxclass{\varsigma}{State}{$\sexp{\aks}{\asigma}{\arho}{e}$}{evaluation}\\
\stxclasscont{$\sapp{\aks}{\asigma}{f}{\vv}$}{apply}\\
\stxclasscont{$\sval{\aks}{\asigma}{\vv}$}{value}\\
\stxclasscont{$\serr{\aks}{\asigma}{b}$}{error}\\
\stxclasscont{$\simpz{\aks}{\asigma}{\ell}{\af}{\aw}{\vv}$}{imp0}\\
\stxclasscont{$\simpo{\aks}{\asigma}{\ell}{\aw}{\vv}$}{imp1}\\
\stxclasscont{$\schaz{\aks}{\asigma}{\ell}{\af}{\aw}{\vv}$}{chap0}\\
\stxclasscont{$\schao{\aks}{\asigma}{\ell}{\aw}{\vv}$}{chap1}\\
\astxclass{\gamma}{Frame}{\ntthr{let}{\vx}{\arho}{e}}{let}\\
\stxclasscont{\impcwk{\af}{\vv}}{impersonator negative}\\
\stxclasscont{\impcfk{\aw}}{impersonator function}\\
\stxclasscont{\impcrk{\vv}}{impersonator positive}\\
\stxclasscont{\chacwk{\af}{\vv}}{chaperone negative}\\
\stxclasscont{\chacfk{\aw}}{chaperone function}\\
\stxclasscont{\chacrk{\vv}}{chaperone positive}\\
\stxclass{v}{Val}{$\af\,|\,n\,|\,b$}{values}\\
\astxclass{\sigma}{Store}{\funarr{Addr}{P(Val)}}{stores}\\
\astxclass{\rho}{Env}{\funarr{Var}{\widehat{Addr}}}{environments}\\
\astxclass{\af,\aw}{Op}{\nttwo{clos}{\mathit{lam}}{\arho}}{closures}\\
\stxclasscont{\ntthr{imp}{\ell}{\aaa_{\ell,f}}{\aaa_{\ell,w}}}{impersonators}\\
\stxclasscont{\ntthr{chap}{\ell}{\aaa_{\ell,f}}{\aaa_{\ell,w}}}{chaperones}\\
\stxclasscont{$p$}{primitives}\\
\astxclass{\aaa}{Addr}{a \emph{finite} set of addresses}{}
\end{tabular}

\caption{Abstract abstract machine state space for \chapcalc}
\end{figure}

The abstraction function $\alpha$ allows us to tune our analysis, much like the parameter $k$ in $k$-CFA.
In general, the precision of the analysis increases as the abstract primitive domain underlying $\alpha$ coincides more closely with the particular contracts of the program.

\subsubsection{application}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\appe{\ae_f}{\ae_1\,\dots\,\ae_n}}}{\sapp{\ks}{\sigma}{f}{\langle v_1,\dots,v_n\rangle}}

\noindent
where $f\in\A{\sigma}{\rho}{\ae_f}$ and $v_i\in\A{\sigma}{\rho}{\ae_i}$ for $i=1,\dots,n$.

%Like closures, there is circularity in the definition of operators in \chapcalc, which induces an infinite space.
%$\mathrm{Lab}\times\mathrm{Operator}\times\mathrm{Operator}\subset\mathrm{operator}$
%We finitize the space by directing the components of a procedure impersonator or chaperone through the store.
%For allocation, we synthesize a variable for each component unique to each call site.
%$\aaa_\ell,f$
%$\aaa_\ell,w$


This pushdown analysis is a flow analysis and we use the provided flow information to discover bonafide chaperone-installation sites---that is, call sites to which only \scheme{chap-op} flows to the operator position.

We build the creation relation by considering each chaperone-installation operation and gathering the active chaperone guard frames at that control point.
We relate the label of the present installation site with the label that annotates each frame and is carried from the installation sites of the chaperones the frame represents.

We build the misbehaving set of chaperones by considering error states.
For each error state, we gather the active chaperone guard frames and include their annotating labels in the misbehaving set.
If the error state itself has explicit blame, the associated label is also included in the misbehaving set.

Finally, we consider call graphs rooted at the application of a chaperone guard procedure (these roots distinguished by the particular stack frame pushed) to approximate termination behavior.


%error dependency relation by gathering the active chaperone guard frames at each point of error
%ach frame is annotated with the label of the installation site of the chaperone it represents.

%We use pushdown analysis to build an approximation of the dependency relations.
%We use termination analysis (

%We use two static analysis techniques in tandem to determine whether chaperone-installment sites in \chapcalc\ programs are dischargeable or demotable.

%First, we use abstract interpretation via introspective pushdown analysisto soundly approximate the both the error and creation dependence relations.
%Using the flow information available from this same analysis, we perform termination analysis on $lambda$-terms used in guard procedures.

%Because \chapcalc\ lacks any inductively-defined datatypes, the portion of the dynamic call graph rooted at a guard procedure is likely a tree.
%This is not so in Racket, where such datatypes are common.
%For instance, the \scheme{(listof integer?)} contract is checked recursively on the structure of the list.
%A more powerful analysis, such as a higher-order size-change termination analysis~\cite{sereni2007termination}, would be fruitful in that context but is unnecessary here.

%\subsection{A Worked Example}

%\begin{schemedisplay}
%(let ([(->) (λ (neg pos) (λ (f) (chap-op f (λ (v) (values pos (neg v))))))])
%  (let ([(any/c) (λ (x) x)])
%    (let ([(any) values])
%      (let ([(boolean/c) (λ (p)
%                           (if (not (boolean? p))
%                               (raise)
%                               p))])
%        (let ([(nat/c) (λ (n)
%                         (if (or (not (integer? n))
%                                 (< n 0))
%                             (raise)
%                             n))])
%          (let ([(church/c) (-> (-> any/c any)
%                                (-> any/c any))])
%            (letrec ([(n->f) ((-> nat/c church/c)
%                              (λ (n)
%                                (if (= n 0)
%                                    (λ (f) (λ (x) x))
%                                    (let ([(n-1) (n->f (- n 1))])
%                                      (λ (f)
%                                        (let ([(fn-1) (n-1 f)])
%                                          (λ (x) (f (fn-1 x)))))))))])
%              (let ([(f->n) ((-> church/c nat/c)
%                             (λ (c)
%                               ((c (λ (x) (+ x 1))) 0)))])
%                (let ([(c:*) ((-> church/c (-> church/c church/c))
%                              (λ (n1)
%                                (λ (n2)
%                                  (λ (f)
%                                    (n1 (n2 f))))))])
%                  (let ([(c:zero?) ((-> church/c boolean/c)
%                                    (λ (c) ((c (λ (x) #f)) #t)))])
%                    (let ([(c:sub1) ((-> church/c church/c)
%                                     (λ (n)
%                                       (λ (f)
%                                         (let ([(X) (λ (g) (λ (h) (h (g f))))])
%                                           (λ (x)
%                                             (((n X)
%                                               (λ (u) x))
%                                              (λ (u) u)))))))])
%                      (letrec ([(c:!) ((-> church/c church/c)
%                                       (λ (n)
%                                         (if (c:zero? n)
%                                             (λ (f) f)
%                                             ((c:* n) (c:! (c:sub1 n))))))])
%                        (f->n (c:! (n->f 6)))))))))))))))
%\end{schemedisplay}

%\subsubsection{Abstract Domains}

%Because higher-order contracts often refine domains, the choice of abstraction function can have significant ramifications for the precision of the analysis.
%For instance, an analysis of the program
%\begin{schemedisplay}
%(letrec ([(fact) (values (LAMBDA (n)
%                          (let ([test0 (= n 0)])
%                            (if test0
%                                1
%                                (let ([(n-1) (- n 1)])
%                                  (let ([(rec) (fact n-1)])
%                                    (* n rec)))))))])
%  (let ([(fact) (-> fact nonnegative? positive?)])
%    (fact 5)))
%\end{schemedisplay}
%using a singleton domain [?] for integers will fail to discharge the chaperone.
%A domain which distinguishes values coincident with the edges of the contract would be able to.

%\subsection{Termination Analysis}

%We take most of this from \cite{sereni2007termination}.
%Sereni says an avenue of future work is to integrate with Might's gamma CFA.
%We could also integrate it with pushdown analysis?
%We need to build up the dynamic call graph in both analyses.
%The garbage collection is sound so we may be able to extend the TA to it (and hopefully for pushdown too).
%We don't care about the whole program; we only care about guard expressions.
%We use flow analysis to determine which lambda terms can flow to a guard.
%We do a flow analysis on all the free variables to see what could go where.
%We may be able to radically decrease the size of the call graph (in some cases) since we don't care about the whole program.

%The application of a chaperone guard will not diverge if the dynamic call graph rooted at that call is finite and does not contain any cycles.
%One of the conditions for a chaperone-installment site to be dischargeable is that the obviation of the pertinent guard applications does not change the behavior of the program.
%A guard can change the behavior of the program in one of two ways:
%First, it can signal a contract violation by means of an exception.
%The program halts and produces a blame assignment as a result.
%Clearly, if a guard would have thrown an error, and in so doing halted the program, the omission of the guard application changes the behavior---and meaning---of the program.
%Second, a guard can diverge.
%A chaperone-installment site can be discharged, then, if none of the guards there raise an error or diverge and the chaperone-installment sites of any dependent chaperones can also be discharged.



%Consider the analysis of the program
%\begin{schemedisplay}
%(let ([(f) (chap-op (LAMBDA (x) x)
%                               (LAMBDA (x)
%                                 (let ([(test) (integer? x)])
%                                   (if test
%                                       x
%                                       (raise)))))])
%  (f 1))
%\end{schemedisplay}
%\begin{verbatim}
%[]
%[(let)]
%[]
%[(chap)]
%\end{verbatim}              

%We first perform an introspective pushdown analysis on \chapcalc\ programs.
%The abstract semantics are fairly straightforward.
%Structural abstraction proceeds component-wise, point-wise, etc.
%Like Might and Van Horn~\cite{van2010abstracting} with closures, we must untie the recursive definition of chaperones and impersonators.
%We don't need it for the operators themselves since they are atomic expressions, and so cannot refer to themselves.
%We do it for the guard procedure by using the label of the site as the abstract address (or deriving it therefrom).

%We can build up the dependence relation by looking at the stack frames possible at each point of error or construction in the program.
%We determine construction points in the program by looking at value states (points of return) and examining the top frame at that point (to see if it's a chaperone construction frame).
%We take the union over all the sets of frames dependent on errors.
%We build the construction dependence relation also.
%We can then determine whether any of the installment site labels are safe to remove.
%But before that, we look at all operators that can flow to the guard of a chaperone.
%We are interested in whether they can diverge or not.
%With lambda terms, we look at whether they can diverge.
%With chaperones or impersonators, we look at whether any of the constituent operators can diverge.
%Primitives cannot diverge.

%We could look more precisely at dependence and distinguish between positive and negative guards more.
%We could find instances where the positive guard could be discharged with values. Then the negative guard could be discharged if the positive guard could be and it itself was well-behaved.
%Then a chaperone or impersonator with a guard values can be discharged.
A chaperone-installment site can discharge the positive guard if none of the positive guards of its constituents are relied on by errors.