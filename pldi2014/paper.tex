\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{slatex}

\mathchardef\mhyphen="2D
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{PLDI '14}{Month d--d, 2014, Edinburgh, Scotland} 
\copyrightyear{2014} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Static Discharge of Higher-Order Interposition}
%\subtitle{Subtitle Text, if any}

\authorinfo{Kimball Germane\and Matthew Might}
           {University of Utah}

\begin{document}

\newcommand{\chapcalc}[0]{\ensuremath{\lambda_{\mathcal{C}}}}

% TODO:
% soundness theorem
% soundness intuition
% abstract
% static analysis
% syntax
% semantics


\maketitle

\begin{abstract}
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%term1, term2

%\keywords
%keyword1, keyword2

%\cite{siek2009exploring}
%\cite{wadler2009well}

% behavioral contracts
% monitoring
% projection
% discharge
% demotion or promotion
% compliance
% chaperone vs. chaperoned operator
% 

\section{Introduction}

% what is the problem?
Higher-order behavioral contracts take time and space to enforce.

%But we expect many contract projections to be benign.

It takes time to determine compliance of first-order values as first-order contracts can be arbitrary predicates.
Additionally, functions may ascribe contracts to their higher-order arguments which themselves do similarly, even recursively.
Execution time of the program proper can be dwarfed by that of the enforcement of its specification \cite{strickland2012chaperones}.
%There isn't much a calculus can do to solve the time issue, especially in the face of dependent contracts.

Because contract compliance of higher-order values cannot be determined in general at ascription time, compliance checks must be attached to values to be performed later.
These attachments may accumulate, even changing the asymptotic space complexity of the program \cite{herman2010space} unless otherwise handled (again see \cite{herman2010space} or, for example, \cite{siek2010threesomes}).

%This space issue is well-known and a few different approaches have been taken to deal with it:
%Herman's coercion calculus, Wadler and Sieks' threesome calculus, the space-efficient contracts author
%These do well to soundly preserve the asymptotic space complexity of the program and perhaps the time as well.

The approach of hybrid type checking \cite{flanagan2006hybrid} offers a balance between the rigidity and performance of static type systems and the flexibility and cost of dynamic contracts by using static analyses to establish contract compliance at compile time, if possible, and relying on dynamic checks otherwise.
Modular development can impede these analyses because the greatest amount of knowledge a module can have about its imports \emph{is} their behavioral contract.\footnote{Indeed, it can be less than this, as when the behavioral specification is not codified entirely within the program.}
(For example, recognizing that contracts constitute total formal knowledge, Tobin-Hochstadt and Van Horn \cite{tobin2012higher} conduct an intra-module analysis which identifies extra-module references with opaque values that satisfy their contract.)
% also, contracts are attached to values that flow across module boundaries.
Nevertheless, static analyses typically perform best when given whole programs.
For instance, the whole-program ML compiler MLton \cite{weeks2006whole} is able to perform thorough inter-procedural and inter-modular analysis and effect significant program optimizations.

We turn our attention to whole-program analysis of Racket \cite{plt-tr1}, a higher-order, dynamically-typed language, for the purpose of statically discharging contracts.
Racket programs are organized into modules which consist of import and export declarations, definitions, and expressions.
Because Racket has rich facilities for syntactic extension, execution of code must be carefully controlled, especially since modules can be compiled separately \cite{flatt2002composable}.
Therefore, the quickest way to a whole program is by \emph{demodularizing} pre-compiled modules into a whole program in the Racket bytecode language (which, contrary to its name, is a fairly rich higher-order language).
At this level, contracts are manifest in terms of \emph{interposition} primitives.


Recent advances in higher-order program analysis \cite{earl2012introspective} allow the form of the stack to be approximated at each control point in the program.
The original purpose of this approximation was to provide an abstract garbage collector a conservative set of live frames, which disregards some latent structure provided by the analysis.
Specifically, the pushdown system characterization of an abstract interpretation immediately admits a finite description of an unbounded stack as a regular expression.
We use this structure to approximate blame on a misbehaving program.
Using a notion of dependence similar to Might's \cite{might2009interprocedural}, we devise a blame analysis which allows us to soundly and statically discharge contracts.

%The motivation for this was to provide an abstract garbage collector a set of live frames, disregarding any stack structure latent in the control flow graph.

%This description alone is enough to allow us to reason statically about features based on stack inspection, such as security checks [cite] and dynamic binding [cite].
%We will use it to approximate blame on a misbehaving program.
%After considering all possible sources of such blame, a straightforward analysis allows us to alter contract sites, shifting some of the dynamic burden to the static.

% thus, in order to soundly discharge contracts from the original program, we must soundly discharge impersonators and chaperones.
%The implementation of familiar language features is sometimes accomplished through alien constructs.
% (Because the feature must be situated particularly within the already existing features of the language.)
%Contracts are a common feature of dynamically-typed languages.
%Higher-order contracts \cite{findler2002contracts} increase the domain of contracts to higher-order values.
%Of course, codomain compliance of a higher-order contract cannot be decided at attachment time.
%Instead, contracts are decomposed and positioned to intercept the arguments and results of application--the earliest possible time that contract compliance can be determined.
%This \emph{de facto} wrapping of deferred contract checks imposes space and time overhead.
%Wadler and his cronies and Herman and his cronies \cite{wadler2009well,herman2010space} show how the accumulation of wrappers can grow unbounded and offer various solutions to ameliorate this.
%Determining contract compliance can make up a significant portion of reduction.

%Higher-order contracts \cite{findler2002contracts} are now familiar constructs of languages but their implementation in Racket, which must cope with other language features--perhaps incidentally, is in terms of value wrappers.
% \emph{impersonators} and \emph{chaperones}.
%In Racket, data contracts are implemented at the bytecode level using interposition primitives--that is, values are wrapped and these wrappers intercept arguments and results.
%Because functions are data in a higher-order language, special care has been given to enforcing safe and sound function contracts.
%Of course, codomain contract compliance cannot be decided.
%In consequence, codomain contract checks are deferred until the function actually delivers a value.

%Nevertheless, analysis tools have access to more of certain kinds of information after compilation and so have the potential to prove more and different properties about programs.
%Specifically, analysis tools for Racket have access to the whole program after module compilation through a \emph{demodularization} process.

%Racket program lifecycle--the tipping of various types of information

% a static analysis defines a class of program transformations
% if the analysis is sound, the transformation is meaning-preserving
% are these two preceding statements true?

%This goal can be sought at each of the various stages of the Racket program lifecycle.
%Initially, programs are organized into modules, and dynamic behavior can be gleaned from contract declarations at module boundaries.\cite{tobin2012higher}
%Each module is compiled in isolation to bytecode; the bytecode compiler performs optimizations which rely on at most basic flow analysis are performed (constant-folding, 
%``The bytecode compiler applies all standard optimizations, such as constant propagation, constant folding, inlining, and dead-code elimination.''
%The journey to this stage discards high-level information and doesn't acquire much new information, so analysis here is probably fruitless.

%Racket modules are compiled to bytecode. This

%implementation of contracts within racket using interposition

%talk about blame and the method Racket uses to assign blame--the compilation process, etc.

We discuss interposition and its relationship to behavioral contracts in more depth in Section 2.
We introduce the syntax and semantics of \chapcalc, a core calculus with facilities for interposing higher-order values, in Section 3.
We present two theorems which establish the conditions for the safe removal or weakening of interposition in Section 4.
We present a static analysis which can judge when these conditions hold in Section 5.
We present performance benchmarks of programs subject to this static analysis in Section 6.
We discuss some language features which require more care to integrate with the present analysis in Section 7.
We conclude by discussing the future application and direction of this work in Section 8.


%impersonators and chaperones

%The \scheme{chaperone-procedure} procedure takes a procedure \scheme{p} to be chaperoned as its first argument and a procedure \scheme{w} to wrap \scheme{p} as its second argument.
%The argument and result arities of \scheme{p} and \scheme{w} must be compatible.
%This means that the argument arity of \scheme{w} must be the same as
%\footnote{Racket procedures can include both mandatory and optional keyword arguments. When considering these, it is necessary only that the set of mandatory keyword arguments of \scheme{p} include those of \scheme{w} and the set of all keyword arguments of \scheme{p} be included in.}
%The result of a \scheme{chaperone-procedure} call is a procedure which, upon invocation, will deliver the arguments to \scheme{w}.
%\begin{enumerate}
%\item The $n$ arguments are delivered to \scheme{w}.
%\item If \scheme{w} returns $n$ results, the results are 
%\end{enumerate}

\setspecialsymbol{LAMBDA0}{$\lambda_0$}
\setspecialsymbol{LAMBDA1}{$\lambda_1$}
\setspecialsymbol{LAMBDA2}{$\lambda_2$}

\setspecialsymbol{LAMBDA}{$\lambda$}
\setspecialsymbol{GE}{$\ge$}
\setspecialsymbol{EPS}{$\epsilon$}

\section{Interposition}

The implementation of familiar language features is sometimes accomplished through alien constructs.
In point of fact, behavioral contracts in Racket are manifest at run time by one of two interposition primitives: \emph{impersonators} and \emph{chaperones}.

An impersonator wraps a value and intercepts operations on it, potentially redirecting the operations arbitrarily.
In the case of higher-order values such as procedures, impersonators intercept arguments and can alter or replace them before passing them to the procedure they wrap.

For instance, the expression
\begin{schemedisplay}
(impersonate-procedure (LAMBDA0 (x) (+ x 1)) (LAMBDA1 (x) (+ x 2)))
\end{schemedisplay}
creates a \emph{procedure impersonator value} which, when applied to a single argument, first applies the $\lambda_1$ closure (the \emph{impersonating} procedure) to that argument and applies the $\lambda_0$ closure (the \emph{impersonated} procedure) to the result.
The net effect of applying this impersonator value, then, is to add three to the argument.

The impersonating procedure can provide a procedure value in addition to its results which will be applied to the results of application of the impersonated procedure.
Modifying our previous example, the expression
\begin{schemedisplay}
(impersonate-procedure (LAMBDA0 (x) (+ x 1))
                       (LAMBDA1 (x) (values (LAMBDA2 (x) (+ x 3)) (+ x 2))))
\end{schemedisplay}
creates a procedure impersonator value which behaves identically to the first example up to return of the impersonated procedure, at which point its result is applied to the $\lambda_2$ closure.
The net effect of applying this impersonator value is to add six---not three---to the argument.

We will often refer to the impersonating procedure as the \emph{negative guard} in reference to the notion of negative blame and the additional ``result impersonator'' result returned by that procedure as the \emph{positive guard} for the same reason. 
In cases where a positive guard is provided, the wrapper analogy is apt as values must pass through an impersonator barrier at both entry to and exit from the procedure.

Chaperones refine impersonators by trading behavioral freedom for reasonability.
Well-behaved procedure chaperones cannot alter intercepted arguments arbitrarily; they may only install chaperones on them.
Chaperones share the ability of impersonators to perform side-effects.
In particular, they retain the ability to raise exceptions, the mechanism by which contract violations are signalled.

As an example of a realistic use of a chaperone, consider the factorial procedure for which a chaperone dynamically enforces the type of its argument and result\footnote{Of course, even without a chaperone, applying the factorial procedure to a non-number argument will provoke an error, but to a non-integer argument will diverge. The chaperone here addresses both cases: it causes blame to be assigned at the procedure level, and encodes the specification sufficiently to avoid divergence.} expressed as
\begin{schemedisplay}
(chaperone-procedure
 (letrec ([fact (LAMBDA (n)
                  (if (= n 0)
                      1
                      (* n (fact (- n 1)))))])
   fact)
 (LAMBDA (n)
   (if (and (integer? n) (GE n 0))
       (values (LAMBDA (n)
                 (if (and (integer? n) (GE n 1))
                     n
                     (raise result error ...)))
               n)
       (raise argument error ...))))
\end{schemedisplay}
The chaperoning procedure is only shallowly installed in that only the initial argument and final result of a factorial application are scrutinized.
This is consistent with the way that chaperones are employed by the contract system: chaperones are attached to values typically only as they pass through module boundaries, and rarely to track intra-module blame.

Finally, we illustrate the rationale of a protocol in which the negative guard produces the positive guard instead of the user providing it to \scheme{chaperone-prodedure} directly.
Consider the installation of a chaperone on the square root function, \scheme{sqrt}, given by
\begin{schemedisplay}
(chaperone-procedure
 sqrt
 (LAMBDA (x)
   (if (and (real? x) (GE x 0))
       (values (LAMBDA (y)
                 (if (and (real? x) (< (abs (- (* y y) x)) EPS))
                     y
                     (raise positive error ...)))
               x)
       (raise negative error ...))))
\end{schemedisplay}
wherein the chaperoning procedure not only refines the domain contract of \scheme{sqrt} (from \scheme{number?} to non-negative \scheme{real?}) but checks its result against a correctness constraint.
In general, allowing the positive guard to be lexically embedded in the negative guard gives the former access to the arguments of the latter which, in turn, allows richer specifications to be expressed, such as dependent contracts \cite{findler2002contracts}.

\subsection{Run-time cost of impersonators and chaperones}

We can put the phases of creation, projection, and application of the contract lifecycle in correspondence with components of the impersonating lifecycle.

The creation time of a contract corresponds with the evaluation of the negative guard procedure expression (typically at installment time) and the positive guard procedure expression (at application time).
In the vast majority of cases, these guard expressions are simple $\lambda$-terms so their contribution to the overall cost of interposition is negligible.

The projection time of a contract corresponds with the installation of an impersonator on a procedure.
This is essentially an atomic operation.

The bulk of the run-time cost of interposition is accrued at application time which corresponds exactly to that of a contract.
The cost incurred is due to enforcement of the interposition protocol.
This entails that
\begin{itemize}
\item negative guards must return the same number of values as given (except for an optional positive guard);
\item the positive guard, if provided, must be a procedure;
\item the positive guard must accept the number of results produced by the impersonated procedure;
\item the positive guard must produce the same number of results as arguments given to it;
\end{itemize}
and, for chaperoning interposition,
\begin{itemize}
\item the negative guard must return only its arguments or chaperoned versions of them; and
\item the positive guard must do likewise.
\end{itemize}

Thus, we would prefer to remove all application costs due to interposition, but will accept merely removing the costs specific to chaperoning.

%Thus, we will enjoy greater run-time cost reduction if we can obviate the chaperoning of a value altogether, but still reduce run-time costs if we can impersonate the value instead.


%The arity of the impersonating procedure must include the arity of the to-be-impersonated procedure, which condition is enforced at impersonator installation time.
%The monitoring chaperones perform on the procedures they wrap takes time and space, but this does not represent all of the run-time cost associated with them.
%Chaperones themselves (and impersonators alike) are monitored to meet a minimum standard of well-behavedness.
%For instance, the runtime ensures that each guard function returns an appropriate number of results, which number depends on the number of arguments supplied at application.
%In addition, arity compatibility of the positive guard must be checked at application time as it is undecidable in general to determine it before the guard itself and the values to which it is to be applied are in hand.
%Where the standard of well-behavedness of chaperones deviates from that of impersonators is in the restriction that guard results must be the same as the arguments given or chaperones of them.





%the bytecode level in terms of interposition installation.
%Higher-order and mutable values are wrapped with \emph{impersonators} which redirect operations on the value and mediate breaches of expectations between the value and its context.
%Impersonators can redirect behavior arbitrarily, which may violate some expectations or invariants the user would like to establish, so contracts are expressed in terms of a restricted form of impersonators, \emph{chaperones}.
%Chaperones are limited to chaperoning values that pass through their membrane and performing side effects (particularly the announcement of a contract violation in the form of an exception).

%Run-time interposition effects a run-time cost: impersonators have to be well-behaved in certain ways the limitations of chaperones must by enforced dynamically.

%Soundly discharging a contract, then, amounts to preventing the installment of the chaperone in the first place.
%If that is not possible, 

%Behavioral contracts on higher-order and mutable objects must be checked on every operation to which the contract pertains--an up-front check is not enough.
%Racket uses run-time interposition to implement value contracts in terms of two proxy primitives: \emph{impersonators} and \emph{chaperones}.

%An impersonator wraps a value and redirects operations on it.

%Impersonators wrap values and redirect operations in which they interpose.

%The implementation of value contracts in Racket is accomplished via \emph{impersonators} and \emph{chaperones}.
%Impersonators and chaperones wrap values and intercept 

%The implementation of higher-order contracts in Racket is accomplished via procedure \emph{impersonators} and \emph{chaperones}.

%Procedure impersonators intercept application arguments and results and forward them to the procedure or context, respectively, although they may modify or replace them before doing so.
%Additionally, they may exhibit side effects.

%Function chaperones refine impersonators in that they are restricted in the modification they can apply to intercepted values.
%Procedure chaperones must return their arguments or chaperones of their arguments.

%Impersonators and chaperones thus constitute an interposed wrapper between values and their contexts, and so we refer to them as \emph{interposition}.

%Interposition is accomplished via two primitives, \emph{impersonators} and \emph{chaperones}.

%Impersonators intercept arguments and results and can modify them arbitrarily before delivering them to their original destination.
%Because such an ability amounts to mutation, impersonators are restricted to values where mutation can be observed, including functions.

%Chaperones refine impersonators in that their interposition is restricted to installing chaperones on arguments and performing side effects--in particular, raising exceptions to signal contract violations and assign blame.

%Higher-order contract checking can introduce enormous overhead to program execution--in real-world programs, as high as 75\% \emph{?}--but we expect that many of the contracts will never be violated.
%The static detection and discharge of these contracts would therefore increase program performance significantly without compromising safety.

%chaperone calculus, including the specific semantics of impersonators and chaperones

%the motivation to soundly discharge or promote a chaperone

%the conditions for a discharge to be sound

%a fixed-point type of algorithm to determine which can be erased
%erase the ones at the "bottom"
%run the analysis again
%keep going until there are none at the bottom
%must handle recursive sites, if that's possible
%we don't have to run the analysis again, just analyze the results

%the result of the analysis is a program transformation on labelled sites

%\section{Chaperone Calculus}

% Racket is big and we don't/can't analyze all of it, nor do we want to report on it, so we deal with a small calculus.
% Part of the purpose is to limit the language; part is to limit the exposition.
% We will clear what is safe and easy to add.

%We consider a small language with facilities for impersonating and chaperoning procedures, \chapcalc.

%We inherit the constraints of impersonators and chaperones from Racket.
%To accommodate these constraints, \chapcalc \scheme{let}- and \scheme{letrec}-binding forms have the same structure as \scheme{λ}-binding forms.
%For example,
%\begin{schemedisplay}
%(let ([(a) (f x)])
%  ...)
%\end{schemedisplay}
%binds the single result of \scheme{(f x)} to \scheme{a}, and \scheme{raise}s if \scheme{(f x)} does not result in exactly one value (just as an application \scheme{raise}s if its arity is incompatible the number of arguments supplied).
%In contrast,
%\begin{schemedisplay}
%(let ([a (f x)])
%  ...)
%\end{schemedisplay}
%binds a list of any number of results of \scheme{(f x)} to \scheme{a}.
%Finally,
%\begin{schemedisplay}
%(let ([(a . b) (f x)])
%  ...)
%\end{schemedisplay}
%binds the first result of \scheme{(f x)} to \scheme{a} and a list of all remaining %results to \scheme{b}.

%This is the grammar for \chapcalc 0.
%\begin{figure*}
%\input{calc0}
%\end{figure*}

%programs either evaluate to a value, evaluate to an error, or diverge.
%our theorem only deals with chaperones which don't affect whether the program evaluates to a value?
%a program could diverge on chaperone creation (evaluating the guards) or chaperone application (applying the guards).
%this is undecidable in general.
%it is possible to remove a chaperone and have some programs that errored out evaluate to a value (because the guards may artificially restrict the domain or codomain of the function).
%it is possible to remove a chaperone and have some programs that errored out diverge (because the error came before divergence).
%if a program evaluates to a value then no chaperone errored out and no chaperone diverged.
%we also are only changing chaperones that don't error in any circumstances.
%therefore, if a program evaluates to a value with a given input before erasure or promotion, it will evaluate to that value after erasure or promotion.
%if a program evaluates to an error with a given input, it will evaluate to an error after, since we will not erase or promote a chaperone that /could/ throw an error, for a sound analysis.
%however, programs that would have diverged otherwise may evaluate to a value or an error.

%Figure whatever defines the grammar for \chapcalc 0 expressions. Expressions \scheme{e} have the following forms
%Procedure applications of the form \scheme{(e e ...)} apply a procedure to a static sequence of arguments.
%The \scheme{app-values} form applies a procedure to a list of values as if the constitent values were supplied statically.
%The \scheme{values} forms returns any number of values as results. 

%The \scheme{or} form is strict in its first expression position.
%The \scheme{and} form is strict in its first expression position.

%To make the handling of wrapper procedures easier, call and return sites are symmetric in \chapcalc. The binding specification of a $\lambda$ form (statically) designates a finite number of arguments to bind individually and an optional \emph{rest} parameter which binds any remaining arguments, as can that of a \scheme{let} or \scheme{letrec} form. If the binding specification of a form does not have a \scheme{rest} parameter, its arity is the number of arguments it binds--a natural number.

%When speaking about operators, we will refer to its arguments arity, which is the set of acceptable numbers of arguments, and its results arity, which is the set of possible numbers of results.

%Figure whatever2 defines the evaluation contexts for \chapcalc 0 expressions.
%Evaluation contexts are either a hole which is the destination for the evaluation of the current redex...

%Figure whatever3 defines the reduction rules for \chapcalc 0.
%Rule blank applies when the redex is an application form and the operator is a closure.
%The result is blank.
%Rule blank applies when the redex is an application form and the operator is a primitive.
%The result is blank or an error.
%Rule blank applies when the redex is an application form and the operator is a chaperone.
%If the arguments arity of the negative guard does not include the number of arguments given, an error is raised.
%The context is extended with a frame annotated with the value and ``negative'' and the arguments given.
%When the results return, etc.

%Decomposition of a term into context and redex is unique and the rule conditions are disjoint, so these rules define a function on terms.

%Let $\longrightarrow\longrightarrow$ be the reflexive, transitive closure of this relation.
%This defines an evaluation function.
%Programs in \chapcalc 0 can result in a value, an error, or divergence.
%\begin{definition}[Soundness]
%If a program $p$ with input $x$ evaluates to a value $v$, then $T[p]$ with input $x$ evaluates to $v$.
%If a program $p$ with input $x$ results in an error, then $T[p]$ with input $x$ results in an error.
%\end{definition}

%While blame is an apt description of the judgment we are making, our notion of blame is not the same as [Findler and Wadler].
%The category of behaviors for which we must account include whether errors arise as a result of chaperone creation or chaperone application.
%In each case, we are concerned with the creation site of the chaperone application.
%If an error arises as a result

%While there is only one mechanism to provoke errors, the erroneous result of the program resides in one of four classes depending on the state of execution at the time of provocation.
%(Bad format below.)
%\begin{enumerate}
%\item If evaluation of a \scheme{chaperone-operator} application is occurring, the error is transformed to a blame assignment of that site.
%\item If evaluation of the negative guard of a chaperone is occurring, the error becomes \scheme{(blame -L)}.
%\item If evaluation of the positive guard of a chaperone is occurring, the error becomes ...
%\item none means none
%\item if the negative guard does more than chaperone arguments, blame should be assigned to the guard in some sense, indicating that not only can the guard not be discharged, but the chaperone site also cannot be demoted to an impersonator. (remember the types of errors we need to track!)
%\end{enumerate}
%An error is transformed according to the innermost part of the context which meets the criteria.

% make a redex model of the language
% generate random program
% run analysis on random program
% transform according to analysis
% ensure that the result is the same
% generate random program that takes input (either lists, functions, or numbers)
% run analysis
% transform according to analysis
% ensure that the result is the same for a set of random inputs

%Our transformation preserves valid evaluation and preserves erroneous evaluation.
%We do not (and cannot) say anything about divergent evaluation.
%$T[p]$ may converge on some input $x$ where $p$ diverged.

%By this definition, the identity transformation is sound. We will take the position that if the creation or application of a chaperone value \emph{may} result in an error, we will not discharge it. Only when our conservative analysis indicates that an error cannot be raised will we discharge it.

%As an error is raised, it starts to unwind the stack. If a negative frame is encountered, blame is allocated to over p (negative p). Similarly for a positive frame. If neither type of frame is encountered, the result is simply \scheme{error}.

%The \scheme{chaperone-operator} operator takes as arguments: an operator \scheme{f} to be chaperoned, an operator \scheme{neg-wrap} which must have the same argument arities as \scheme{f} and produce as many results as arguments given, and an operator \scheme{pos-wrap} which must have the same result arities as \scheme{f} and accept as many arguments as results produced.

%For each wrapper, then, there are two properties which must be enforced.
%Of these four properties, only one--that \scheme{neg-wrap} has the same argument arity as \scheme{f}--can be enforced at chaperone creation (and Racket takes this approach). For simplicity and understandability, we will initially defer enforcement of each of these properties until chaperone invocation.

%Definition: call an impersonator value \emph{well-behaved} with respect to a program if it never \scheme{raise}s as a result of an arity mismatch and its wrappers preserve arities.

%[m] -> neg-wrap -> [m] -> f -> [n] -> pos-wrap -> [n]

%talk about the run-time cost of chaperones and the optimizations we would like to perform:

%STILL NEED CHAPERONE VALUES TO TRACK THEIR CREATING CHAPERONE (OR AT LEAST ITS LABEL).


%Guards can fail by raising an error. (This error is translated into a blame error by the context?)
%Guards can also fail by changing their arguments more than chaperoning.

%A guard that never raises an error and does not chaperone any of its arguments is ``OK''.
%A chaperone with an ``OK'' negative guard and an ``OK'' positive guard is ``OK''.
%A guard that never raises an error and only creates ``OK'' chaperones is ``OK''.
%An ``OK'' guard can be replaced with \scheme{values}.
%A chaperone creation site that never raises and with only ``OK'' guards is ``OK''.
%An ``OK'' chaperone creation site can be replaced with its first argument.

%If a program $p$ with input $x$ evaluates to a value $v$, then program $p$ with an ``OK'' chaperone creation site replaced with its first argument evaluates to $v$.

%Definition: call a chaperone value well-behaved with respect to a program if it is a well-behaved impersonator and every result of its wrappers is \scheme{chaperone-of?} the corresponding argument.

%\subsection{Handling \emph{handle}}

%Exception handlers prevent certain errors from escaping a particular dynamic extent.
%Consider the program
%\begin{schemedisplay}
%(handle
%  (chaperone-operator + (raise) (raise))
%  -)
%\end{schemedisplay}
%wherein an error is always raised and the handler always triggered.
%Even though an exception never escapes the dynamic extent of the \scheme{handle} expression, replacing the \scheme{chaperone-operator} application with its first argument results in a different program. 
%This means that we must consider whether a \scheme{chaperone-operator} application ever raises an error, and not simply if that error escapes a delimited extent.
% being able to catch errors means that errors can change the meaning of a program arbitrarily--even if it results in a value.
% this means that we need to preserve errors
% chaperone-of? within the language can change the behavior, right? if it was a chaperone before, removing the chaperone makes it still chaperone-of? it's chaperone? that makes it possible to detect changes, but that is discouraged, and we will leave it out of our language.

%[m] -> neg-wrap -> C[m] -> f -> [n] -> pos-wrap -> C[n]



\section{Chaperone Calculus}

In order to explicate a static analysis of higher-order interposition, we define \chapcalc, or \emph{chaperone calculus}, an extension of the A-normalized $\lambda$-calculus with interposition facilities.

As only a moderate extension of the $\lambda$-calculus, \chapcalc\ lacks many Racket features, not the least of which is mutation.
We will see, in addition, that both \scheme{chaperone-operator} and \scheme{impersonate-operator} exist as tags of syntactic forms instead of first-class values as are their counterparts in Racket.
Providing them as first-class entities would increase the expressive power [cite Felleisen] of \chapcalc\ and, in general, require a more powerful analysis.
In practice, \scheme{chaperone-operator} and \scheme{impersonate-operator} are most often referenced directly by name and so treated more as syntactic tags.
We will treat them so specifically to simplify the presentation of the analysis, but discuss a strategy to integrate first-class uses of them in Section ?.
%In the actual analysis, we consider all call sites and add a condition for the sound discharge of a call site that \scheme{chaperone-operator} is the only values to flow to the operator position.

\subsection{\chapcalc\ Syntax}

The syntax of \chapcalc\ can be seen in figure \ref{fig:syntax}.

\chapcalc\ inherits application, abstraction, and variable terms from the $\lambda$-calculus.
It includes simple values from the domain of integers and booleans as well as a set of first-class primitive functions which operate over these values.

The syntactic class $\ae$ signifies \emph{atomic expressions} and includes $\lambda$-terms, variables, and the simple values of booleans, integers, and primitive functions. These expressions will never produce an error or diverge but will always produce a value.

The syntactic class $c$ denotes application terms which are formed by an atomic operator expression followed by a sequence of atomic operand expressions.

The syntatic class of expressions, denoted $e$, includes \scheme{let}, \scheme{letrec}, \scheme{if} expressions as well as \scheme{chaperone-operator} and \scheme{impersonate-operator} forms.

Each \scheme{chaperone-operator} form is annotated with a unique label $\ell$ to keep otherwise identical terms distinguishable.

The second subform of a \scheme{chaperone-operator} or \scheme{impersonate-operator} remains a proper expression to facilitate some of the blame semantics.

\newcommand{\vx}[0]{\mathbf{x}}

\newcommand{\appe}[2]{(#1\,#2)}
\newcommand{\lame}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\chae}[2]{(\mathit{chaperone\mhyphen operator}\,#1\,#2)^\ell}
\newcommand{\impe}[2]{(\mathit{impersonate\mhyphen operator}\,#1\,#2)}
\newcommand{\lete}[3]{(\mathbf{let}\,((#1)\,#2)\,#3)}
\newcommand{\letrece}[3]{(\mathbf{letrec}\,((#1)\,#2)\,#3)}
\newcommand{\ife}[3]{(\mathbf{if}\,#1\,#2\,#3)}

\newcommand{\ande}[2]{(\mathrm{and}\,#1\,#2)}
\newcommand{\ore}[2]{(\mathrm{or}\,#1\,#2)}

\newcommand{\true}[0]{\mathrm{\#t}}
\newcommand{\false}[0]{\mathrm{\#f}}
\setlength{\tabcolsep}{1pt}
\begin{figure}
\label{fig:syntax}
%\begin{tabular}{rcl}
%c & = & $\appe{e}{e\,\dots}$ & application\\
%\end{tabular}

\begin{align*}
c &= \appe{\ae}{\ae\,\dots} && \text{application}\\
e &= \lete{x\,\dots}{c}{e} && \text{let}\\
  &|  \letrece{x\,\dots}{c}{e} && \text{letrec}\\
  &|  \ife{\ae}{e}{e} && \text{if}\\
  &   \chae{\ae}{e} && \text{chaperone-operator}\\
  &   \impe{\ae}{e} && \text{impersonate-operator}\\
\ae &= \lame{x\,\dots}{e}\,|\,x\,|\,p\,|\,i\,|\,b && tsh\\
p &= values | = | < | > | + | - | not | integer? | boolean? | operator? | raise && \\
x &= ha & \\
i &= 0|1|-1|2|-2|\dots\\
b &= \true\,|\,\false\\
\end{align*}

\begin{tabular}{rrl}
$c$ & = & $\appe{\ae}{\ae\,\dots}$\\
$e$ & = & $\lete{x\,\dots}{c}{e}$\\
    & | & $\letrece{x\,\dots}{c}{e}$\\
g & h & i
\end{tabular}
\caption{The syntax of \chapcalc.}
\end{figure}

A program is a term in the grammar with no free variables and in which all identifiers in the same binding form are pairwise distinct.




% raise integer? boolean? not operator? + - * = < > values
% need primitives to allow contracts to deal higher orderly
% ae := (lambda s e) x primitive integer boolean

% (ae ae ...)
% (app-values ae ae)
% (chaperone-operator ae ae ae)
% (impersonate-operator ae ae ae)
% (let ([s call]) e)
% (letrec ([s call]) e) IS IT POSSIBLE TO LIFT AN EXPRESSION OUT THAT SHOULDN'T BE?
% (if ae e e)
% (lambda s e)

% results are:
% values: closures, chaperones, impersonators, primitives, integers, booleans
% errors: error, blame L, blame +L, blame -L

% (e e1 ... en),\rho,\sigma,\kappas
% v = A(e,\rho,\sigma), vi = A(ei,\rho,\sigma)
% case v
%   ((lambda s e'),\rho')
%   if s compatible with n
%     (e',\rho'',\sigma',\kappas) where \rho'' and \sigma' bind vis according to s
%     error
%   primitive
%   if primitive arity compatible with n
%     \delta(primitive,v1,...,vn)
%     error
%   (chaperone L f neg pos)
%   (lambda vs
%     (let ([vs' (app-values neg vs)])
%       (if (= (length vs)
%              (length vs'))
%           (if (and-map chaperone-of? vs' vs)
%               (let ([rs' (app-values f vs')])
%                 (if (arity-comp? pos rs')
%                     (let ([rs (app-values pos rs')])
%                       (if (= (length rs')
%                              (length rs))
%                           (if (and-map chaperone-of? rs rs')
%                               (app-values values rs)
%                               (error)) (blame + guard)
%                           (error))) (blame + guard)
%                     (error))) (blame + guard)
%               (error)) (blame - guard)
%           (error)))) (blame - guard)

\newcommand{\A}[3]{\mathcal{A}(#1,#2,#3)}

\newcommand{\dynbla}[1]{\mathrm{dynamic\mhyphen blame}(#1)}

\newcommand{\ks}[0]{\kappa s}
\newcommand{\vv}[0]{\mathbf{v}}
\newcommand{\vvp}[0]{\mathbf{v'}}
\newcommand{\sexp}[4]{\Sigma_e(#1,#2,#3,#4)}
\newcommand{\sval}[3]{\Sigma_v(#1,#2,#3)}
\newcommand{\sapp}[4]{\Sigma_a(#1,#2,#3,#4)}
\newcommand{\scha}[6]{\Sigma_d(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdchaz}[6]{\Sigma_{chap_0}(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdchao}[5]{\Sigma_{chap_1}(#1,#2,#3,#4,#5)}
\newcommand{\serr}[0]{\mathrm{error}}
\newcommand{\sbla}[2]{\mathrm{blame}_{#1}(#2)}
\newcommand{\app}[4]{\mathrm{apply}(#1,#2,#3,#4)}
\newcommand{\red}[2]{\begin{align*}& #1\\\rr\, & #2\end{align*}}

\newcommand{\bind}[4]{\mathrm{bind}(#1,#2,#3,#4)}
\newcommand{\prebind}[2]{\mathrm{pre\mhyphen bind}(#1,#2)}
\newcommand{\recbind}[4]{\mathrm{rec\mhyphen bind}(#1,#2,#3,#4)}

\newcommand{\clo}[2]{(#1,#2)}
\newcommand{\cha}[2]{\mathrm{chaperone}(\ell,#1,#2)}
\newcommand{\imp}[2]{\mathrm{impersonator}(#1,#2)}

\newcommand{\chak}[1]{\mathrm{chap}_\kappa(\ell,#1)}
\newcommand{\chacwk}[2]{\mathrm{chap\mhyphen neg\mhyphen ults}_\kappa(\ell,#1,#2)}
\newcommand{\chacfk}[1]{\mathrm{chap\mhyphen fun\mhyphen ults}_\kappa(\ell,#1)}
\newcommand{\chacrk}[1]{\mathrm{chap\mhyphen pos\mhyphen ults}_\kappa(\ell,#1)}

\newcommand{\impk}[1]{\mathrm{imp}_\kappa(\ell,#1)}
\newcommand{\impcwk}[2]{\mathrm{imp\mhyphen neg\mhyphen ults}_\kappa(\ell,#1,#2)}
\newcommand{\impcfk}[1]{\mathrm{imp\mhyphen fun\mhyphen ults}_\kappa(\ell,#1)}
\newcommand{\impcrk}[1]{\mathrm{imp\mhyphen pos\mhyphen ults}_\kappa(\ell,#1)}


\newcommand{\letk}[3]{\mathrm{let}_\kappa(#1,#2,#3)}
\newcommand{\letreck}[3]{\mathrm{letrec}_\kappa(#1,#2,#3)}


\newcommand{\rr}{\longrightarrow}
\newcommand{\rrs}{\longrightarrow^{*}}

\subsection{$\chapcalc$ Semantics}

expression: forms + primitives + booleans + numbers + labels + variables
value: primitive + boolean + number + closure + impersonator + chaperone
semantics: stack frame + stack (sequence of frames) + store + address + environment as finite map
$\Gamma^{*}$

We use boldface to denote a vector of objects in that category, i.e., $\mathbf{v}$ denotes a vector $\langle v_1,\dots,v_n\\rangle$ for some natural number $n$.

We define the semantics of \chapcalc\ in terms of an abstract machine similar to Felleisen's CESK machine[cite that] to directly apply a particular static analysis.

With the introduction of chaperones and impersonators (and the incusion of primitive functions), we can no longer count on the operator of an application to be a closure.
Thus, we will treat these three categories of values as classes of \emph{operators} and will refer to them collectively as such.

In difference, our machine is defined in terms of multiple state variants.
\begin{itemize}
\item An \emph{evaluation} state $\varsigma=\Sigma_{e}(\Gamma^{*},\sigma,\rho,e)$, corresponds to a traditional CESK state.
(The order of the components is reversed, however, to aid factoring out common components from among the variants.)

$\varsigma\in\mathrm{Kont}\times\mathrm{Sto}\times\mathrm{Env}\times\mathrm{Exp}$

\item An \emph{apply} state, tagged $\Sigma_{a}$, represents a point of application and dispatches on the operator type (closure, impersonator, or primitive).
\item A \emph{value} state, tagged $\Sigma_{v}$, represents a point of return and dispatches on the type of the top continuation frame.
If the continuation is empty, the constituent values are the results of the program.
\item An \emph{error} state, tagged $\Sigma_!$, represents the arisal of an error and, as the result of the program, may include blame information.
\item Finally, we define a set of \emph{dummy} states which splits a transition which would otherwise pop and push a frame simulaneously into a sequence of two transitions which performs each separately.
(This eases further the transition to a pushdown system.)
\end{itemize}


%\begin{figure}
%\begin{align*}
%  c \in \sa{Conf} &= \syn{Exp} \times \sa{Env} \times \sa{Store} \times \sa{Kont} && %\text{[configurations]}
%  \\
%  \aenv \in \sa{Env} &= \syn{Var} \parto \sa{Addr} && \text{[environments]}
%  \\
%  \astore \in \sa{Store} &= \sa{Addr} \to \Pow{\sa{Clo}} && \text{[stores]}
  % \\
  % \aden \in \sa{Den} &= \Pow{\sa{Clo}} && \text{[denotable values]}
%  \\
%  \aclo \in \sa{Clo} &= \syn{Lam} \times \sa{Env} && \text{[closures]}
%  \\
%  \acont \in \sa{Kont} &= \sa{Frame}^* && \text{[continuations]}
%  \\
%  \Gamma \in \sa{Frame} &= \syn{Var} \times \syn{Exp} \times \sa{Env}  && \text{[stack frames]}
%  \\
%  \alpha \in \sa{Addr} &\text{ is a \emph{finite} set of addresses} && \text{[addresses]}
%  \text.
%\end{align*}
%\caption{The abstract configuration-space.}
%\label{fig:abs-conf-space}
%\end{figure}


The result of a program is
\begin{itemize}
\item \emph{values} taken from the set of simple values or run-time values of closures, impersonators, and chaperones,
\item an \emph{error} which may include blame information indicating the source of the error, or
\item divergence.
\end{itemize}

A program is injected into a machine state with the function $\mathcal{I} : e\rightarrow\Sigma$ defined as $\mathcal{I}(p)=\sexp{\langle\rangle}{\perp}{\perp}{p}$.

The reduction relation is defined first in terms of the class of machine state.

\subsubsection{application}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\appe{\ae_f}{\ae_1\,\dots\,\ae_n}}}{\sapp{\ks}{\sigma}{f}{\langle v_1,\dots,v_n\rangle}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$ and $v_i=\A{\sigma}{\rho}{\ae_i}$ for $i=1,\dots,n$.

\subsubsection{chaperone-operator}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\chae{\ae_f}{e_w}}}{\sexp{\chak{f}::\ks}{\sigma}{\rho}{e_w}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$.

\noindent
\red{\sval{\chak{f}::\ks}{\sigma}{\vv}}{\sval{\ks}{\sigma}{\langle\cha{f}{w}\rangle}}

\noindent
%where $\alpha_f=\mathrm{alloc}(\sigma,f)$ and $\alpha_w=\mathrm{alloc}(\sigma,w)$
if $\vv=\langle w\rangle$ for some value $w$, $\mathrm{operator?}(f)$, $\mathrm{operator?}(w)$, and $\mathrm{arity}(w)=\mathrm{arity}(f)$.

\noindent
\red{\sval{\chak{f}::\ks}{\sigma}{\vv}}{\sbla{2,8,9}{\ell}}

\noindent
if $\vv\ne\langle w\rangle$ for any value $w$, $\mathrm{operator?}(f)$ does not hold, $\mathrm{operator?}(w)$ does not hold, or $\mathrm{arity}(w)\ne\mathrm{arity}(f)$.

%$\red{\sval{\chak{\rho}{e_w}::\ks}{\sigma}{\vv}}{\scha{\ks}{\sigma}{\rho}{e_w}{\ell}{f}}$
%if $\vv=\langle f\rangle$ for some $f$ such that $\mathrm{operator?}(f)$

%$\red{\sval{\chak{f}::\ks}{\sigma}{\vv}}{\sbla{\ell}}$
%if $\vv=\langle f\rangle$ for some $f$ where $\mathrm{operator?}(f)$ does not hold

%We assign blame to $\ell$ here because if we were to replace this \scheme{chaperone-operator} form with its first subform, this error would not be raised unless and until the resultant value was applied.
%Because it is not necessarily applied, deferring the error changes the meaning of the program.

%$\red{\sval{\chapk{\rho}{e_w}::\ks}{\sigma}{\vv}}{\serr}$
%if $\vv\ne\langle f\rangle$ for any $f$

%$\red{\scha{\ks}{\sigma}{\rho}{e_w}{\ell}{f}}{\sexp{\chawk{f}::\ks}{\sigma}{\rho}{e_w}}$

%$\red{\sval{\chawk{f}::\ks}{\sigma}{\vv}}{\sval{\ks}{\sigma}{?}}$
%if $\vv=\langle g\rangle$ for some $g$ such that $\mathrm{operator?}(g)$ and %$\mathrm{arity}(f)=\mathrm{arity}(g)$

%$\red{\sval{\chawk{f}::\ks}{\sigma}{\vv}}{\sbla{\ell}}$
%if $\vv\ne\langle g\rangle$ for any $g$ or $\vv=\langle g\rangle$ for some $g$ where $\mathrm{operator?}(g)$ does not hold or $\mathrm{arity}(f)\ne\mathrm{arity}(g)$

%We assign blame to $\ell$ here for the same reasons we did before.

% we can blame the chaperone creation site which precludes its removal
% we can blame the wrapper functions for not chaperoning the arguments

\subsubsection{impersonate-operator}

%\red{\sexp{\ks}{\sigma}{\rho}{\impe{e_f}{e_w}}}{}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\impe{\ae_f}{e_w}}}{\sexp{\impk{f}::\ks}{\sigma}{\rho}{e_w}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$.

\noindent
\red{\sval{\impk{f}::\ks}{\sigma}{\vv}}{\sval{\ks}{\sigma}{\langle\imp{f}{w}\rangle}}

\noindent
if $\vv=\langle w\rangle$ for some value $w$, $\mathrm{operator?}(f)$, $\mathrm{operator?}(w)$, and $\mathrm{arity}(w)=\mathrm{arity}(f)$.

\noindent
\red{\sval{\impk{f}::\ks}{\sigma}{\vv}}{\dynbla{\ks}}

\noindent
if $\vv\ne\langle w\rangle$ for any value $w$, $\mathrm{operator?}(f)$ does not hold, $\mathrm{operator?}(w)$ does not hold, or $\mathrm{arity}(w)\ne\mathrm{arity}(f)$.

\subsubsection{let}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\lete{x_1\,\dots\, x_n}{e_0}{e_1}}}{\sexp{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\rho}{e_0}}

\noindent
where $\vx=\langle x_1,\dots,x_n\rangle$.

\red{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma'}{\rho'}{e_1}}

\noindent
where $(\sigma',\rho')=\bind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

\red{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\dynbla{\ks}} if $|\vx|\ne|\vv|$

\subsubsection{letrec}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\letrece{x_1\,\dots\, x_n}{e_0}{e_1}}}{\sexp{\letk{\rho'}{\vx}{e_1}::\ks}{\sigma}{\rho}{e_0}}

\noindent
where $\vx=\langle x_1,\dots,x_n\rangle$ and $\rho'=\prebind{\rho}{\vx}$.

\red{\sval{\letreck{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma'}{\rho}{e_1}}

\noindent
where $\sigma'=\recbind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

\red{\sval{\letreck{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\dynbla{\ks}} if $|\vx|\ne|\vv|$

\subsubsection{if}

\red{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}{\sexp{\ks}{\sigma}{\rho}{e_c}}
if $v_t\ne\false$
where $v_t=\A{\sigma}{\rho}{\ae_t}$.

\red{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}{\sexp{\ks}{\sigma}{\rho}{e_a}}
if $v_t=\false$
where $v_t=\A{\sigma}{\rho}{\ae_t}$.

%$\red{\sval{\ifk{\rho}{e_c}{e_a}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma}{\rho}{e_c}}$
%if $\vv=\langle v_0\rangle$ for some $v_0\ne\false$

%$\red{\sval{\ifk{\rho}{e_c}{e_a}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma}{\rho}{e_a}}$
%if $\vv=\langle v_0\rangle$ for $v_0=\false$

%$\red{\sval{\ifk{\rho}{e_c}{e_a}::\ks}{\sigma}{\vv}}{\serr}$
%if $\vv\ne\langle v_0\rangle$ for any $v_0$

% primitive
% integer
% boolean
% (lambda s e)
% x

\subsection{apply}

\emph{apply} states serve as the branching point for dispatch on the operator.

\subsubsection{closure}

The application of a closure operator proceeds straightforwardly by extending its environment and evaluating its body.

\red{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}{\sexp{\ks}{\sigma'}{\rho'}{e}}
where $\vx=\langle x_1,\dots,x_n\rangle$ and $(\sigma',\rho')=\bind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

If the number of values applied is incompatible with the arity of the closure, blame is assigned dynamically.

\red{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}{\dynbla{\ks}}
if $|\vx|\ne|\vv|$ where $\vx=\langle x_1,\dots,x_n\rangle$

\subsubsection{chaperone}

Chaperone application recurs on its guard and augments the context to complete the interposition when its guard returns.
The enlarged context is annotated with the label of the applied chaperone (which itself is the label of its installment site).

\red{\sapp{\ks}{\sigma}{\cha{f}{w}}{\vv}}{\sapp{\chacwk{f}{\vv}::\ks}{\sigma}{w}{\vv}}

When the results of its wrapper are obtained, the next state is determined by the results.
If an additional result is provided and it is an operator, it is situated to intercept function results.

If the number of results obtained is the same as the number of arguments given, the interposition ceases and the function can be evaluated in tail position with respect to the chaperone application.

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sapp{\ks}{\sigma}{f}{\vvp}}
if $|\vv|=|\vvp|$ and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{1}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold.

--

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}
if $|\vv|=|\vvp|$, $\mathrm{operator?}(w)$, and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{3}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{operator?}(w)$ does not hold.

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{1}{\ell}}
if $|\vv|=|\vvp|$ and $\mathrm{operator?}(w)$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold.

--

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{4}{\ell}}
if $|\vv|\ne|\vvp|$ and $|\vv|+1\ne|\vvp|$

\red{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}{\sapp{\chacfk{w}::\ks}{\sigma}{f}{\vvp}}

\red{\sval{\chacfk{w}::\ks}{\sigma}{\vv}}{\sdchao{\ks}{\sigma}{w}{\vv}{\ell}}

\red{\sdchao{\ks}{\sigma}{w}{\vv}{\ell}}{\app{\chacrk{\vv}::\ks}{\sigma}{w}{\vv}}




\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sval{\ks}{\sigma}{\vvp}}
if $|\vv|=|\vvp|$ and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sbla{7}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold

\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sbla{6}{\ell}}
if $|\vv|\ne|\vvp|$





%$\mathrm{apply}(\kappa s,\sigma,\mathrm{chap}(f,w),\mathbf{v})=\mathrm{apply}(\mathrm{chap\mhyphen ults}_\kappa(f,\mathbf{v})::\kappa s,\sigma,w,\mathbf{v})$

%$\dynbla{\chawk{f}::\kappa s}=\sbla{\ell}$

%$\dynbla{\chawk{f}::\kappa s}=\sbla{\ell}$

%$\dynbla{\kappa ::\kappa s}=\dynbla{\kappa s}$ for other $\kappa$

%$\dynbla{\langle\rangle}=\serr$

% we can't have the chaperones carry around their parent chaperone label also because
% that set will increase as the analysis runs but we don't want to have to prove
% soundness to update the existing chaperone values (it may not even be sound)
% however, at each chaperone creation site, we build up a conservative approximation
% of the set of creators, and we can refer to that.
% does this suggest that blame should be deferred until the graph is completely built?
% unless we can target the blame with absolute precision, I think so.

% arity error on application to negative guard:
% the blame should not rest on the chaperone, because, at creation time, the negative guard was determined to have the same arity as the function, and the error would have been thrown regardless. we might want to defer the arity checking until chaperone application/invocation for symmetry, but the semantics are different: a program with an unused chaperone value might fail if it was checked eagerly, but wouldn't if it was checked lazily.
% number of results not number of arguments on negative guard:
% blame negative guard because values would not raise this (which means chaperone discharge would not either)
% results not chaperone-of? the arguments
% blame negative guard because values would not produce this
% if a guard throws an error (transitions to an error, really), we wait until the analysis is over to assign blame because we need to know what's in the stack and we don't get that fully until the end.
% application of f to guard results will not throw (not because of arity, and also because a user program cannot distinguish between a chaperone of a value and a value)
% application of pos guard to results of f may throw for arity
% blame positive guard because values would not do this
% number of results not number of arguments:
% blame positive guard because values would not do this
% results not chaperone-of? the arguments
% blame positive guard because values would not do this

% at the end, we have a transition graph. there are error states and a few direct blame states. for each chaperone creation state (and so label), we determine the set of signed labels that correspond to chaperone guards that were active at its creation.
% for every error state, we determine the set of signed labels that correspond to chaperone labels that were active at its raise.
% we then use these maps to determine which chaperones are blameless!

% NOW, is it true that, when an error is thrown, we can actually bound its source to the current approximation of the stack?
% is it true that, when a chaperone is created, we can bound its source to the current approximation of the stack?
% I don't think so because later states may raise errors that are directed to the same place and those errors might not be blamed on the right party.

% ACTUALLY when we apply a chaperone, we check whether the operator can accept that number of arguments. if not, we throw an error (with no blame!)
% this means that a negative guard can be treated like a positive guard

%Changing the form of \scheme{chaperone-procedure} to take the negative and positive guards more explicitly doesn't actually make it more understandable in the long run, and doing it to avoid dealing with dependent contracts is unnecessary.

%First, in doing so, we have to account for the possibility of the evaluation of the positive guard resulting in an error. Granted, we expect most guards to be variables or lambda expressions, but they are not constrained to be. In the current calculus, the evaluation of a positive guard resulting in an error would be blamed on the chaperone call itself, still opening the door for the negative guard to be replaced with values. In a more accurate calculus, that error would be attributed to the negative guard itself.

\section{Chaperone Discharge and Demotion}

\subsection{Expectation that many dynamic checks are unnecessary}

Programs that can result in an error are incorrect.
The purpose of blame assignment is to facilitate the act of correcting the program.
We expect a program to result in a blame assignment only rarely.
We have similar expections for a program to result in divergence, and that specifically at the hand of a chaperoned value.
In fact, we expect correct programs never to exhibit such behavior, and while chaperones serve the reality of incorrect programs, the frequency of their complaints diminishes in the long run as the programmer applies their feedback.
The nature of the programming cycle indicates that there may be some chaperones which, situated within a particular program, do not influence the behavior of the program and also that the proportion of chaperoned values in such a position may increase as the program is maintained.

\subsection{Intuition behind sound discharge}

The conditions necessary for the sound discharge of a chaperone are more easily constructed by considering the conditions sufficient for a chaperone to be meaningful.
If we can enumerate a complete set of these conditions in the sense that any meaningful chaperone must meet at least one of the conditions, we obtain the soundness conditions by complement.

A chaperone \emph{cannot} be discharged if
\begin{enumerate}
\item the negative guard causes an error to be raised,
\item the negative guard diverges,
\item the negative guard does not return the same number of results as arguments given (or one extra),
\item the extra result, if provided, is not a procedure,
\item the results of the negative guard are not, at most, chaperones of the arguments,
\item the positive guard does not accept the number of results produced by the chaperoned procedure,
\item the positive guard causes an error to be raised,
\item the positive guard diverges,
\item the positive guard does not return the same number of results as arguments given, or
\item the results of the positive guard are not, at most, chaperones of the arguments.
\end{enumerate}

For a given program execution, if neither a chaperone nor its installation raises an error or diverges, it is a candidate for \emph{discharge}, or the [omission/removal] of its installation.
It is only a candidate because its application may cause a chaperone to be installed and that chaperone may not be well-behaved.
In this case, discharging the original chaperone would prevent a meaningful chaperone from being created which would make discharge unsound.
Then, intuitively, a chaperone can be discharged if it will not raise an error or diverge  \emph{and} any chaperones it installs can be discharged.

The discharge of a chaperone amounts to replacing its installation site with that site's first argument
However, multiple chaperone installations may occur at a given chaperone installation site during program execution, so we cannot, in all circumstances, selectively prevent the creation of a single chaperone.
Instead, we consider the discharge of installment sites themselves.
The conditions to discharge a given site are stronger than that of a chaperone installed at that site: instead of demonstrating that a single chaperone satisfies a property, we must demonstrate that every chaperone created at that site satisfies that property \emph{and} that there is no chaperone installation at that site for which
\begin{enumerate}
\item the evaluation of its guard expression causes an error to be raised,
\item the evaluation of its guard expression diverges, or
\item the negative guard does not accept the same number of arguments as the procedure to be chaperoned.
\end{enumerate}

When put in these terms, it is clear that a chaperone installment site can be discharged only if it meets these conditions for every possible execution.
These conditions seem onerous.
Indeed, in Racket, users typically access chaperone installation through a library wrapper so all chaperones in the entire program share the same installation site.
This, in turn, means that a given chaperone can be safely discharged only if \emph{all} chaperones in all executions of the program can be safely discharged.
%In other words, the program must be correct up to the encoded specification.
Fortunately, with access to the whole program, we may inline definitions which allows us to multiply the number of installment sites in the program.

%In such cases, we may not be able to discharge only a particular chaperone.
%We therefore strengthen the discharge condition that 

\subsection{Intuition behind demotion}

Much of the run-time overhead of chaperones is shared by impersonators.
Nevertheless, the enforcement of certain invariants specific to chaperones is somewhat costly --- specifically, the enforcement that chaperone guards at most install chaperones on their arguments.
The conditions to \emph{demote} the set of chaperones installed at a particular site to impersonators (by replacing the \scheme{chaperone-operator} installment site with \scheme{impersonate-operator}) are immediately weaker than to discharge the site entirely: we need to demonstrate only that the chaperone guards do not arbitrarily modify their arguments (conditions 5 and 10 above) for it to be a candidate for demotion.
If one of this site's chaperones is installed on the argument of a chaperone guard, demoting this site to install merely an impersonator will make an otherwise well-behaved chaperone not so.
This observation provides us with the intuition behind sound site demotion: a chaperone may be demoted if neither of its guards do more than install chaperones on their arguments for all program executions and the chaperone which guard installed it, if any, can be and is demoted. 
We once again lift the conditions to chaperone installment sites so that a chaperone installment site can be demoted if all chaperones installed there in any program execution can be demoted and the installment sites of any installing chaperones can be and are demoted.

\subsection{More formal notion of discharge and demotion}

Formally, the discharge or demotion of a chaperone installment site is defined in terms of simple program transformers.

\begin{definition}
A \emph{discharge transformation} $D_\ell : P\rightarrow P$ is a program transformation which replaces a chaperone-installment site labelled $\ell$ with its first subform.
\end{definition}

\begin{definition}
A \emph{demotion transformation} $E_\ell : P\rightarrow P$ is a program transformation which replaces a chaperone-installment site labelled $\ell$ with an impersonator-installment site with the same subforms.
\end{definition}

We assume that each chaperone-installment site is labelled uniquely within a program.
Then, as formulated, these transformations can affect only one site.
We will see that transformations which meet a set of soundness conditions can be composed and reordered.
%they unambiguously define a more powerful transformation

%We will now make the notion of safe chaperone discharge and demotion more formal.
%We begin with some definitions.

%We will consider all the conditions jointly necessary for sound discharge, but it may be helpful to instead consider all the conditions which are disjointly sufficient to prevent discharge.
%If we can enumerate a complete set of conditions under which discharge is unsound, then we can take the complement (and conjunction) to have a set under which discharge is sound.

%consider all the conditions under which a chaperone installment site can affect evaluation

% a chaperone installment site can be discharged if
% it never causes an error in installation
% all its chaperones never raise an error ("static" or "dynamic")
% all the chaperone installment sites it activates can be discharged

% a chaperone installment site /cannot/ be discharged if:
% an error is raised during evaluation of the guard (dynamic blame)
% an error is raised during projection (static blame of arity mismatch, or non-procedure)
% one of its installed chaperones raises a dynamic error
% one of its installed chaperones raises a static error
% one of the installment sites used while one of its chaperones is active cannot be discharged

% a chaperone installment site /cannot/ be demoted if:
% a chaperone created their more than chaperones its arguments
% a chaperone installment site it depends on is not soundly demoted

\begin{definition}
A chaperoned operator is \emph{active} if evaluation is within the dynamic extent of its negative or positive guard.
\end{definition}

\begin{definition}
A chaperone installment site labelled \emph{depends} on a chaperoned operator if that operator is active when the installment site is evaluated.
\end{definition}



\begin{definition}
An error \emph{depends} on a chaperoned operator if that operator is active at the time the error is raised.
\end{definition}

Chaperone guards may themselves invoke chaperoned operators, so there may be more than one active chaperone at any given time.

%We call the most-recently-activated chaperone the \emph{youngest} chaperone.
%At evaluation time of a chaperone installment site, we say that the youngest chaperone is \emph{dependent} on the site.
%Because a given chaperone installment site may be evaluated multiple times during program execution and from multiple control paths, a chaperone creation site may have several dependent chaperones.

\subsection{Soundness of discharge and demotion}

The sound discharge or demotion of a chaperone-installment site cannot change the meaning of the program.
In terms of \chapcalc, a discharge should not be judged sound if an execution that once resulted in an error (because of a misbehaving chaperone, say) results in a value or vice versa.
Additionally, a divergent program should not converge after demotion.


\begin{definition}[Chaperone-Installment Site Discharge Soundness]
We say a discharge transformation $D_\ell$ is sound for a program $p$ when it holds that
\begin{itemize}
\item if $p\rrs v$, then $D_\ell(p)\rrs v$,
\item if $p\Uparrow b$, then $D_\ell(p)\Uparrow b$, and
\item if $p\Uparrow$, then $D_\ell(p)\Uparrow$.
\end{itemize}
\end{definition}


a chaperone may not exist in every program execution
for a particular program execution, a chaperone can be discharged if it never throws an error and all of the chaperones it creates can be discharged.
for a particular program execution, a chaperone installment site can be discharged if it does not error on evaluation, does not diverge on evaluation, and all the chaperones installed there can be discharged.

%\begin{definition}
%A chaperoned operator is \emph{negative active} if evaluation is within the dynamic extent of its negative guard.
%\end{definition}

%\begin{definition}
%A chaperoned operator is \emph{positive active} if evaluation is within the dynamic extent of its positive guard.
%\end{definition}

\begin{definition}
A chaperoned operator is simply \emph{active} if evaluation is within the dynamic extent of one of its guards.
\end{definition}

\begin{definition}
A chaperone-installment site labelled $\ell_1$ is \emph{negative dependent} on a chaperone-installment site labelled $\ell_0$ if there is a program execution in which the $\ell_1$-site is visited while the youngest active chaperone is negative active and was installed at $\ell_0$.
\end{definition}

\begin{definition}
A chaperone-installment site labelled $\ell_1$ is \emph{positive dependent} on a chaperone-installment site labelled $\ell_0$ if there is a program execution in which the $\ell_1$-site is visited while the youngest active chaperone is positive active and was installed at $\ell_0$.
\end{definition}

A chaperone positive guard can be removed if causes no blame5,6 errors, no blame7 errors, and any positive-dependent chaperones can be discharged.

A chaperone negative guard can be removed if it cause

\begin{theorem}[Chaperone-Installment Site Discharge Theorem]
A chaperone-installment site can be discharged if, for all possible program executions, it does not cause an error, does not diverge, and all dependent chaperone sites can be discharged.
\end{theorem}

Call a chaperone $c$ well0 if its application does

Call a chaperone site $s$ with label $\ell$ well0 if, for any possible program execution, a resultant error is never blame0-ed on $\ell$.

Call a chap



\begin{definition}[Weak Chaperone-Installment Site Discharge Soundness]
We say a discharge transformation $D_\ell$ is sound when the conditions hold that
\begin{itemize}
\item if $p\rrs v$, then $D_\ell(p)\rrs v$, and
\item if $p\Uparrow b$, then $D_\ell(p)\Uparrow b$.
\end{itemize}
\end{definition}

The weak variant of the soundness theorem does not say anything about divergence. According to this definition, a transformation $D_\ell$ may be sound with respect to a program $p$ if $D_\ell(p)\rrs v$ or $D_\ell(p)\Uparrow b$ even when $p\Uparrow$.

Because the non-weak variant of soundness speaks on every type of program result, the conditions can be read as equivalences.

This makes 

Chaperone values are branded with the label of their creation site. In any given program, there are a finite number of these creation sites and labels. In fact, it is these creation sites that we are concerned with. The output of an analysis is a map from labels to transformations (no-op, promotion, discharge). Once we apply these transformations, we recover optimization opportunities as data dependency decreases.

We call a wrapper function $g$ an \emph{originator} of a chaperone $c_0$ if $c_0$ is created in within the extent of $g$. Chaperone values are also branded with their parent chaperon

Definition: call a creation site good0 if all of the chaperone values which flow from it are well-behaved.

%If the wrapper returns an additional result, its first result is a function (that may depend on input) that has argument and result arities of the result arities of the wrapped function.

\begin{theorem}[Selective Chaperone Discharge Theorem]
A good and nice chaperone installment site can soundly be replaced by its first argument (where ``soundly'' means ``with no change to the meaning of the program'').
\end{theorem}

%\begin{proof}
%The only way that a chaperone can change the meaning of a program is by causing an error, raising an error, or causing the creation of a chaperone with the same property.

%By definition, all chaperones which flow from a good and nice chaperone installment site are good and nice meaning that they do not cause an error, raise an error, or cause the creation of a chaperone with the same property.
%\end{proof}

% do (chaperone f negative positive) first
% and then deal with (chaperone f w)

%Because the result wrapper is produced at each invocation, it may depend on 

Strickland presents a chaperone erasure theorem which states that if a program with chaperones evaluates to a value, the same program with chaperones erased--that is, with all chaperone installment sites replaced with the first argument--will evaluate to the same value. The purpose of this theorem seems to be to make a statement about the nature of chaperones--that, in a well-behaved program, they do not change meaning. Our theorems give the conditions of when a given chaperone installment site does not change the meaning of the program.

IPDCFA provides us with the chaperones which may be meaningful, but it does not provide us with which chaperone guards may diverge, either by evaluation of the guard itself or application of it.
To a first approximation, we can conservatively say that any non-atomic expression for the guard potentially diverges and cannot be safely removed from the program.
This strategy covers most of the cases in practice, since it is relatively rare to have a complicated expression in guard position---the more complicated the expression, the bigger the onus of justifying that the 

%This language is sufficient to express two theorems.

%Definition: Call an impersonator \emph{well-behaved} with respect to a program if its application never \scheme{raise}s.
%(only talking about arity and special runtime stuff here)

%Well-behavedness is defined with respect to a program--as opposed to assigning the property in isolation--because an impersonator may misbehave in situations never encountered within a particular program.

%In general, we cannot decide whether a particular impersonator--in context or isolation--has this property.

%Definition: Call a chaperone wrapping function \emph{well-behaved} with respect to a program if it only possibly installs chaperones on its arguments.

%Definition: Call a chaperone \emph{well-behaved} with respect to a program if its application never \scheme{raise}s.

%Definition: Call a chaperone \emph{satisfied} with respect to a program if it never \emph{raise}s and 

%Def: call a chaperone good0 wrt a program if it at most chaperones its arguments.
%Def: call a chaperone-installment site good0 wrt a program if all chaperones which flow from it are good0.
%Def: call a chaperone good1 wrt a program if it is good0 and its installing chaperone, if any, is good1.
%Def: call a chaperone-installment site good1 wrt a program if it is good0 and the chaperone-installment sites of its installing chaperones, if any, are good1.
%Thm: a good1 chaperone-installment site can be promoted to an impersonator-installment site if its installing chaperone site, if any, is promoted.


%if all chaperones which flow from a chaperone-installment site are good1, the installer can be promoted to an impersonator installer--all the chaperones which flow from it can be promoted to impersonators.

% I think the conditions above and below are (as written and in actuality) disjoint

%Def: call a chaperone good2 wrt a program if its application never raises a runtime (arity) error, its wrapper never raises.
%Def: call a chaperone good3 wrt a program if it is good2 and the chaperones it installed, if any, are good3.
%Thm: if all chaperones which flow from a chaperone-installment site are good3, that site can be replaced with its first argument (the until-now-wrapped value).

%This amounts to the possible arisal of two different types of errors: the first type is the violation of a contract assertion--in this case, blame is determined to fall on either the caller or the callee (the wrapped function itself); the second type is a misbehaving chaperone: it does not return the correct number of values or it does not only chaperone the arguments.

%define well-behaved impersonator and well-behaved chaperone
%define good chaperone
%chaperone erasure theorem
% basically, if a program reduces to a value with chaperones, then it should reduce to the same value with chaperones erased. this theorem was stated for a language without error recovery, so we may have to alter either our language or the theorem.
% also, this theorem says nothing about the program in general. we want to say that the erasure or promotion of specific chaperones will not change the meaning of the program. it may be that error recovery external to a chaperone extinguishes its violation transparently, but that is not the purpose of our analysis.

% the concrete interpreter correctly assigns blame but there is a problem:
% if the chaperone-operator is wrapped in a function, then it can only be changed if /all/ the uses of that function meet the requirements. it doesn't matter if the store is going to be garbage-collected--all the values are branded with its syntactic label.
% one thing we could do is attempt to distinguish calls into classes and divert all calls of a certain class to a different function. for instance, if a chaperone value as it goes around the program is well-behaved, can we look where it is created and change it in isolation somehow?

In the Racket implementation, the \scheme{chaperone-procedure} primitive is access most often through a wrapper function that handles keyword procedures.
Our static analysis determines the transformation of a \scheme{chaperone-procedure} application site to be sound only if no contract installed there will ever be blamed.
This means that the violation of a single contract installed there prevents the promotion or discharge of \emph{any} of the other contracts installed there.
In order for the analysis to be effective, we need more granularity.
We preprocess programs to inline certain definitions according to human judgement.

\subsection{Demotion soundness theorem}


% we aren't giving necessary conditions to discharge chaperones
% we are giving sufficient conditions
% there are chaperones that are dischargable but that don't meet our conditions.



We expect that a vast majority of impersonators and chaperones will be well-behaved in this sense, and only affect program behavior through one of the guards.
In particular, we expect that chaperone guards will at most chaperone their arguments.







If a chaperone 



Such chaperones of course need never be installed at run time.
We say we \emph{discharge} chaperones when we alter the program to remove their installment.
Chaperones which may influence program behavior cannot be discharged but may satisfy a weaker condition which allows them to be \emph{demoted} to impersonators, reducing the amount of run-time monitoring that must be dedicated to them.



% inline call sites to partition the chaperones created at each site
% show that all chaperones at a given creation site are safe
% these two work with each other
% look instead 

Depending on the class of errors which we can rule out statically, we can \emph{discharge} a chaperone which is to prevent it from ever being created.
However, we distinguish between the possible errors shared by chaperone and impersonator application and the error unique to chaperone application raised when a wrapper function does more than chaperone its arguments.
If a chaperone does not induce any of the latter type, and sundry other conditions are met, we should be able to \emph{demote} it to an impersonator.
This avoids the potentially expensive check that the wrapper results are chaperones of the arguments.
If a wrapper function never throws an error and none of the chaperones it creates ever throw errors, we can remove it.
We present a two soundness theorems:
The first soundness theorem provides the conditions whereupon a chaperone can be discharged.



%In contracts, one can talk about creation time--the time the contract value is created--projection time--the time the contract is attached to a value--and application time--the time that the contracted value is applied to its argument.
%These times are not contiguous and may overlap in the presence of dependent contracts.
%The evaluation time of the wrapper corresponds to creation time.
%The chaperone-operator form corresponds to the projection time.
%The application of the negative wrapper of the chaperoned value corresponds to application time.
%Within the application, the evaluation of the positive wrapper corresponds to creation time.
%At return, the application of the positive wrapper corresponds to application time.

We now explore the conditions under which a chaperone can be removed from the program.

Consider the installation of a chaperone on a first-order procedure by
\begin{schemedisplay}
(chaperone-operator
 (lambda (n) (+ n 1))
 (lambda (n)
    (if (integer? n)
        (values (lambda (n)
                  (if (integer? n)
                      n
                      (raise)))
                n)
        (raise))))
\end{schemedisplay}
Even without program context, we can make judgements strong enough to weaken this installation site.

First, observe that the positive guard (the first argument of the \scheme{values} call) neither guard installs a chaperone, either directly or indirectly.
Based on this and the fact that it is independent of the negative guard argument, arity-compatible with the result arity of the function, and type-compatible with the result of the function (which is to say that no resultant value of the function is sufficient to make the guard throw an error, and, finally, that it is an atomic expression and so must not diverge, we can remove it, transforming the installation expression to
\begin{schemedisplay}
(chaperone-operator
 (lambda (n) (+ n 1))
 (lambda (n)
    (if (integer? n)
        n
        (raise))))
\end{schemedisplay}
with no change in meaning to the program.

We now have two opportunities for optimization which have disparate conditions.
First, we can see that the remaining guard will never install a chaperone on one of its arguments as they are first-order values.
If, with respect to the program, the guard never raises an error, then it acts as the identity function\footnote{Specifically, it acts like \scheme{values}, the identity function for any number of values}.
With these two conditions met, we can replace the entire form with \scheme{(lambda (n) (+ n 1))}.

If our analysis cannot rule out the possibility of guard error arisal, we cannot soundly remove it.
We may be able to weaken the run-time monitoring necessary, however.
If we can establish that this chaperone installment site has no dependent chaperones, we can replace it with an \scheme{impersonate-operator} site.
In fact, this weakening is independent of the omission of the positive guard from the form.
In general, if all the chaperones which flow from an installment site at most chaperone their arguments, and the site itself has no dependent chaperones, it can be replaced with an equivalent \scheme{impersonate-procedure} site, regardless of the error or divergence behavior of the value at creation, projection, or application time.




We might surmise that this fact alone would allow us to transform this \scheme{chaperone-operator} form to an \scheme{impersonate-operator} form which would avoid the chaperone-specific monitoring at runtime.
Suppose, however, that this installment site appeared within the body of a procedure used as a chaperone guard.

Next, observe that the argument and results arity of the guards are completely compatible with the arity of the function.
In fact, the only possible way this chaperone would change the behavior of the program is by signalling an error when the argument or result is not 

If a chaperone never throws an error and all of the chaperone creation sites that depend on it can be discharged, it can be discharged.

If all of the chaperones created at a chaperone creation site can be discharged, the creation site can be discharged.

%possible side-effects
%error on creation (not same arity, not procedure arg0, not procedure arg1)
%divergence on arg1
%error thrown by args wrapper
%divergence on args wrapper (extra argument)
%divergence on args wrapper (otherwise)
%args wrapper returns wrong number of results
%extra result not an operator
%args wrapper results not chaperones of arguments
%ults wrapper doesn't accept number of results
%ults wrapper throws an error
%divergence on ults wrapper
%ults wrapper returns wrong number of results
%ults wrapper does not chaperone its arguments

\subsubsection{Impersonator errors}
\begin{enumerate}
\item error on creation (not same arity, not procedure arg0, not procedure arg1)
\item divergence on arg1
\item error thrown by args wrapper
\item divergence on args wrapper (extra argument)
\item divergence on args wrapper (otherwise)
\item args wrapper returns wrong number of results
\item extra result not an operator
\item ults wrapper doesn't accept number of results
\item ults wrapper throws an error
\item divergence on ults wrapper
\item ults wrapper returns wrong number of results
\end{enumerate}

\subsubsection{Chaperone-specific errors}
\begin{enumerate}
\item args wrapper results not chaperones of arguments
\item ults wrapper does not chaperone its arguments
\end{enumerate}

We can be more precise about the possible sources of side effects to reveal places to replace wrapper functions individually.

A positive guard can be discharged if the evaluation to its value converges, it always accepts the number of results of the function, it always returns the same number of results, its results are always chaperones of its arguments, it never raises an error (explicitly), it doesn't diverge, and all the chaperone creation sites that depend on it can be discharged.

A negative guard can be discharged (changed to values) if the evaluation to its value converges, it has the same arity of the function, it returns the correct number of arguments, its extra argument is a function, its results are always chaperones of its arguments, it doesn't divergence, all chaperone creation sites that depend on it can be discharged, and the positive guard it returns can be discharged.

% these conditions are stronger than necessary in the sense that the definition of dependence is not precise but a conservative approximation, and not every value that meets the precise condition would meet these stronger conditions, but it is easier to determine that these stronger conditions hold.

A chaperone can be discharged if its (negative) guard can be discharged.

A chaperone creation site can be discharged if all the chaperones it creates can be discharged.

We assume that any chaperone installed while a chaperone is active 

A chaperone can be demoted if the results of its positive and negative guard are only ever chaperones of the arguments (excepting the extra result for the negative guard), and all chaperone 

Our analysis calculates a conservative approximation of the dependence relation.

In addition, our analysis calculates a conservative approximation of the set of dependent chaperones.

We build a control flow graph.
At each control state, we can calulate a description of the possible stacks.
First, we consider control states where a chaperone is being created.
The set of possible stacks at each control state reveals the set of creation sites of chaperones upon which that creation site depends.
Next, we consider terminal error control states.
The set of possible stacks at each control state reveals the set of creation sites of chaperones that are responsible for the error.

\section{Limitations}

Our analysis applies equally well if we extend the language with more referentially transparent primitives or macro-expressible constructs such as \scheme{and} and \scheme{or} forms.
We can even add an error-catching facility but we must be careful in our analysis.

In Racket, \scheme{chaperone-procedure} is a primitive procedure--not a special form.
\scheme{app-values}

Chaperones are intended to be treated like the original value.
% box?, procedure?, etc. will respond the same way
% they evaluate equal? to the values they wrap, but not eq?
Procedure chaperones are considered to have the same arity of the procedures they wrap.
The \scheme{chaperone?} predicate is designated as the single way to detect chaperones at runtime, though its use is discouraged.


\section{Static Analysis}

% relation R
% a set S
% let S0 = S
% let Sn+1 = { x | xRy for some y in Sn } union S0
% let S' be the fixed point (the transitive closure)
% this is the same as the transitive closure of R projected on the right to S
% conjecture: 

% we have a control flow pushdown graph
% there are eval, apply, value, error, etc. states
% error states may be simple error states or "static" blame states
% regardless, consider all of the dependent chaperone frames
% if a creating chaperone site is discharged, the error may not occur
% if an active chaperone was never created, the error may not occur
% then we do a conservative divergence analysis of all lambdas which flow to guards
% if any of the lambdas which flow to the guards may diverge, we can't discharge that

% look for all static errors that signify arguments not being chaperoned
% those chaperones cannot be demoted to impersonators
% we might need a special "chaperone-just-created" state
% ok, that's simple enough

Call a chaperone first-order if it is chaperoning a first-order operator or if its guard constrains the argument to be first-order.
For instance, \scheme{(chaperone-operator add1 (LAMBDA (x) x))} creates a first-order chaperone because \scheme{add1}, defined as \scheme{(LAMBDA (x) (+ x 1))}, is first order.
On the other hand, the operator \scheme{(LAMBDA (x) x)} accepts higher-order arguments, but \scheme{(chaperone-operator (LAMBDA (x) x) integer/c)} creates a first-order operator.

In \chapcalc, a first-order chaperone cannot install chaperones on its arguments (as chaperones don't exist for simple values).

The pushdown control-flow analysis produces a finite graph of control states with edges labelled with symbols from the stack alphabet.

For each variant of continuation frame $\Gamma$, the stack alphabet contains the symbols $+\Gamma$ representing a \emph{push} of a $\Gamma$-frame and $-\Gamma$ representing a \emph{pop} of a $\Gamma$-frame.
The stack alphabet also contains the symbol $\epsilon$ which labels transitions between control states with no net stack change between them.

From the control graph, we can build a conservative approximation of the installed-by relation by considering states which are the target of a transition labelled $-\chak(f)\Gamma_{chap}(\ell,f)$.
At each of these states, we calculate a conservative set of labels of the youngest active chaperones at that control point.



We seed a set with the labels of qualifying errors (ones that directly disqualify a site from being removed)
and apply the relation to the set to build a transitive closure of it.
These sites cannot be removed.

We look for the special class of errors that occur when a guard does not chaperone its arguments.
We find all of the chaperone sites it installs and the transitive closure of it.
These sites cannot be demoted.

A particular program expression may appear where the 

Our concrete semantics brands each chaperone value at creation time with the label of its creation site and the label of the creation site of the chaperone in which dynamic extent of the application takes place using stack inspection. This makes access to the stack critical in our analysis.

Introspective pushdown control-flow analysis admits a description of possible stacks at a given program point with regular expressions. We include as parents all possible labels of guards. Thus, the abstraction of the parent label becomes a set of labels.

% but wait! how are the possible stacks affected by garbage collection?
% if a function cannot be invoked at a site, then its stack will not be the base
% for inner calls within that function.

% what I'm saying is:
% I have a chaperone that calls -> (a chaperone installer) in its negative guard.
% sometime later in the program, I have another chaperone that also calls -> in its negative guard.
% PDCFA determines that both stacks are possible?

Introspective pushdown control-flow analysis (IPDCFA) can provide a conservative approximation of possible stacks at each program point described with regular expressions. Then, we look at states with expressions \scheme{(chaperone-procedure f neg-wrap pos-wrap)} and the possible stacks at those particular states. If any of the stacks contain a chaperone activation frame, we conservatively assume that all chaperones created at this program point are children of that chaperone. Because we have a conservative approximation of possible stacks, it may be that multiple activation frames may be relevant (either through alternation or nested where it is absent in one branch). We assign all of the chaperone values as parents to chaperones created at this site, and, when we make our judgments, must ensure that the properties hold for all to discharge them.

We perform a pushdown control-

The set of possible sequences of stack frames at a particular program point is a regular language.
An introspective pushdown control-flow analysis provides us with a regular expression encoding this language.
A string in the language is a sequence of frames ordered from oldest to youngest.

We are interested in chaperone activation frames, a subset of all possible frames, and so a subset of the stack alphabet.
In particular, we are interested in the subset of youngest such frames.
Consider the set of strings--stack sequences--that comprise the language.
Filter the characters in each string so that only characters from the set of interest appear.
Disregard the empty string (and any strings that were fully-consumed by the filtering process).
Consider the set of all final characters in the remaining strings.
Each character in the set represents a chaperone activation frame, and is branded with the label of the active chaperone's creation site.
Thus, this set represents the possible creation sites of active chaperones.

We can perform the same operation on a regular expression by introducing a distinguished character $\bullet$ which represents a sequence of characters that have been filtered away.

Given a regular expression (either a character, a concatenation, a union, or a Kleene star), define $f:RE \longrightarrow RE$ as follows
$f(\bullet)=\bullet$

$f(c)=c$

$f(\bullet\cdot L_1)=L_1$

$f(L_0\cdot\bullet)=L_0$

$f(L_0\cdot L_1)=e\cdot L_1$

$f(\bullet^*)=\bullet$

$f(L_0^*)=L_0^*$

$f(\bullet\cup L_1)=L_1$

$f(L_0\cup\bullet)=L_0$

$f(L_0\cup L_1)=L_0\cup L_1$

Because $f$ ``absorbs'' holes, a hole will only occur if the entire language is replaced by the language that contains only the empty string.
We define $h$ to obtain the set of stack frames by the following:
$h(\bullet)=\emptyset$

$h(c)=\{c\}$

$h(L_0\cdot L_1)=h(L_0)\cup h(L_1)$ if $L_1$ is nullable; $h(L_1)$ otherwise.

$h(L_0\cup L_1)=h(L_0)\cup h(L_1)$

$h(L^*)=h(L)$

$g$ (the replacement function) is homomorphic in the regular combinators. 

%\section{Chaperone Erasure Theorem}

%If a well-behaved program (meaning a program in which chaperoning procedures do not cause side effects and chaperone application does not cause side effects) evaluates to v, then a program without the chaperones will evaluate to the same value.

%Selective chaperone erasure theorem: if none of the values that flow from a call site $c$ throw any exceptions and none of the chaperones installed by its wrappers throw exceptions, the chaperone can be erased (the call site (chaperone-operator f w) can be replaced with f) with no change in the meaning of the program.

%Proof by induction:
%It holds for any reduction rule which does not involve chaperones by the induction hypothesis.

%Consider the call site \scheme{(chaperone-operator f w)}. If none of the values which flow from this call site raise an exception, then we can substitute it with \scheme{f}.

%Call a chaperone \emph{well-behaved} if its application within a program never induces a type B error.

%Call a chaperone-installment site (chaperone-operator f w) good if all the values which f

%Call a chaperone good if it is well-behaved and its installing chaperone, if any, is also good.

%Chaperone promotion theorem: a good chaperone can be promoted to an impersonator. That is, if all the values that flow from a call site (chaperone-operator f w) are good, the replacement of its call site (chaperone-operator f w) to (impersonate-operator f w) as well as the the replacement of its installing chaperone will not change the meaning of the program. (All the values that flow from its call site must be well-behaved

%It is critical that the property hold transitively for the installing chaperones. If not, a chaperone could install an impersonator where it originally installed a chaperone, which would would result in an error that wasn't there before.

%fine-grained chaperone erasure theorem
%fine-grained chaperone promotion theorem
%introduce a flow analysis which can make judgements which satisfy the conditions of the theorem built on introspective pushdown systems.
%compare the performance of programs which have been analyzed
% it is not necessary that the tool automatically rewrite the program according to the theorem--only that it performs the analysis and perhaps makes the judgments for its application

conclusion describing limitations and intended direction












%\section{Introduction}

%Our goal is to soundly discharge chaperones or, if that's not possible, to soundly promote them to impersonators.

%Call a chaperone \emph{well-behaved} if it has the following properties:

%- its wrapper function has the same arity as its wrapped function
%  (however, this property is checked during the creation of the chaperone.
%  if it is violated, the chaperone is never created but we must keep the
%  call to preserve the behavior of the program. so we need a way to flag
%  the call or somesuch.)
%- its wrapper function returns the same number of values as it is given
%  or one additional value
%- if its wrapper function returns the same number of values as it is given,
%  they are chaperones of the corresponding given values
%- if the wrapper function returns an additional value, the first value it 
%  returns is a function that accepts as many arguments as the wrapped function
%  results in. the rest of the values are chaperones of the corresponding given
%  values.
%- the wrapper function returns as many values as it is given

%Some of these are dynamic properties, so determining whether they have a given
%property may be undecidable.

%Call a chaperone \emph{benign} if it is well-behaved, never performs a side-effect,
%and all of the chaperones it installs are benign.

%Call a chaperone \emph{good} if it is well-behaved and, if it was installed by a chaperone,
%that chaperone is also good.

%Benign chaperones can be discharged.

%Good chaperones can be promoted.

%How do we determine whether a chaperone has one of these properties?

%We have an abstract machine for a small language with impersonators and chaperones.
%When a chaperone is created, we stick it into a private table.
%If it was created in a chaperone wrapper, we link it to that chaperone.
%When a chaperone arguments wrapper is applied, we push the chaperone onto a stack with a %flag indicating 'arguments'.
%When it returns, we pop the stack.
%We do the same when a results wrapper is returned.
%If a well-behavedness exception is raised, the active chaperone gets a flag.
%If a side effect is performed and the stack is not empty (?), we flag the chaperone on the top of the stack. It 
%is no longer benign, nor is its creator chaperone and so on up the chain.
%We create the dependency graph after execution and can judge the well-behavedness.



%We augment the machine with a table.


%Take the factorial function and wrap it with a contract that ensures
%exact-nonnegative-integer? -> exact-positive-integer?

%change the base case value 1 to -1 and the function never fulfills its
%contract. instead, change the multiplier to -n (instead of n) and it
%fulfills its contract for even arguments. if a program were to happen 
%to only call factorial with nonnegative even arguments, this chaperone
%would be dischargeable. is (λ (x) (if (integer? x) (* 2 (abs x) 0))) 
%so rare?

%now consider

%(letrec ([(fac) (chaperone-procedure
%                 <recursive factorial referencing fac>
%                 <simple contract>)])
%                 ...)

%this is a recursive chaperone and it is amenable to the same analysis.
%if any of its applications are flagged, it is flagged.

%\begin{schemedisplay}
%(letrec ([(fac) (chaperone-procedure
%                 (λ (n a)
%                   (if (= n 0)
%                       a
%                       (fac (- n 1) (* n a))))
%                 (λ (n a)
%                   (if (or (or (not (integer? n))
%                               (< n 0))
%                           (or (not (integer? a))
%                               (< a 1)))
%                       (raise 42)
%                       (values (λ (a)
%                                 (if (or (not (integer? a))
%                                         (< a 1))
%                                     (raise 43)
%                                     a))
%                               a))))])
%      ...)
%\end{schemedisplay}
      
%is this the proper way to handle accumulator arguments?
%if so, is there a recursive pattern that we can apply
%to eliminate the duplicated code?



%- racket program lifecycle
%- bytecode optimizations performed (briefly)
%- PDCFA
%- contracts
%- impersonators and chaperones
%- intuition behind impersonator/chaperone discharge
%- theorem that the program behavior will be the same (adapt from Strickland)
%- theorem of equivalence of impersonator and certain types of chaperones
%- impersonator and chaperone calculus
%- analysis of real racket programs using calculus




%- in direct style, temporary variables defined in the process of evaluating
%arguments are discarded. in the extreme nesting of ANF, these variables 
%never go out of scope. can we determine statically when they are no longer 
%necessary? if not, should we mark the point at which we know they're not (by 
%virtue of their preimage)? (it looks like CPS has something on us here.)

%- should we stack-allocate variables? this does allow us to reason precisely 
%about certain quantities (although there are an infinite number of values 
%when we include integers, so do we only include finite domains?). it seems 
%like the reference information from the bytecode compiler could be useful 
%here.

%- it seems like we can use a black box value and accrue constraints on it
%(much like Sam TB did in his recent scripting language symbolic contract 
%paper) to handle input. we probably need only define its behavior with 
%respect to primitives and being in application position.

%Analysis of impersonators and chaperones
%A chaperone can only raise a side effect or chaperone a value.
%If a chaperone attempts to alter an argument or result in any other way,
%the runtime system raises an exception. The chaperone wrapper is in error.
%This leads to two notions of well-behavedness: the first is that the 
%chaperone wrapper itself is well-behaved. In this case we could drop the 
%chaperone wrapper down to an impersonator BUT for the possibility that 
%a chaperone wraps arguments or results in chaperones themselves; there 
%is no primitive that acts like an impersonator but wraps like a chaperone.
%This requires us to define well-behaved in an inductive way: a chaperone 
%is well-behaved if the chaperones it installs are well-behaved.
%The second notion of well-behavedness is that the wrapped object is 
%well-behaved with respect to the chaperone. This is a more conventional 
%outlook and is directly related to contract discharge. If the object 
%is well-behaved with respect to its chaperone and the values on which its 
%chaperone installs chaperones are well-behaved with respect to their 
%newly-acquired chaperones, the chaperone can be dropped entirely. 

%ANF for multi-argument functions and abstract interpretation
%we don't want to introduce bindings of arguments into the 
%environment of later arguments. fresh variables won't do it.
%what if we had two environments: an application environment
%that is only active at the time of evaluation of application
%arguments and that is merged at call time.

%The greatest use of the discovery and development of improved static analysis methods for higher-order languages is to apply them to real programs written in real languages.
%Of course, one must then contend with the realities of ``real'' languages which boils down to the cruft inherent in imperfect environments and design processes and advancement and iteration.

%Dimitros V. added the following feature.

%In A-normal Form, the computation is ``linearized''. Argument evaluation, rather than increasing the size 
%of the continuation, pre-emptively evaluates subexpressions. Because of the nested nature of ANF, these temporary 
%references never go out of scope. With access to the static continuation (the entire remaining term), we can determine 
%at compile time whether it is ever again referenced in this scope. We then need to check only dynamic values for 
%references to the variable.

%We turn the information available at this stage to our advantage:
%- use clear? flags to facilitate garbage collection

%The greatest beneficiary of analyses designed for unityped languages built upon the λ-calculus is undoubtedly Racket.
%These analyses do best when given access to the entire program.
%As a collection of compiled modules, Racket programs do not provide that access.
%To reconcile this, Racket programs are \emph{demodularized}.
%This process combines a collection of bytecode modules into one monolithic program--exactly the target of our analysis.

%Racket is a member of the Lisp family of languages. It shares some advanced features with Scheme such as a hygienic macro system first-class continuations.
%However, it adds to this units, contracts, classes, generics, modules, as well as a more powerful macro system (which supports a typed dialect of Racket) and composable control.
%Racket uses a sophisticated VM to provide many of these features.
%Consequently, Racket programs are first compiled (on a by-module basis) to a bytecode.

%Numerous advances in static analyis of higher-order languages have been made recently.
%Up to now, 

% dependencies explicitly.

%Racket bytecode is similar to 

%\section{Racket Program Lifecycle}

%Racket is a tower of languages built using a powerful macro system. One of the core organizational principles is the 
%module.



%\section{The Racket Virtual Machine}

%racket is a language in the lisp family of languages.
%racket programs are organized into modules.
%each module is expanded into core forms according to its module language and imports and then compiled.
%The expansion result is a program in the ``kernel'' language which contains basic forms such as \emph{lambda}, \emph{begin}, and \emph{if}.

%a program is demodularized by combining the compiled modules and rewriting module variable accesses to global variable accesses and other things.
%the demodularization process is seeded with a target module which may be considered the main module.


%\section{Abstracting Abstract Machines}

%CFA and its fruits have enjoyed much attention from theory, and it is time it was put into practice.
%After Olin Shivers discovered the family of analyses he termed kCFA, he worked out dozens of optimizations that could be built on top of it. It is time that those were applied to a lambda-calculus-based language with the type-system for it.

%bladaldaab
%this sucks

%but it is the paper we want to write

%Many of the analyses have been presented in terms of a CESK machine. The Racket virtual machine does not follow this format, but instead follows a VSHTC machine that executes bytecode instructions.

%We want to use the decompiled code instead which is in a few core forms, has some helpful annotations, and is at the level of the lambda calculus. The small size of the language suggests that it would easy to write a CESK machine, but we must bear in mind that ensuring correctness is part of the cost of that construction.

%Also, perhaps we want to hook into the compiler earlier. Otherwise, our strategy is to:

%- compile the code
%- decompile the code
%- analyze the code, performing any optimizations we can muster
%- recompile the code

%But maybe there are two points in the compilation process when we want to perform static analysis.

%The first is during the initial compilation phase. It may be that the current optimization phase consists only of relatively low-hanging fruit. If so, it might make sense to parameterize the optimization level to control the amount of analysis that can occur. The lowest level of optimization proper could include those already in the system, which we would integrate into our system.

%The next point is after compilation and decompilation. The reason for this is that the demodularizer can only work with bytecode and whole-program analysis is probably much more fruitful than a modular analysis. Simultaneously, it probably is infeasible most of the time since it requires the whole program. (Actually, is that right? The only times the code couldn't be available is with dynamic loading, right?)

%These two types of analysis are probably pretty different. The first type deals with the module system and could take advantage of contracts (which are introduced at module boundaries). The second type deals only with whole programs that may have been optimized somewhat.

%[This raises a somewhat related question: how does the demodularizer deal with contracts?]

%a calculus for impersonators and chaperones

%impersonate-procedure (i-p)
%takes a procedure and a wrapping procedure as argument

%let f ~ a -> b denote that function f has input arity a and output arity b.

%then (i-p p w) is a valid call if
%p ~ m -> n
%w ~ m -> (m + 1)
%and the first result from w is a function g ~ n -> n
%it is returned by the input guard/impersonation/etc. so that it can capture input variables.

%many uses will use 'values'. in fact, that may be one of the questions we have.

%chaperones are impersonators restricted to performing side-effects (specifically, throwing an exception). this is enforced by run-time verification that the input arguments are unchanged as they pass the threshold and the results are unchanged as they return through.

%chaperones require run-time resources to ensure they are well-behaved, and are thus more expensive to use than impersonators.

%a well-behaved chaperone--one that always fulfills the responsibilities above an impersonator--needs no oversight. if we can prove that a given chaperone does so, we can remove the oversight completely by installing an impersonator in its place.

%if, in addition to being well-behaved, a chaperone does not perform any side-effects in any circumstances, we can dismiss it entirely and let the functions roam unattended.

%for a well-behaved chaperone, we may be able to prove only that it does not perform side-effects on return, in which case we can replace the wrapped function at interposition-time with 'values'. (it may be that side-effects are absent precisely because the original exit check /was/ 'values'. our replacement in this case is unnecessary but benign.)

%in sum, our opportunities for optimization are as follows from greatest to least:

%- if the chaperone is well-behaved and never performs side-effects on either entry or exit, we can dismiss it entirely.

%- if the chaperone is well-behaved and never assigns negative blame, we can replace the wrapper procedure with \scheme{values}.

%- if the chaperone is well-behaved and never performs side-effects on exit, we can replace the exit function with 'values' at interposition-time.

%- if the chaperone is well-behaved and but may perform side-effects on both entry and exit, we can install an impersonator in its place.

%the first opportunity requires an analysis capable of justifying a strong statement. such statements are probably difficult to come by at this stage since they are more easily made earlier in the program when guarantees are specified explicitly.

%the next opportunity is similar.

%the final opportunity is most achievable not only because within which its behavior is restricted the least, but because a chaperone that exceeds its provisions is in error. it should be relatively easy to prove a chaperone well-behaved if the program is well-behaved in regard to it.

%the construction of chaperones excludes the ability to discharge chaperoning on entry but not on exit. one reason for this is that, even if the function has no side effects, we must apply it anyway to acquire the exit wrapper. especially by virtue of its construction, we can't replace the input function with something like

%(lambda xs
%  (apply values f xs))

%where f is the first value of the original input barrier because f may capture arguments and we would have to prove that it didn't.

%for the purposes of analysis, we suggest an additional chaperone form
%(chaperone-procedure p iw ow)
%where p ~ n -> m is the procedure to be wrapped, iw (for input wrapper) is (at-least n) -> n, and ow (for output wrapper) is m -> (at-least m)

%one of the side-effects a chaperone can effect (ha!) is to chaperone the arguments or results of a function call.

%for instance, if our exit membrane was

%(λ (p)
%  (if (procedure? p)
%      (chaperone-procedure p (λ args (error "explosion")))
%      p))

%then we would make time bomb procedures.

%\section{Chaperones}

%The 'chaperone-procedure' primitive accepts as arguments

%1. a procedure 'p' to be chaperoned,
%2. a procedure 'w' to chaperone, and
%3. a sequence of alternating chaperone property keys and values.

%The chaperone procedure 'w' must accept an arity superset of 'p'. The acceptable numbers
%of position arguments that 'w' accepts must be a superset of 'p'. The set of required 
%keyword arguments must be a subset of those of 'p' and the set of optional keyword arguments 
%must be a superset of those of 'p'.

%The 'chaperone-procedure' operation "wraps" ...

%The 'impersonator-of?' predicate indicates whether the first argument is an impersonator of 
%the second. This is determined by whether every impersonator intact (word from Racket manual) 
%in the second argument is intact in the first, or if they are otherwise 'equal?'.


%Our first approach is to define 'impersonate-procedure' as a higher-order function. The simplest 
%definition omits arity checks. [and we're ignoring keywords]
%(λ (p w)
%  (λ xs
%    (let-values ([ys (apply w xs)])
%      (if (andmap equal? xs ys)
%          (apply p ys)
%          (error "bad chaperone")))))
%There are a few problems with this. First, of course, is that we do not check for proper arity. The 
%next and more critical is that we cannot support 'impersonator-of?' because we cannot strip away the impersonator 
%or distinguish it from its wrapped value.

%Therefore, a higher-order approach will not work. We must build knowledge about impersonators and chaperones
%into our analysis.

%\section{Alphatising}

%Variable names are absent in Racket bytecode.
%Rather than by name, variables are accessed directly via stack offsets.
%This is a great boon to efficiency but makes a monovariant analysis particularly troubling since, from application stack behavior, a single variable can effectively have multiple names within its scope (though never at the same time) so disparate variables are folded together. (Talk more about how variables from different parts of the program are folded together because of stack offsets alone.)
%Because the environment has stack structure, this results in lower precision at the base of the stack, where more of the values are bound.
%To ameliorate this, we preprocess the bytecode to recover variable names.

%The bytecode compiler augments each local variable reference with VM directives, such as slot-clearing instructions to destroy references.
%We (plan to) carry these over to the ANF to suit the same purpose.

\section{Chaperone Discharge}

%We say a chaperoning function is \emph{well-behaved} if it only results in chaperones of its arguments.
%We say a chaperoning function \emph{f} is \emph{benign} for a particular set of values \emph{V} if it 
%exhibits no side effects when its arguments are contained in \emph{V}. [Think about side channels as 
%side effects a la the original impersonators paper. Also, we might want to consider V and chaperones of
%the elements of V.]

%Because chaperone invariants are enforced dynamically, chaperones incur a runtime cost above impersonators. 
%If, for a particular program, a chaperone is well-behaved, it can be replaced with an impersonator (which 
%does not enforce argument equality) (but must be customized to return chaperoned arguments, etc. As we prove facts about inner values and their ultimate flow, we can make more powerful judgements about the chaperones that wrapped them to begin with.).

%Because the contract system is implemented with chaperones, many chaperones perform no side-effects other than 
%a blame 

\section{Static Analysis}

Introspective pushdown control-flow analysis (IPDCFA) was developed to allow abstract garbage collection to apply to the standard pushdown control-flow analysis.
By transforming a pushdown system to a Dyck state graph, we obtain a finite graph of control states and a finite desciption of the possible stacks at that program point.
This provided a root set from which abstract garbage collection could work.

It also opened the door for static analysis of programming languages that require--or can be put in terms of--stack inspection.
Our analysis of chaperones requires that we determine the source label of all created chaperones and the source label of the chaperone which created it.
Essentially, we need to know the 

\section{Limitations}

\scheme{app-values} increases the expressiveness of the language.
(We do not have to specify the number of arguments to a function statically.)
The structure of a list is recursive.
We can untie the recursive definition by directing through the store; we took this approach with environments.
We could look into this, but that means the length of the list could vary.
That could \emph{really} destroy precision, but we need to investigate it further.

\emph{rest values} increase the expressiveness of the language. They are very related to \scheme{app-values}.
\scheme{chaperone-operator} as a primitive (as opposed to a form) increases the expressiveness of the language.

\section{Conclusion}

Interposition primitives exist for more than functions in Racket: boxes, vectors, hash tables, continuation mark keys, etc.

We omitted from \chapcalc a few primitives that exist in Racket that must be accounted for by our analysis.
A call \scheme{(chaperone-of? f g)} determines whether \scheme{f} is \scheme{equal?} to \scheme{g} modulo chaperones.
In other words, it determines whether \scheme{f} could be constructed from the parts of \scheme{g} and some chaperone installation.
This primitive presents no problem for chaperone discharge as \scheme{(chaperone-of? f f)} always evaluates to \scheme{#t}.
However, if a chaperone has been promoted to an impersonator and flows to the first argument position, the meaning of the program is changed, making the promotion unsound.
If chaperone values that both otherwise can and cannot be promoted flow to this position, we cannot promote the chaperones.
If only promoted or discharged chaperones flow to it, we can replace it with the corresponding \scheme{impersonator-of?} call.

We also must contend with the \scheme{chaperone?} and \scheme{impersonator?} predicates. We can apply similar reasoning to integrate them into our original analysis.
Given that Racket programmers are discouraged from using them, we don't expect them to regularly upend our analysis, but of course we must account for them.

%the run-time system is oblivious to contracts.
%contracts are implemented in terms of impersonators and chaperones.

%we would like to perform analysis of a higher-level language because the compiler almost certainly discards useful information. (at that level, we would have to more directly contend with the module system.) however, we are constrained by the demodularizer. since it works--and can only work--at the bytecode level, we are capped at the level of that language. fortunately, the bytecode language is fairly rich: it has lambdas, conditionals, sequences, and mutation as primitives. in fact, it closely corresponds to core Scheme (with additions that define core Racket: continuation marks, modules, etc.)

%[Impersonators and Chaperones] provides a chaperone erasure theorem which says that the result of a well-behaved program is independent of chaperones--it's only in the violation of (perhaps implicit) specification that chaperones change the result. locally speaking, chaperones cannot alter the arguments or result of a function application. they are, however, unconstrained in their side-effecting abilities. with the bytecode for the actual procedures available, we can analyze them for side effects.


\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{paper}


% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright

%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...

%\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

