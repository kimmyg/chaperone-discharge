\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{slatex}

\mathchardef\mhyphen="2D
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{PLDI '14}{Month d--d, 2014, Edinburgh, Scotland} 
\copyrightyear{2014} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Static Discharge of Higher-Order Interposition}
%\subtitle{Subtitle Text, if any}

\authorinfo{Kimball Germane\and Matthew Might}
           {University of Utah}

\begin{document}

\newcommand{\chapcalc}[0]{\ensuremath{\lambda_{\mathcal{C}}}}

% TODO:
% soundness theorem
% soundness intuition
% abstract
% static analysis
% syntax
% semantics


\maketitle

\begin{abstract}
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%term1, term2

%\keywords
%keyword1, keyword2

%\cite{siek2009exploring}
%\cite{wadler2009well}

% behavioral contracts
% monitoring
% projection
% discharge
% demotion or promotion
% compliance
% chaperone vs. chaperoned operator
% 

\section{Introduction}

% what is the problem?
Higher-order behavioral contracts take time and space to enforce.

%But we expect many contract projections to be benign.

It takes time to determine compliance of first-order values as first-order contracts can be arbitrary predicates.
Additionally, functions may ascribe contracts to their higher-order arguments which themselves do similarly, even recursively.
Execution time of the program proper can be dwarfed by that of the enforcement of its specification \cite{strickland2012chaperones}.
%There isn't much a calculus can do to solve the time issue, especially in the face of dependent contracts.

Because contract compliance of higher-order values cannot be determined in general at ascription time, compliance checks must be attached to values to be performed later.
These attachments may accumulate, even changing the asymptotic space complexity of the program \cite{herman2010space} unless otherwise handled (again see \cite{herman2010space} or, for example, \cite{siek2010threesomes}).

%This space issue is well-known and a few different approaches have been taken to deal with it:
%Herman's coercion calculus, Wadler and Sieks' threesome calculus, the space-efficient contracts author
%These do well to soundly preserve the asymptotic space complexity of the program and perhaps the time as well.

The approach of hybrid type checking \cite{flanagan2006hybrid} offers a balance between the rigidity and performance of static type systems and the flexibility and cost of dynamic contracts by using static analyses to establish contract compliance at compile time, if possible, and relying on dynamic checks otherwise.
Modular development can impede these analyses because the greatest amount of knowledge a module can have about its imports \emph{is} their behavioral contract.\footnote{Indeed, it can be less than this, as when the behavioral specification is not codified entirely within the program.}
(For example, recognizing that contracts constitute total formal knowledge, Tobin-Hochstadt and Van Horn \cite{tobin2012higher} conduct an intra-module analysis which identifies extra-module references with opaque values that satisfy their contract.)
% also, contracts are attached to values that flow across module boundaries.
Nevertheless, static analyses typically perform best when given whole programs.
For instance, the whole-program ML compiler MLton \cite{weeks2006whole} is able to perform thorough inter-procedural and inter-modular analysis and effect significant program optimizations.

We turn our attention to whole-program analysis of Racket \cite{plt-tr1}, a higher-order, dynamically-typed language, for the purpose of statically discharging contracts.
Racket programs are organized into modules which consist of import and export declarations, definitions, and expressions.
Because Racket has rich facilities for syntactic extension, execution of code must be carefully controlled, especially since modules can be compiled separately \cite{flatt2002composable}.
Therefore, the quickest way to a whole program is by \emph{demodularizing} pre-compiled modules into a whole program in the Racket bytecode language (which, contrary to its name, is a fairly rich higher-order language).
At this level, contracts are manifest in terms of \emph{interposition} primitives.


Recent advances in higher-order program analysis \cite{earl2012introspective} allow the form of the stack to be approximated at each control point in the program.
The original purpose of this approximation was to provide an abstract garbage collector a conservative set of live frames, which disregards some latent structure provided by the analysis.
Specifically, the pushdown system characterization of an abstract interpretation immediately admits a finite description of an unbounded stack as a regular expression.
We use this structure to approximate blame on a misbehaving program.
Using a notion of dependence similar to Might's \cite{might2009interprocedural}, we devise a blame analysis which allows us to soundly and statically discharge contracts.

%The motivation for this was to provide an abstract garbage collector a set of live frames, disregarding any stack structure latent in the control flow graph.

%This description alone is enough to allow us to reason statically about features based on stack inspection, such as security checks [cite] and dynamic binding [cite].
%We will use it to approximate blame on a misbehaving program.
%After considering all possible sources of such blame, a straightforward analysis allows us to alter contract sites, shifting some of the dynamic burden to the static.

% thus, in order to soundly discharge contracts from the original program, we must soundly discharge impersonators and chaperones.
%The implementation of familiar language features is sometimes accomplished through alien constructs.
% (Because the feature must be situated particularly within the already existing features of the language.)
%Contracts are a common feature of dynamically-typed languages.
%Higher-order contracts \cite{findler2002contracts} increase the domain of contracts to higher-order values.
%Of course, codomain compliance of a higher-order contract cannot be decided at attachment time.
%Instead, contracts are decomposed and positioned to intercept the arguments and results of application--the earliest possible time that contract compliance can be determined.
%This \emph{de facto} wrapping of deferred contract checks imposes space and time overhead.
%Wadler and his cronies and Herman and his cronies \cite{wadler2009well,herman2010space} show how the accumulation of wrappers can grow unbounded and offer various solutions to ameliorate this.
%Determining contract compliance can make up a significant portion of reduction.

%Higher-order contracts \cite{findler2002contracts} are now familiar constructs of languages but their implementation in Racket, which must cope with other language features--perhaps incidentally, is in terms of value wrappers.
% \emph{impersonators} and \emph{chaperones}.
%In Racket, data contracts are implemented at the bytecode level using interposition primitives--that is, values are wrapped and these wrappers intercept arguments and results.
%Because functions are data in a higher-order language, special care has been given to enforcing safe and sound function contracts.
%Of course, codomain contract compliance cannot be decided.
%In consequence, codomain contract checks are deferred until the function actually delivers a value.

%Nevertheless, analysis tools have access to more of certain kinds of information after compilation and so have the potential to prove more and different properties about programs.
%Specifically, analysis tools for Racket have access to the whole program after module compilation through a \emph{demodularization} process.

%Racket program lifecycle--the tipping of various types of information

% a static analysis defines a class of program transformations
% if the analysis is sound, the transformation is meaning-preserving
% are these two preceding statements true?

%This goal can be sought at each of the various stages of the Racket program lifecycle.
%Initially, programs are organized into modules, and dynamic behavior can be gleaned from contract declarations at module boundaries.\cite{tobin2012higher}
%Each module is compiled in isolation to bytecode; the bytecode compiler performs optimizations which rely on at most basic flow analysis are performed (constant-folding, 
%``The bytecode compiler applies all standard optimizations, such as constant propagation, constant folding, inlining, and dead-code elimination.''
%The journey to this stage discards high-level information and doesn't acquire much new information, so analysis here is probably fruitless.

%Racket modules are compiled to bytecode. This

%implementation of contracts within racket using interposition

%talk about blame and the method Racket uses to assign blame--the compilation process, etc.

We discuss interposition and its relationship to behavioral contracts in more depth in Section 2.
We introduce the syntax and semantics of \chapcalc, a core calculus with facilities for interposing higher-order values, in Section 3.
We present two theorems which establish the conditions for the safe removal or weakening of interposition in Section 4.
We present a static analysis which can judge when these conditions hold in Section 5.
We present performance benchmarks of programs subject to this static analysis in Section 6.
We discuss some language features which require more care to integrate with the present analysis in Section 7.
We conclude by discussing the future application and direction of this work in Section 8.

\setspecialsymbol{LAMBDA0}{$\lambda_0$}
\setspecialsymbol{LAMBDA1}{$\lambda_1$}
\setspecialsymbol{LAMBDA2}{$\lambda_2$}

\setspecialsymbol{LAMBDA}{$\lambda$}
\setspecialsymbol{GE}{$\ge$}
\setspecialsymbol{EPS}{$\epsilon$}

\section{Interposition}

The implementation of familiar language features is sometimes accomplished through alien constructs.
In point of fact, behavioral contracts in Racket are manifest at run time by one of two interposition primitives: \emph{impersonators} and \emph{chaperones}.

An impersonator wraps a value and intercepts operations on it, potentially redirecting the operations arbitrarily.
In the case of higher-order values such as procedures, impersonators intercept arguments and can alter or replace them before passing them to the procedure they wrap.

For instance, the expression
\begin{schemedisplay}
(impersonate-procedure (LAMBDA0 (x) (+ x 1)) (LAMBDA1 (x) (+ x 2)))
\end{schemedisplay}
creates a \emph{procedure impersonator value} which, when applied to a single argument, first applies the $\lambda_1$ closure (the \emph{impersonating} procedure) to that argument and applies the $\lambda_0$ closure (the \emph{impersonated} procedure) to the result.
The net effect of applying this impersonator value, then, is to add three to the argument.

The impersonating procedure can include a procedure value in addition to its results which will be applied to the results of application of the impersonated procedure.
Modifying our previous example, the expression
\begin{schemedisplay}
(impersonate-procedure (LAMBDA0 (x) (+ x 1))
                       (LAMBDA1 (x) (values (LAMBDA2 (x) (+ x 3)) (+ x 2))))
\end{schemedisplay}
creates a procedure impersonator value which behaves identically to the first example up to the return of the impersonated procedure, at which point the $\lambda_2$ closure is applied to its result.
The net effect of applying this impersonator value is to add six---not three---to the argument.

We will often refer to the impersonating procedure as the \emph{negative guard} as an error raised by it is construed as blaming the negative position; we refer to the additional value returned by the negative guard as the \emph{positive guard} for the same reason.
In cases where a positive guard is provided, the wrapper analogy is apt as values must pass through an impersonator barrier at both entry to and exit from the procedure.

Chaperones refine impersonators by trading behavioral freedom for reasonability~\cite{strickland2012chaperones}.
Well-behaved procedure chaperones cannot alter intercepted arguments arbitrarily; they may only install chaperones on them.
Chaperones share the ability of impersonators to perform side-effects.
In particular, they retain the ability to raise exceptions, the mechanism by which contract violations are signalled.

As an example of a realistic use of a chaperone, consider the factorial procedure for which a chaperone dynamically enforces the type of its argument and result\footnote{Of course, even without a chaperone, applying the factorial procedure to a non-number argument will provoke an error, but to a non-integer argument will diverge. The chaperone here addresses both cases: it causes blame to be assigned at the procedure level, and encodes the specification sufficiently to avoid divergence.} expressed as
\begin{schemedisplay}
(chaperone-procedure
 (letrec ([fact (LAMBDA (n)
                  (if (= n 0)
                      1
                      (* n (fact (- n 1)))))])
   fact)
 (LAMBDA (n)
   (if (and (integer? n) (GE n 0))
       (values (LAMBDA (n)
                 (if (and (integer? n) (GE n 1))
                     n
                     (raise result error ...)))
               n)
       (raise argument error ...))))
\end{schemedisplay}
The chaperoning procedure is only shallowly installed in that only the initial argument and final result of a factorial application are scrutinized.
This is consistent with the way that chaperones are employed by the contract system: chaperones are attached to values typically only as they pass through module boundaries, and rarely to track intra-module blame.

Finally, we illustrate the rationale of a protocol in which the negative guard produces the positive guard instead of the user providing it to \scheme{chaperone-prodedure} directly.
Consider the installation of a chaperone on the square root function, \scheme{sqrt}, given by
\begin{schemedisplay}
(chaperone-procedure
 sqrt
 (LAMBDA (x)
   (if (and (real? x) (GE x 0))
       (values (LAMBDA (y)
                 (if (and (real? x) (< (abs (- (* y y) x)) EPS))
                     y
                     (raise positive error ...)))
               x)
       (raise negative error ...))))
\end{schemedisplay}
wherein the chaperoning procedure not only refines the domain contract of \scheme{sqrt} (from \scheme{number?} to non-negative \scheme{real?}) but checks its result against a correctness constraint.
In general, allowing the positive guard to be lexically embedded in the negative guard gives the former access to the arguments of the latter which, in turn, allows richer specifications to be expressed, such as dependent contracts \cite{findler2002contracts}.

\subsection{Run-time cost of impersonators and chaperones}

We can put the phases of creation, projection, and application of the contract lifecycle in correspondence with components of the impersonating lifecycle.

The creation time of a contract corresponds with the evaluation of the negative guard procedure expression (typically at installment time) and the positive guard procedure expression (at application time).
In the vast majority of cases, these guard expressions are simple $\lambda$-terms so their contribution to the overall cost of interposition is negligible.

The projection time of a contract corresponds with the installation of an impersonator on a procedure.
This is essentially an atomic operation.

The bulk of the run-time cost of interposition is accrued at application time which corresponds exactly to that of a contract.
The cost incurred is due to enforcement of the interposition protocol.
This entails that
\begin{itemize}
\item negative guards must return the same number of values as given (except for an optional positive guard);
\item the positive guard, if provided, must be a procedure;
\item the positive guard must accept the number of results produced by the impersonated procedure;
\item the positive guard must produce the same number of results as arguments given to it;
\end{itemize}
and, for chaperoning interposition,
\begin{itemize}
\item the negative guard must return only its arguments or chaperoned versions of them; and
\item the positive guard must do likewise.
\end{itemize}

Thus, we would prefer to remove all application costs due to interposition, but will accept merely removing the costs specific to chaperoning.

\section{Chaperone Calculus}

In order to explicate a static analysis of higher-order interposition, we define \chapcalc, or \emph{chaperone calculus}, an extension of the A-normalized $\lambda$-calculus with interposition facilities.

As only a moderate extension of the $\lambda$-calculus, \chapcalc\ lacks many Racket features, not the least of which is mutation.
We will see, in addition, that counterparts to both \scheme{impersonate-procedure} and \scheme{chaperone-procedure} exist as tags of syntactic forms instead of first-class values as in Racket.
Providing them as first-class entities would increase the expressive power [cite Felleisen] of \chapcalc\ and, in general, require a more powerful analysis.
In practice, \scheme{impersonate-procedure} and \scheme{chaperone-procedure} are most often referenced directly by name and so treated more as syntactic tags.
We will treat their \chapcalc\ counterparts as such specifically to simplify the presentation of the analysis, but discuss a strategy to integrate first-class uses of them in Section ?.
%In the actual analysis, we consider all call sites and add a condition for the sound discharge of a call site that \scheme{chaperone-operator} is the only values to flow to the operator position.

\subsection{\chapcalc\ Syntax}

The syntax of \chapcalc\ can be seen in figure \ref{fig:syntax}.

\chapcalc\ inherits application, abstraction, and variable terms from the $\lambda$-calculus.
It includes simple values from the domain of integers and booleans as well as a set of first-class primitive functions which operate over these values.

The syntactic class $\ae$ signifies \emph{atomic expressions} and includes $\lambda$-terms, variables, and the simple values of booleans, integers, and primitive functions. Expressions classified as such will never produce an error or diverge.

The syntactic class $c$ denotes application terms which are formed by an atomic operator expression followed by a sequence of atomic operand expressions.

The syntatic class of expressions, denoted $e$, includes \scheme{let}, \scheme{letrec}, \scheme{if} expressions as well as \scheme{chaperone-operator} and \scheme{impersonate-operator} forms.

Each \scheme{chaperone-operator} form is annotated with a unique label $\ell$ to keep otherwise identical terms distinguishable.

The second subform of a \scheme{chaperone-operator} or \scheme{impersonate-operator} remains a proper expression to facilitate some of the blame semantics.

\newcommand{\vx}[0]{\mathbf{x}}

\newcommand{\appe}[2]{(#1\,#2)}
\newcommand{\lame}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\chae}[2]{(\mathit{chaperone\mhyphen operator}\,#1\,#2)^\ell}
\newcommand{\impe}[2]{(\mathit{impersonate\mhyphen operator}\,#1\,#2)}
\newcommand{\lete}[3]{(\mathbf{let}\,((#1)\,#2)\,#3)}
\newcommand{\letrece}[3]{(\mathbf{letrec}\,((#1)\,#2)\,#3)}
\newcommand{\ife}[3]{(\mathbf{if}\,#1\,#2\,#3)}

\newcommand{\ande}[2]{(\mathrm{and}\,#1\,#2)}
\newcommand{\ore}[2]{(\mathrm{or}\,#1\,#2)}

\newcommand{\true}[0]{\mathrm{\#t}}
\newcommand{\false}[0]{\mathrm{\#f}}
\setlength{\tabcolsep}{1pt}
\begin{figure}
\label{fig:syntax}
%\begin{tabular}{rcl}
%c & = & $\appe{e}{e\,\dots}$ & application\\
%\end{tabular}

\begin{verbatim}
 c = (ae ae ...)                 application
 e = (let ((x ...) c) e)         let
   | (letrec ((x ...) c) e)      letrec
   | (if ae e e)                 if
   | (chaperone-operator ae e)   chaperone-operator
   | (impersonate-operator ae e) impersonate-operator
ae = (lambda (x ...) e) | x | p | i | b
 p = < | > | = | values | not | integer?
   | + | - | raise | boolean? | operator?
 x = variables
 i = 0 | 1 | -1 | 2 | -2 | ...
 b = #t | #f
\end{verbatim}

%\begin{align*}
%c &= \appe{\ae}{\ae\,\dots} && \text{application}\\
%e &= \lete{x\,\dots}{c}{e} && \text{let}\\
%  &|  \letrece{x\,\dots}{c}{e} && \text{letrec}\\
%  &|  \ife{\ae}{e}{e} && \text{if}\\
%  &   \chae{\ae}{e} && \text{chaperone-operator}\\
%  &   \impe{\ae}{e} && \text{impersonate-operator}\\
%\ae &= \lame{x\,\dots}{e}\,|\,x\,|\,p\,|\,i\,|\,b && tsh\\
%p &= values | = | < | > | + | - | not | integer? | boolean? | operator? | raise && \\
%x &= ha & \\
%i &= 0|1|-1|2|-2|\dots\\
%b &= \true\,|\,\false\\
%\end{align*}

\begin{tabular}{rrl}
$c$ & = & $\appe{\ae}{\ae\,\dots}$\\
$e$ & = & $\lete{x\,\dots}{c}{e}$\\
    & | & $\letrece{x\,\dots}{c}{e}$\\
g & h & i
\end{tabular}
\caption{The syntax of \chapcalc.}
\end{figure}

A program is a term in the grammar with no free variables and in which all identifiers in the same binding form are pairwise distinct.




% raise integer? boolean? not operator? + - * = < > values
% need primitives to allow contracts to deal higher orderly
% ae := (lambda s e) x primitive integer boolean

% (ae ae ...)
% (app-values ae ae)
% (chaperone-operator ae ae ae)
% (impersonate-operator ae ae ae)
% (let ([s call]) e)
% (letrec ([s call]) e) IS IT POSSIBLE TO LIFT AN EXPRESSION OUT THAT SHOULDN'T BE?
% (if ae e e)
% (lambda s e)

% results are:
% values: closures, chaperones, impersonators, primitives, integers, booleans
% errors: error, blame L, blame +L, blame -L

% (e e1 ... en),\rho,\sigma,\kappas
% v = A(e,\rho,\sigma), vi = A(ei,\rho,\sigma)
% case v
%   ((lambda s e'),\rho')
%   if s compatible with n
%     (e',\rho'',\sigma',\kappas) where \rho'' and \sigma' bind vis according to s
%     error
%   primitive
%   if primitive arity compatible with n
%     \delta(primitive,v1,...,vn)
%     error
%   (chaperone L f neg pos)
%   (lambda vs
%     (let ([vs' (app-values neg vs)])
%       (if (= (length vs)
%              (length vs'))
%           (if (and-map chaperone-of? vs' vs)
%               (let ([rs' (app-values f vs')])
%                 (if (arity-comp? pos rs')
%                     (let ([rs (app-values pos rs')])
%                       (if (= (length rs')
%                              (length rs))
%                           (if (and-map chaperone-of? rs rs')
%                               (app-values values rs)
%                               (error)) (blame + guard)
%                           (error))) (blame + guard)
%                     (error))) (blame + guard)
%               (error)) (blame - guard)
%           (error)))) (blame - guard)

\newcommand{\A}[3]{\mathcal{A}(#1,#2,#3)}

\newcommand{\dynbla}[1]{\mathrm{dynamic\mhyphen blame}(#1)}

\newcommand{\ks}[0]{\kappa s}
\newcommand{\vv}[0]{\mathbf{v}}
\newcommand{\vvp}[0]{\mathbf{v'}}
\newcommand{\sexp}[4]{\Sigma_e(#1,#2,#3,#4)}
\newcommand{\sval}[3]{\Sigma_v(#1,#2,#3)}
\newcommand{\sapp}[4]{\Sigma_a(#1,#2,#3,#4)}
\newcommand{\scha}[6]{\Sigma_d(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdchaz}[6]{\Sigma_{chap_0}(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdchao}[5]{\Sigma_{chap_1}(#1,#2,#3,#4,#5)}
\newcommand{\serr}[0]{\mathrm{error}}
\newcommand{\sbla}[2]{\mathrm{blame}_{#1}(#2)}
\newcommand{\app}[4]{\mathrm{apply}(#1,#2,#3,#4)}
\newcommand{\red}[2]{\begin{align*}& #1\\\rr\, & #2\end{align*}}

\newcommand{\bind}[4]{\mathrm{bind}(#1,#2,#3,#4)}
\newcommand{\prebind}[2]{\mathrm{pre\mhyphen bind}(#1,#2)}
\newcommand{\recbind}[4]{\mathrm{rec\mhyphen bind}(#1,#2,#3,#4)}

\newcommand{\clo}[2]{(#1,#2)}
\newcommand{\cha}[2]{\mathrm{chaperone}(\ell,#1,#2)}
\newcommand{\imp}[2]{\mathrm{impersonator}(#1,#2)}

\newcommand{\chak}[1]{\mathrm{chap}_\kappa(\ell,#1)}
\newcommand{\chacwk}[2]{\mathrm{chap\mhyphen neg\mhyphen ults}_\kappa(\ell,#1,#2)}
\newcommand{\chacfk}[1]{\mathrm{chap\mhyphen fun\mhyphen ults}_\kappa(\ell,#1)}
\newcommand{\chacrk}[1]{\mathrm{chap\mhyphen pos\mhyphen ults}_\kappa(\ell,#1)}

\newcommand{\impk}[1]{\mathrm{imp}_\kappa(\ell,#1)}
\newcommand{\impcwk}[2]{\mathrm{imp\mhyphen neg\mhyphen ults}_\kappa(\ell,#1,#2)}
\newcommand{\impcfk}[1]{\mathrm{imp\mhyphen fun\mhyphen ults}_\kappa(\ell,#1)}
\newcommand{\impcrk}[1]{\mathrm{imp\mhyphen pos\mhyphen ults}_\kappa(\ell,#1)}


\newcommand{\letk}[3]{\mathrm{let}_\kappa(#1,#2,#3)}
\newcommand{\letreck}[3]{\mathrm{letrec}_\kappa(#1,#2,#3)}


\newcommand{\rr}{\longrightarrow}
\newcommand{\rrs}{\longrightarrow^{*}}

\subsection{$\chapcalc$ Semantics}

expression: forms + primitives + booleans + numbers + labels + variables
value: primitive + boolean + number + closure + impersonator + chaperone
semantics: stack frame + stack (sequence of frames) + store + address + environment as finite map
$\Gamma^{*}$

We use boldface to denote a vector of objects in that category, i.e., $\mathbf{v}$ denotes a vector $\langle v_1,\dots,v_n\rangle$ for some natural number $n$.

We define the semantics of \chapcalc\ in terms of an abstract machine similar to Felleisen's CESK machine[cite that] to directly apply a particular static analysis.

With the introduction of chaperones and impersonators (and the incusion of primitive functions), we can no longer count on the operator of an application to be a closure.
Thus, we will treat these three categories of values as classes of \emph{operators} and will refer to them collectively as such.

In difference, our machine is defined in terms of multiple state variants.
\begin{itemize}
\item An \emph{evaluation} state $\Sigma_{e}(\langle\gamma,\dots\rangle,\sigma,\rho,e)$ corresponds to a traditional CESK state.
(The order of the components is reversed, however, to aid factoring out common components from among the variants.)

%$\varsigma\in\mathrm{Kont}\times\mathrm{Sto}\times\mathrm{Env}\times\mathrm{Exp}$

\item An \emph{apply} state $\Sigma_{a}(\langle\gamma,\dots\rangle,\sigma,f,\mathbf{v})$ represents a point of application and dispatches on the operator type (closure, impersonator, or primitive).
\item A \emph{value} state $\Sigma_{v}(\langle\gamma,\dots\rangle,\sigma,\mathbf{v})$ represents a point of return and dispatches on the type of the top continuation frame.
If the continuation is empty, the constituent values are the results of the program.
\item An \emph{error} state $\Sigma_!(\langle\gamma,\dots\rangle,\sigma,b)$, represents the arisal of an error and, as the result of the program, may include blame information.
\item Finally, we define a set of \emph{dummy} states which splits a transition which would otherwise pop and push a frame simulaneously into a sequence of two transitions which performs each separately.
(This eases further the transition to a pushdown system.)
\end{itemize}


%\begin{figure}
%\begin{align*}
%  c \in \sa{Conf} &= \syn{Exp} \times \sa{Env} \times \sa{Store} \times \sa{Kont} && %\text{[configurations]}
%  \\
%  \aenv \in \sa{Env} &= \syn{Var} \parto \sa{Addr} && \text{[environments]}
%  \\
%  \astore \in \sa{Store} &= \sa{Addr} \to \Pow{\sa{Clo}} && \text{[stores]}
  % \\
  % \aden \in \sa{Den} &= \Pow{\sa{Clo}} && \text{[denotable values]}
%  \\
%  \aclo \in \sa{Clo} &= \syn{Lam} \times \sa{Env} && \text{[closures]}
%  \\
%  \acont \in \sa{Kont} &= \sa{Frame}^* && \text{[continuations]}
%  \\
%  \Gamma \in \sa{Frame} &= \syn{Var} \times \syn{Exp} \times \sa{Env}  && \text{[stack frames]}
%  \\
%  \alpha \in \sa{Addr} &\text{ is a \emph{finite} set of addresses} && \text{[addresses]}
%  \text.
%\end{align*}
%\caption{The abstract configuration-space.}
%\label{fig:abs-conf-space}
%\end{figure}


The result of a program is
\begin{itemize}
\item \emph{values} taken from the set of simple values or run-time values of closures, impersonators, and chaperones,
\item an \emph{error} which may include blame information indicating the source of the error, or
\item divergence.
\end{itemize}

\begin{verbatim}
\sigma\in\Sigma = e Kont x Store x Env x Exp
                | v Kont x Store x Val*
                | a Kont x Store x Val x Val*
           Kont = Frame*
          Frame = let Var* x Env x Exp
                | letrec Var* x Env x Exp
                | chap-create Lab x Val
                | chap-neg Lab x Val x Val*
                | chap-ope Lab x Val
                | chap-pos Lab x Val*
          Store = Addr -> Val
            Env = Var -> Addr
           Addr = infinite set of addresses
\end{verbatim}

A program is injected into a machine state with the function $\mathcal{I} : e\rightarrow\Sigma$ defined as $\mathcal{I}(p)=\sexp{\langle\rangle}{\perp}{\perp}{p}$.

The reduction relation is defined first in terms of the class of machine state.

\subsubsection{application}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\appe{\ae_f}{\ae_1\,\dots\,\ae_n}}}{\sapp{\ks}{\sigma}{f}{\langle v_1,\dots,v_n\rangle}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$ and $v_i=\A{\sigma}{\rho}{\ae_i}$ for $i=1,\dots,n$.

\subsubsection{chaperone-operator}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\chae{\ae_f}{e_w}}}{\sexp{\chak{f}::\ks}{\sigma}{\rho}{e_w}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$.

\noindent
\red{\sval{\chak{f}::\ks}{\sigma}{\vv}}{\sval{\ks}{\sigma}{\langle\cha{f}{w}\rangle}}

\noindent
%where $\alpha_f=\mathrm{alloc}(\sigma,f)$ and $\alpha_w=\mathrm{alloc}(\sigma,w)$
if $\vv=\langle w\rangle$ for some value $w$, $\mathrm{operator?}(f)$, $\mathrm{operator?}(w)$, and $\mathrm{arity}(w)=\mathrm{arity}(f)$.

\noindent
\red{\sval{\chak{f}::\ks}{\sigma}{\vv}}{\sbla{2,8,9}{\ell}}

\noindent
if $\vv\ne\langle w\rangle$ for any value $w$, $\mathrm{operator?}(f)$ does not hold, $\mathrm{operator?}(w)$ does not hold, or $\mathrm{arity}(w)\ne\mathrm{arity}(f)$.

%$\red{\sval{\chak{\rho}{e_w}::\ks}{\sigma}{\vv}}{\scha{\ks}{\sigma}{\rho}{e_w}{\ell}{f}}$
%if $\vv=\langle f\rangle$ for some $f$ such that $\mathrm{operator?}(f)$

%$\red{\sval{\chak{f}::\ks}{\sigma}{\vv}}{\sbla{\ell}}$
%if $\vv=\langle f\rangle$ for some $f$ where $\mathrm{operator?}(f)$ does not hold

%We assign blame to $\ell$ here because if we were to replace this \scheme{chaperone-operator} form with its first subform, this error would not be raised unless and until the resultant value was applied.
%Because it is not necessarily applied, deferring the error changes the meaning of the program.

%$\red{\sval{\chapk{\rho}{e_w}::\ks}{\sigma}{\vv}}{\serr}$
%if $\vv\ne\langle f\rangle$ for any $f$

%$\red{\scha{\ks}{\sigma}{\rho}{e_w}{\ell}{f}}{\sexp{\chawk{f}::\ks}{\sigma}{\rho}{e_w}}$

%$\red{\sval{\chawk{f}::\ks}{\sigma}{\vv}}{\sval{\ks}{\sigma}{?}}$
%if $\vv=\langle g\rangle$ for some $g$ such that $\mathrm{operator?}(g)$ and %$\mathrm{arity}(f)=\mathrm{arity}(g)$

%$\red{\sval{\chawk{f}::\ks}{\sigma}{\vv}}{\sbla{\ell}}$
%if $\vv\ne\langle g\rangle$ for any $g$ or $\vv=\langle g\rangle$ for some $g$ where $\mathrm{operator?}(g)$ does not hold or $\mathrm{arity}(f)\ne\mathrm{arity}(g)$

%We assign blame to $\ell$ here for the same reasons we did before.

% we can blame the chaperone creation site which precludes its removal
% we can blame the wrapper functions for not chaperoning the arguments

\subsubsection{impersonate-operator}

%\red{\sexp{\ks}{\sigma}{\rho}{\impe{e_f}{e_w}}}{}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\impe{\ae_f}{e_w}}}{\sexp{\impk{f}::\ks}{\sigma}{\rho}{e_w}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$.

\noindent
\red{\sval{\impk{f}::\ks}{\sigma}{\vv}}{\sval{\ks}{\sigma}{\langle\imp{f}{w}\rangle}}

\noindent
if $\vv=\langle w\rangle$ for some value $w$, $\mathrm{operator?}(f)$, $\mathrm{operator?}(w)$, and $\mathrm{arity}(w)=\mathrm{arity}(f)$.

\noindent
\red{\sval{\impk{f}::\ks}{\sigma}{\vv}}{\dynbla{\ks}}

\noindent
if $\vv\ne\langle w\rangle$ for any value $w$, $\mathrm{operator?}(f)$ does not hold, $\mathrm{operator?}(w)$ does not hold, or $\mathrm{arity}(w)\ne\mathrm{arity}(f)$.

\subsubsection{let}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\lete{x_1\,\dots\, x_n}{e_0}{e_1}}}{\sexp{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\rho}{e_0}}

\noindent
where $\vx=\langle x_1,\dots,x_n\rangle$.

\red{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma'}{\rho'}{e_1}}

\noindent
where $(\sigma',\rho')=\bind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

\red{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\dynbla{\ks}} if $|\vx|\ne|\vv|$

\subsubsection{letrec}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\letrece{x_1\,\dots\, x_n}{e_0}{e_1}}}{\sexp{\letk{\rho'}{\vx}{e_1}::\ks}{\sigma}{\rho}{e_0}}

\noindent
where $\vx=\langle x_1,\dots,x_n\rangle$ and $\rho'=\prebind{\rho}{\vx}$.

\red{\sval{\letreck{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma'}{\rho}{e_1}}

\noindent
where $\sigma'=\recbind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

\red{\sval{\letreck{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\dynbla{\ks}} if $|\vx|\ne|\vv|$

\subsubsection{if}

\red{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}{\sexp{\ks}{\sigma}{\rho}{e_c}}
if $v_t\ne\false$
where $v_t=\A{\sigma}{\rho}{\ae_t}$.

\red{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}{\sexp{\ks}{\sigma}{\rho}{e_a}}
if $v_t=\false$
where $v_t=\A{\sigma}{\rho}{\ae_t}$.

%$\red{\sval{\ifk{\rho}{e_c}{e_a}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma}{\rho}{e_c}}$
%if $\vv=\langle v_0\rangle$ for some $v_0\ne\false$

%$\red{\sval{\ifk{\rho}{e_c}{e_a}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma}{\rho}{e_a}}$
%if $\vv=\langle v_0\rangle$ for $v_0=\false$

%$\red{\sval{\ifk{\rho}{e_c}{e_a}::\ks}{\sigma}{\vv}}{\serr}$
%if $\vv\ne\langle v_0\rangle$ for any $v_0$

% primitive
% integer
% boolean
% (lambda s e)
% x

\subsection{apply}

\emph{apply} states serve as the branching point for dispatch on the operator.

\subsubsection{closure}

The application of a closure operator proceeds straightforwardly by extending its environment and evaluating its body.

\red{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}{\sexp{\ks}{\sigma'}{\rho'}{e}}
where $\vx=\langle x_1,\dots,x_n\rangle$ and $(\sigma',\rho')=\bind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

If the number of values applied is incompatible with the arity of the closure, blame is assigned dynamically.

\red{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}{\dynbla{\ks}}
if $|\vx|\ne|\vv|$ where $\vx=\langle x_1,\dots,x_n\rangle$

\subsubsection{chaperone}

Chaperone application recurs on its guard and augments the context to complete the interposition when its guard returns.
The enlarged context is annotated with the label of the applied chaperone (which itself is the label of its installment site).

\red{\sapp{\ks}{\sigma}{\cha{f}{w}}{\vv}}{\sapp{\chacwk{f}{\vv}::\ks}{\sigma}{w}{\vv}}

When the results of its wrapper are obtained, the next state is determined by the results.
If an additional result is provided and it is an operator, it is situated to intercept function results.

If the number of results obtained is the same as the number of arguments given, the interposition ceases and the function can be evaluated in tail position with respect to the chaperone application.

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sapp{\ks}{\sigma}{f}{\vvp}}
if $|\vv|=|\vvp|$ and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{1}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold.

--

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}
if $|\vv|=|\vvp|$, $\mathrm{operator?}(w)$, and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{3}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{operator?}(w)$ does not hold.

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{1}{\ell}}
if $|\vv|=|\vvp|$ and $\mathrm{operator?}(w)$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold.

--

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{4}{\ell}}
if $|\vv|\ne|\vvp|$ and $|\vv|+1\ne|\vvp|$

\red{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}{\sapp{\chacfk{w}::\ks}{\sigma}{f}{\vvp}}

\red{\sval{\chacfk{w}::\ks}{\sigma}{\vv}}{\sdchao{\ks}{\sigma}{w}{\vv}{\ell}}

\red{\sdchao{\ks}{\sigma}{w}{\vv}{\ell}}{\app{\chacrk{\vv}::\ks}{\sigma}{w}{\vv}}




\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sval{\ks}{\sigma}{\vvp}}
if $|\vv|=|\vvp|$ and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sbla{7}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold

\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sbla{6}{\ell}}
if $|\vv|\ne|\vvp|$





%$\mathrm{apply}(\kappa s,\sigma,\mathrm{chap}(f,w),\mathbf{v})=\mathrm{apply}(\mathrm{chap\mhyphen ults}_\kappa(f,\mathbf{v})::\kappa s,\sigma,w,\mathbf{v})$

%$\dynbla{\chawk{f}::\kappa s}=\sbla{\ell}$

%$\dynbla{\chawk{f}::\kappa s}=\sbla{\ell}$

%$\dynbla{\kappa ::\kappa s}=\dynbla{\kappa s}$ for other $\kappa$

%$\dynbla{\langle\rangle}=\serr$

% we can't have the chaperones carry around their parent chaperone label also because
% that set will increase as the analysis runs but we don't want to have to prove
% soundness to update the existing chaperone values (it may not even be sound)
% however, at each chaperone creation site, we build up a conservative approximation
% of the set of creators, and we can refer to that.
% does this suggest that blame should be deferred until the graph is completely built?
% unless we can target the blame with absolute precision, I think so.

% arity error on application to negative guard:
% the blame should not rest on the chaperone, because, at creation time, the negative guard was determined to have the same arity as the function, and the error would have been thrown regardless. we might want to defer the arity checking until chaperone application/invocation for symmetry, but the semantics are different: a program with an unused chaperone value might fail if it was checked eagerly, but wouldn't if it was checked lazily.
% number of results not number of arguments on negative guard:
% blame negative guard because values would not raise this (which means chaperone discharge would not either)
% results not chaperone-of? the arguments
% blame negative guard because values would not produce this
% if a guard throws an error (transitions to an error, really), we wait until the analysis is over to assign blame because we need to know what's in the stack and we don't get that fully until the end.
% application of f to guard results will not throw (not because of arity, and also because a user program cannot distinguish between a chaperone of a value and a value)
% application of pos guard to results of f may throw for arity
% blame positive guard because values would not do this
% number of results not number of arguments:
% blame positive guard because values would not do this
% results not chaperone-of? the arguments
% blame positive guard because values would not do this

% at the end, we have a transition graph. there are error states and a few direct blame states. for each chaperone creation state (and so label), we determine the set of signed labels that correspond to chaperone guards that were active at its creation.
% for every error state, we determine the set of signed labels that correspond to chaperone labels that were active at its raise.
% we then use these maps to determine which chaperones are blameless!

% NOW, is it true that, when an error is thrown, we can actually bound its source to the current approximation of the stack?
% is it true that, when a chaperone is created, we can bound its source to the current approximation of the stack?
% I don't think so because later states may raise errors that are directed to the same place and those errors might not be blamed on the right party.

% ACTUALLY when we apply a chaperone, we check whether the operator can accept that number of arguments. if not, we throw an error (with no blame!)
% this means that a negative guard can be treated like a positive guard

%Changing the form of \scheme{chaperone-procedure} to take the negative and positive guards more explicitly doesn't actually make it more understandable in the long run, and doing it to avoid dealing with dependent contracts is unnecessary.

%First, in doing so, we have to account for the possibility of the evaluation of the positive guard resulting in an error. Granted, we expect most guards to be variables or lambda expressions, but they are not constrained to be. In the current calculus, the evaluation of a positive guard resulting in an error would be blamed on the chaperone call itself, still opening the door for the negative guard to be replaced with values. In a more accurate calculus, that error would be attributed to the negative guard itself.

\section{Chaperone Discharge and Demotion}

\subsection{Expectation that many dynamic checks are unnecessary}

Programs that can result in an error are incorrect.
The purpose of blame assignment is to facilitate the act of correcting the program.
We expect a program to result in a blame assignment only rarely.
We have similar expections for a program to result in divergence, and that specifically at the hand of a chaperoned value.
In fact, we expect correct programs never to exhibit such behavior, and while chaperones serve the reality of incorrect programs, the frequency of their complaints diminishes in the long run as the programmer applies their feedback.
The nature of the programming cycle indicates that there may be some chaperones which, situated within a particular program, do not influence the behavior of the program and also that the proportion of chaperoned values in such a position may increase as the program is maintained.

Strickland et al.~\cite{strickland2012chaperones} present a chaperone erasure theorem for a calculus with vector-manipulation primitives.
This theorem establishes that a program with chaperoned values which evaluates successfully will exhibit the same behavior with all the chaperones erased--that is, with chaperone installment removed from the program.
The chaperone erasure theorem, then, makes a statement about the influence chaperones have on the meaning of programs.
We present theorems which build on this conceptual result by giving the conditions under which a chaperone installation can be omitted without changing the meaning of the program.

\subsection{Intuition behind sound discharge}

The conditions necessary for the sound discharge of a chaperone are more easily constructed by considering the conditions sufficient for a chaperone to be meaningful.
If we can enumerate a complete set of these conditions in the sense that any meaningful chaperone must meet at least one of the conditions, we obtain the soundness conditions by complement.

A chaperone \emph{cannot} be discharged if
\begin{enumerate}
\item the negative guard causes an error to be raised,
\item the negative guard diverges,
\item the negative guard does not return the same number of results as arguments given (or one extra),
\item the extra result, if provided, is not a procedure,
\item the results of the negative guard are not, at most, chaperones of the arguments,
\item the positive guard does not accept the number of results produced by the chaperoned procedure,
\item the positive guard causes an error to be raised,
\item the positive guard diverges,
\item the positive guard does not return the same number of results as arguments given, or
\item the results of the positive guard are not, at most, chaperones of the arguments.
\end{enumerate}

For a given program execution, if neither a chaperone nor its installation raises an error or diverges, it is a candidate for \emph{discharge}, or the [omission/removal] of its installation.
It is only a candidate because its application may cause a chaperone to be installed and that chaperone may not be well-behaved.
In this case, discharging the original chaperone would prevent a meaningful chaperone from being created which would make discharge unsound.
Then, intuitively, a chaperone can be discharged if it will not raise an error or diverge  \emph{and} any chaperones it installs can be discharged.

The discharge of a chaperone amounts to replacing its installation site with that site's first argument
However, multiple chaperone installations may occur at a given chaperone installation site during program execution, so we cannot, in all circumstances, selectively prevent the creation of a single chaperone.
Instead, we consider the discharge of installment sites themselves.
The conditions to discharge a given site are stronger than that of a chaperone installed at that site: instead of demonstrating that a single chaperone satisfies a property, we must demonstrate that every chaperone created at that site satisfies that property \emph{and} that there is no chaperone installation at that site for which
\begin{enumerate}
\item the evaluation of its guard expression causes an error to be raised,
\item the evaluation of its guard expression diverges, or
\item the negative guard does not accept the same number of arguments as the procedure to be chaperoned.
\end{enumerate}

When put in these terms, it is clear that a chaperone installment site can be discharged only if it meets these conditions for every possible execution.
These conditions seem onerous.
Indeed, in Racket, users typically access chaperone installation through a library wrapper so all chaperones in the entire program share the same installation site.
This, in turn, means that a given chaperone can be safely discharged only if \emph{all} chaperones in all executions of the program can be safely discharged.
%In other words, the program must be correct up to the encoded specification.
Fortunately, with access to the whole program, we may inline definitions which allows us to multiply the number of installment sites in the program.

%In such cases, we may not be able to discharge only a particular chaperone.
%We therefore strengthen the discharge condition that 

\subsection{Intuition behind demotion}

Much of the run-time overhead of chaperones is shared by impersonators.
Nevertheless, the enforcement of invariants specific to chaperones is somewhat costly --- specifically, the enforcement that chaperone guards at most install chaperones on their arguments.
The conditions to \emph{demote} the set of chaperones installed at a particular site to impersonators (by replacing the \scheme{chaperone-operator} installment site with \scheme{impersonate-operator}) are immediately weaker than to discharge the site entirely: we need to demonstrate only that the chaperone guards do not arbitrarily modify their arguments (conditions 5 and 10 above) for it to be a candidate for demotion.
If one of this site's chaperones is installed on the argument of a chaperone guard, demoting this site to install merely an impersonator will make an otherwise well-behaved chaperone not so.
This observation provides us with the intuition behind sound site demotion: a chaperone may be demoted if neither of its guards do more than install chaperones on their arguments for all program executions and the chaperone which guard installed it, if any, can be and is demoted. 
We once again lift the conditions to chaperone installment sites so that a chaperone installment site can be demoted if all chaperones installed there in any program execution can be demoted and the installment sites of any installing chaperones can be and are demoted.

%We use a straightforward pushdown analysis to determine which states can result in error.
%We use a simple divergence analysis to determine which guards will always terminate.
%With those, we can determine which chaperones can be removed without introducing an error or divergence into the program.


\subsection{More formal notion of discharge and demotion}

Formally, the discharge or demotion of a chaperone installment site is defined in terms of simple program transformers.

\begin{definition}
A \emph{discharge transformation} $D_\ell : P\rightarrow P$ is a program transformation which replaces a chaperone-installment site labelled $\ell$ with its first subform.
\end{definition}

\begin{definition}
A \emph{demotion transformation} $E_\ell : P\rightarrow P$ is a program transformation which replaces a chaperone-installment site labelled $\ell$ with an impersonator-installment site with the same subforms.
\end{definition}

We assume that each chaperone-installment site is labelled uniquely within a program.
Then, as formulated, these transformations can affect only one site.
We will see that transformations which meet a set of soundness conditions can be composed and reordered.
%they unambiguously define a more powerful transformation

A sound approximation of conditions 1 and 7 is the idea of dependence (similar to that of Might~\cite{might2009dependence}).

\begin{definition}
A chaperoned operator is \emph{active} if evaluation is within the dynamic extent of its negative or positive guard.
\end{definition}

\begin{definition}
A chaperoned operator $f$ \emph{depends} on a chaperoned operator $g$ if $g$ is active when the the chaperone $f$ is installed.
\end{definition}

\begin{definition}
A chaperone installment site \emph{depends} on a chaperoned operator $g$ if a chaperone installed there depends on $g$.
\end{definition}

\begin{definition}
An error \emph{depends} on a chaperoned operator if that operator is active at the time the error is raised.
\end{definition}

Chaperone guards may themselves invoke chaperoned operators, so there may be more than one active chaperone at any given time.

\begin{definition}
An error \emph{depends} on a chaperoned installation site if the error is raised during evaluation of the guard.
\end{definition}

%We call the most-recently-activated chaperone the \emph{youngest} chaperone.
%At evaluation time of a chaperone installment site, we say that the youngest chaperone is \emph{dependent} on the site.
%Because a given chaperone installment site may be evaluated multiple times during program execution and from multiple control paths, a chaperone creation site may have several dependent chaperones.

\subsection{Soundness of discharge and demotion}

The sound discharge or demotion of a chaperone-installment site cannot change the meaning of the program.
In terms of \chapcalc, a discharge should not be judged sound if an execution that once resulted in an error (because of a misbehaving chaperone, say) results in a value or vice versa.
Additionally, a divergent program should not converge after demotion.


\begin{definition}[Transformation Soundness]
We say a program transformation $F$ is \emph{sound} for a program $p$ when it holds that
\begin{itemize}
\item if $p\rrs v$, then $F(p)\rrs v$,
\item if $p\Uparrow b$, then $F(p)\Uparrow b$, and
\item if $p\Uparrow$, then $F(p)\Uparrow$.
\end{itemize}
\end{definition}

\begin{definition}
A chaperoned operator is \emph{well-behaved} with respect to a program $p$ if it exhibits none of the conditions of that long list.
\end{definition}

\begin{definition}
A chaperone is \emph{dischargeable} with respect to a program $p$ if it is well-behaved and all dependent chaperoned operators are dischargeable.
\end{definition}

\begin{definition}
A chaperone installation site is \emph{dischargeable} with respect to a program $p$ if all chaperones installed there are well-behaved and all dependent chaperone sites of chaperones installed there are dischargeable.
\end{definition}

\begin{theorem}
If a chaperone installment site labelled $\ell$ is dischargeable with respect to a program $p$, then $D_\ell$ is sound for $p$.
\end{theorem}

\begin{proof}
By induction on the reduction relation.
Suppose $p\rrs v$.
Then none of the chaperone guards (or any guard, for that matter) must raise an error.
Then there is nothing to worry about.
That is, $D_\ell(p)\rrs v$, where we make no distinction between an operator and a chaperone of it.

Suppose $p\Uparrow b$. 
Then an error must be raised while a chaperone (with $b$ derived from its label) is active.
Then that chaperone depends on the error.
Then that chaperone installment site will not be a candidate for deletion.
It is not dischargeable.
Then it's not labelled $\ell$.
Since this is true for every dependent non-dischargeable site (that it's not labelled $\ell$), then $D_\ell(p)\Uparrow b$.

Suppose $p\Uparrow$.
If the installation or application of a chaperone could cause divergence, it won't be dischargeable.
Then the chaperone site labelled $\ell$ must not cause divergence.
Then $D_\ell(p)\Uparrow$.
\end{proof}

\begin{definition}
A chaperoned operator is \emph{good0} with respect to a program $p$ if it does not raise a chaperone error.
\end{definition}

\begin{definition}
A chaperone installment site is soundly \emph{demotable} with respect to a program $p$ if it can be [demoted] and all chaperone installation sites of all chaperones it depends on are soundly demoted.
\end{definition}

\begin{lemma}
If a chaperone installment site labelled $\ell$ is demotable with respect to a program $p$, then $E_\ell$ will not introduce any errors in $p$.

That is,
\begin{itemize}
\item if $p\rrs v$, then $E_\ell(p)\not\Uparrow b$ for any $b$,
\item if $p\Uparrow b$, then $E_\ell(p)\not\Uparrow b'$ for $b\ne b'$, and
\item if $p\Uparrow$, then $E_\ell(p)\not\Uparrow b$ for any $b$.
\end{itemize}
\end{lemma}

\begin{proof}
Suppose $p\rrs v$.
Then no error is thrown in regular execution.
Because we will not demote a site unless there is no possibility that its result is used by a chaperone, demoting the site will not introduce an error.
Therefore, $E_\ell(p)\rrs v$ where we make no distinction between an operator and an impersonator of it.

\end{proof}

\begin{theorem}
If a chaperone installment site labelled $\ell$ is demotable with respect to a program $p$, then $E_\ell$ is sound for $p$.
\end{theorem}

\begin{proof}
Suppose $p\rrs v$.
Then no error is thrown in regular execution.
Because we will not demote a site unless there is no possibility that its result is used by a chaperone, demoting the site will not introduce an error.
Therefore, $E_\ell(p)\rrs v$ where we make no distinction between an operator and an impersonator of it.

Suppose $p\Uparrow b$.

\end{proof}

\section{Static Analysis}
We use two static analysis techniques in tandem to determine whether chaperone installment sites in \chapcalc\ programs are dischargeable or demotable.

We first perform an introspective pushdown analysis on \chapcalc\ programs.
The abstract semantics are fairly straightforward.
Structural abstraction proceeds component-wise, point-wise, etc.
Like Might (cite AAM), we must untie the recursive definition of chaperones and impersonators.
We don't need it for the operators themselves since they are atomic expressions, and so cannot refer to themselves.
We do it for the guard procedure by using the label of the site as the abstract address (or deriving it therefrom).

We can build up the dependence relation by looking at the stack frames possible at each point of error or construction in the program.
We determine construction points in the program by looking at value states (points of return) and examining the top frame at that point (to see if it's a chaperone construction frame).
We take the union over all the sets of frames dependent on errors.
We build the construction dependence relation also.
We can then determine whether any of the installment site labels are safe to remove.
But before that, we look at all operators that can flow to the guard of a chaperone.
We are interested in whether they can diverge or not.
With lambda terms, we look at whether they can diverge.
With chaperones or impersonators, we look at whether any of the constituent operators can diverge.
Primitives cannot diverge.

We could look more precisely at dependence and distinguish between positive and negative guards more.
We could find instances where the positive guard could be discharged with values. Then the negative guard could be discharged if the positive guard could be and it itself was well-behaved.
Then a chaperone or impersonator with a guard values can be discharged.
A chaperone installment site can discharge the positive guard if none of the positive guards of its constituents are relied on by errors.


%\begin{definition}
%A chaperoned operator is \emph{negative active} if evaluation is within the dynamic extent of its negative guard.
%\end{definition}

%\begin{definition}
%A chaperoned operator is \emph{positive active} if evaluation is within the dynamic extent of its positive guard.
%\end{definition}

\begin{definition}
A chaperoned operator is simply \emph{active} if evaluation is within the dynamic extent of one of its guards.
\end{definition}

\begin{definition}
A chaperone-installment site labelled $\ell_1$ is \emph{negative dependent} on a chaperone-installment site labelled $\ell_0$ if there is a program execution in which the $\ell_1$-site is visited while the youngest active chaperone is negative active and was installed at $\ell_0$.
\end{definition}

\begin{definition}
A chaperone-installment site labelled $\ell_1$ is \emph{positive dependent} on a chaperone-installment site labelled $\ell_0$ if there is a program execution in which the $\ell_1$-site is visited while the youngest active chaperone is positive active and was installed at $\ell_0$.
\end{definition}

A chaperone positive guard can be removed if causes no blame5,6 errors, no blame7 errors, and any positive-dependent chaperones can be discharged.

A chaperone negative guard can be removed if it cause

\begin{theorem}[Chaperone-Installment Site Discharge Theorem]
A chaperone-installment site can be discharged if, for all possible program executions, it does not cause an error, does not diverge, and all dependent chaperone sites can be discharged.
\end{theorem}

Call a chaperone $c$ well0 if its application does

Call a chaperone site $s$ with label $\ell$ well0 if, for any possible program execution, a resultant error is never blame0-ed on $\ell$.

Call a chap



\begin{definition}[Weak Chaperone-Installment Site Discharge Soundness]
We say a discharge transformation $D_\ell$ is sound when the conditions hold that
\begin{itemize}
\item if $p\rrs v$, then $D_\ell(p)\rrs v$, and
\item if $p\Uparrow b$, then $D_\ell(p)\Uparrow b$.
\end{itemize}
\end{definition}

The weak variant of the soundness theorem does not say anything about divergence. According to this definition, a transformation $D_\ell$ may be sound with respect to a program $p$ if $D_\ell(p)\rrs v$ or $D_\ell(p)\Uparrow b$ even when $p\Uparrow$.

Because the non-weak variant of soundness speaks on every type of program result, the conditions can be read as equivalences.

This makes 

Chaperone values are branded with the label of their creation site. In any given program, there are a finite number of these creation sites and labels. In fact, it is these creation sites that we are concerned with. The output of an analysis is a map from labels to transformations (no-op, promotion, discharge). Once we apply these transformations, we recover optimization opportunities as data dependency decreases.

We call a wrapper function $g$ an \emph{originator} of a chaperone $c_0$ if $c_0$ is created in within the extent of $g$. Chaperone values are also branded with their parent chaperon

Definition: call a creation site good0 if all of the chaperone values which flow from it are well-behaved.

%If the wrapper returns an additional result, its first result is a function (that may depend on input) that has argument and result arities of the result arities of the wrapped function.

\begin{theorem}[Selective Chaperone Discharge Theorem]
A good and nice chaperone installment site can soundly be replaced by its first argument (where ``soundly'' means ``with no change to the meaning of the program'').
\end{theorem}

%\begin{proof}
%The only way that a chaperone can change the meaning of a program is by causing an error, raising an error, or causing the creation of a chaperone with the same property.

%By definition, all chaperones which flow from a good and nice chaperone installment site are good and nice meaning that they do not cause an error, raise an error, or cause the creation of a chaperone with the same property.
%\end{proof}

% do (chaperone f negative positive) first
% and then deal with (chaperone f w)

%Because the result wrapper is produced at each invocation, it may depend on 



IPDCFA provides us with the chaperones which may be meaningful, but it does not provide us with which chaperone guards may diverge, either by evaluation of the guard itself or application of it.
To a first approximation, we can conservatively say that any non-atomic expression for the guard potentially diverges and cannot be safely removed from the program.
This strategy covers most of the cases in practice, since it is relatively rare to have a complicated expression in guard position---the more complicated the expression, the bigger the onus of justifying that the 

%This language is sufficient to express two theorems.

%Definition: Call an impersonator \emph{well-behaved} with respect to a program if its application never \scheme{raise}s.
%(only talking about arity and special runtime stuff here)

%Well-behavedness is defined with respect to a program--as opposed to assigning the property in isolation--because an impersonator may misbehave in situations never encountered within a particular program.

%In general, we cannot decide whether a particular impersonator--in context or isolation--has this property.

%Definition: Call a chaperone wrapping function \emph{well-behaved} with respect to a program if it only possibly installs chaperones on its arguments.

%Definition: Call a chaperone \emph{well-behaved} with respect to a program if its application never \scheme{raise}s.

%Definition: Call a chaperone \emph{satisfied} with respect to a program if it never \emph{raise}s and 

%Def: call a chaperone good0 wrt a program if it at most chaperones its arguments.
%Def: call a chaperone-installment site good0 wrt a program if all chaperones which flow from it are good0.
%Def: call a chaperone good1 wrt a program if it is good0 and its installing chaperone, if any, is good1.
%Def: call a chaperone-installment site good1 wrt a program if it is good0 and the chaperone-installment sites of its installing chaperones, if any, are good1.
%Thm: a good1 chaperone-installment site can be promoted to an impersonator-installment site if its installing chaperone site, if any, is promoted.


%if all chaperones which flow from a chaperone-installment site are good1, the installer can be promoted to an impersonator installer--all the chaperones which flow from it can be promoted to impersonators.

% I think the conditions above and below are (as written and in actuality) disjoint

%Def: call a chaperone good2 wrt a program if its application never raises a runtime (arity) error, its wrapper never raises.
%Def: call a chaperone good3 wrt a program if it is good2 and the chaperones it installed, if any, are good3.
%Thm: if all chaperones which flow from a chaperone-installment site are good3, that site can be replaced with its first argument (the until-now-wrapped value).

%This amounts to the possible arisal of two different types of errors: the first type is the violation of a contract assertion--in this case, blame is determined to fall on either the caller or the callee (the wrapped function itself); the second type is a misbehaving chaperone: it does not return the correct number of values or it does not only chaperone the arguments.

%define well-behaved impersonator and well-behaved chaperone
%define good chaperone
%chaperone erasure theorem
% basically, if a program reduces to a value with chaperones, then it should reduce to the same value with chaperones erased. this theorem was stated for a language without error recovery, so we may have to alter either our language or the theorem.
% also, this theorem says nothing about the program in general. we want to say that the erasure or promotion of specific chaperones will not change the meaning of the program. it may be that error recovery external to a chaperone extinguishes its violation transparently, but that is not the purpose of our analysis.

% the concrete interpreter correctly assigns blame but there is a problem:
% if the chaperone-operator is wrapped in a function, then it can only be changed if /all/ the uses of that function meet the requirements. it doesn't matter if the store is going to be garbage-collected--all the values are branded with its syntactic label.
% one thing we could do is attempt to distinguish calls into classes and divert all calls of a certain class to a different function. for instance, if a chaperone value as it goes around the program is well-behaved, can we look where it is created and change it in isolation somehow?

In the Racket implementation, the \scheme{chaperone-procedure} primitive is access most often through a wrapper function that handles keyword procedures.
Our static analysis determines the transformation of a \scheme{chaperone-procedure} application site to be sound only if no contract installed there will ever be blamed.
This means that the violation of a single contract installed there prevents the promotion or discharge of \emph{any} of the other contracts installed there.
In order for the analysis to be effective, we need more granularity.
We preprocess programs to inline certain definitions according to human judgement.

\subsection{Demotion soundness theorem}


% we aren't giving necessary conditions to discharge chaperones
% we are giving sufficient conditions
% there are chaperones that are dischargable but that don't meet our conditions.



We expect that a vast majority of impersonators and chaperones will be well-behaved in this sense, and only affect program behavior through one of the guards.
In particular, we expect that chaperone guards will at most chaperone their arguments.







If a chaperone 



Such chaperones of course need never be installed at run time.
We say we \emph{discharge} chaperones when we alter the program to remove their installment.
Chaperones which may influence program behavior cannot be discharged but may satisfy a weaker condition which allows them to be \emph{demoted} to impersonators, reducing the amount of run-time monitoring that must be dedicated to them.



% inline call sites to partition the chaperones created at each site
% show that all chaperones at a given creation site are safe
% these two work with each other
% look instead 

Depending on the class of errors which we can rule out statically, we can \emph{discharge} a chaperone which is to prevent it from ever being created.
However, we distinguish between the possible errors shared by chaperone and impersonator application and the error unique to chaperone application raised when a wrapper function does more than chaperone its arguments.
If a chaperone does not induce any of the latter type, and sundry other conditions are met, we should be able to \emph{demote} it to an impersonator.
This avoids the potentially expensive check that the wrapper results are chaperones of the arguments.
If a wrapper function never throws an error and none of the chaperones it creates ever throw errors, we can remove it.
We present a two soundness theorems:
The first soundness theorem provides the conditions whereupon a chaperone can be discharged.



%In contracts, one can talk about creation time--the time the contract value is created--projection time--the time the contract is attached to a value--and application time--the time that the contracted value is applied to its argument.
%These times are not contiguous and may overlap in the presence of dependent contracts.
%The evaluation time of the wrapper corresponds to creation time.
%The chaperone-operator form corresponds to the projection time.
%The application of the negative wrapper of the chaperoned value corresponds to application time.
%Within the application, the evaluation of the positive wrapper corresponds to creation time.
%At return, the application of the positive wrapper corresponds to application time.

We now explore the conditions under which a chaperone can be removed from the program.

Consider the installation of a chaperone on a first-order procedure by
\begin{schemedisplay}
(chaperone-operator
 (lambda (n) (+ n 1))
 (lambda (n)
    (if (integer? n)
        (values (lambda (n)
                  (if (integer? n)
                      n
                      (raise)))
                n)
        (raise))))
\end{schemedisplay}
Even without program context, we can make judgements strong enough to weaken this installation site.

First, observe that the positive guard (the first argument of the \scheme{values} call) neither guard installs a chaperone, either directly or indirectly.
Based on this and the fact that it is independent of the negative guard argument, arity-compatible with the result arity of the function, and type-compatible with the result of the function (which is to say that no resultant value of the function is sufficient to make the guard throw an error, and, finally, that it is an atomic expression and so must not diverge, we can remove it, transforming the installation expression to
\begin{schemedisplay}
(chaperone-operator
 (lambda (n) (+ n 1))
 (lambda (n)
    (if (integer? n)
        n
        (raise))))
\end{schemedisplay}
with no change in meaning to the program.

We now have two opportunities for optimization which have disparate conditions.
First, we can see that the remaining guard will never install a chaperone on one of its arguments as they are first-order values.
If, with respect to the program, the guard never raises an error, then it acts as the identity function\footnote{Specifically, it acts like \scheme{values}, the identity function for any number of values}.
With these two conditions met, we can replace the entire form with \scheme{(lambda (n) (+ n 1))}.

If our analysis cannot rule out the possibility of guard error arisal, we cannot soundly remove it.
We may be able to weaken the run-time monitoring necessary, however.
If we can establish that this chaperone installment site has no dependent chaperones, we can replace it with an \scheme{impersonate-operator} site.
In fact, this weakening is independent of the omission of the positive guard from the form.
In general, if all the chaperones which flow from an installment site at most chaperone their arguments, and the site itself has no dependent chaperones, it can be replaced with an equivalent \scheme{impersonate-procedure} site, regardless of the error or divergence behavior of the value at creation, projection, or application time.




We might surmise that this fact alone would allow us to transform this \scheme{chaperone-operator} form to an \scheme{impersonate-operator} form which would avoid the chaperone-specific monitoring at runtime.
Suppose, however, that this installment site appeared within the body of a procedure used as a chaperone guard.

Next, observe that the argument and results arity of the guards are completely compatible with the arity of the function.
In fact, the only possible way this chaperone would change the behavior of the program is by signalling an error when the argument or result is not 

If a chaperone never throws an error and all of the chaperone creation sites that depend on it can be discharged, it can be discharged.

If all of the chaperones created at a chaperone creation site can be discharged, the creation site can be discharged.

%possible side-effects
%error on creation (not same arity, not procedure arg0, not procedure arg1)
%divergence on arg1
%error thrown by args wrapper
%divergence on args wrapper (extra argument)
%divergence on args wrapper (otherwise)
%args wrapper returns wrong number of results
%extra result not an operator
%args wrapper results not chaperones of arguments
%ults wrapper doesn't accept number of results
%ults wrapper throws an error
%divergence on ults wrapper
%ults wrapper returns wrong number of results
%ults wrapper does not chaperone its arguments

\subsubsection{Impersonator errors}
\begin{enumerate}
\item error on creation (not same arity, not procedure arg0, not procedure arg1)
\item divergence on arg1
\item error thrown by args wrapper
\item divergence on args wrapper (extra argument)
\item divergence on args wrapper (otherwise)
\item args wrapper returns wrong number of results
\item extra result not an operator
\item ults wrapper doesn't accept number of results
\item ults wrapper throws an error
\item divergence on ults wrapper
\item ults wrapper returns wrong number of results
\end{enumerate}

\subsubsection{Chaperone-specific errors}
\begin{enumerate}
\item args wrapper results not chaperones of arguments
\item ults wrapper does not chaperone its arguments
\end{enumerate}

We can be more precise about the possible sources of side effects to reveal places to replace wrapper functions individually.

A positive guard can be discharged if the evaluation to its value converges, it always accepts the number of results of the function, it always returns the same number of results, its results are always chaperones of its arguments, it never raises an error (explicitly), it doesn't diverge, and all the chaperone creation sites that depend on it can be discharged.

A negative guard can be discharged (changed to values) if the evaluation to its value converges, it has the same arity of the function, it returns the correct number of arguments, its extra argument is a function, its results are always chaperones of its arguments, it doesn't divergence, all chaperone creation sites that depend on it can be discharged, and the positive guard it returns can be discharged.

% these conditions are stronger than necessary in the sense that the definition of dependence is not precise but a conservative approximation, and not every value that meets the precise condition would meet these stronger conditions, but it is easier to determine that these stronger conditions hold.

A chaperone can be discharged if its (negative) guard can be discharged.

A chaperone creation site can be discharged if all the chaperones it creates can be discharged.

We assume that any chaperone installed while a chaperone is active 

A chaperone can be demoted if the results of its positive and negative guard are only ever chaperones of the arguments (excepting the extra result for the negative guard), and all chaperone 

Our analysis calculates a conservative approximation of the dependence relation.

In addition, our analysis calculates a conservative approximation of the set of dependent chaperones.

We build a control flow graph.
At each control state, we can calulate a description of the possible stacks.
First, we consider control states where a chaperone is being created.
The set of possible stacks at each control state reveals the set of creation sites of chaperones upon which that creation site depends.
Next, we consider terminal error control states.
The set of possible stacks at each control state reveals the set of creation sites of chaperones that are responsible for the error.

\section{Limitations}

Our analysis applies equally well if we extend the language with more referentially transparent primitives or macro-expressible constructs such as \scheme{and} and \scheme{or} forms.
We can even add an error-catching facility but we must be careful in our analysis.

In Racket, \scheme{chaperone-procedure} is a primitive procedure--not a special form.
\scheme{app-values}

Chaperones are intended to be treated like the original value.
% box?, procedure?, etc. will respond the same way
% they evaluate equal? to the values they wrap, but not eq?
Procedure chaperones are considered to have the same arity of the procedures they wrap.
The \scheme{chaperone?} predicate is designated as the single way to detect chaperones at runtime, though its use is discouraged.


\section{Static Analysis}

% relation R
% a set S
% let S0 = S
% let Sn+1 = { x | xRy for some y in Sn } union S0
% let S' be the fixed point (the transitive closure)
% this is the same as the transitive closure of R projected on the right to S
% conjecture: 

% we have a control flow pushdown graph
% there are eval, apply, value, error, etc. states
% error states may be simple error states or "static" blame states
% regardless, consider all of the dependent chaperone frames
% if a creating chaperone site is discharged, the error may not occur
% if an active chaperone was never created, the error may not occur
% then we do a conservative divergence analysis of all lambdas which flow to guards
% if any of the lambdas which flow to the guards may diverge, we can't discharge that

% look for all static errors that signify arguments not being chaperoned
% those chaperones cannot be demoted to impersonators
% we might need a special "chaperone-just-created" state
% ok, that's simple enough

Call a chaperone first-order if it is chaperoning a first-order operator or if its guard constrains the argument to be first-order.
For instance, \scheme{(chaperone-operator add1 (LAMBDA (x) x))} creates a first-order chaperone because \scheme{add1}, defined as \scheme{(LAMBDA (x) (+ x 1))}, is first order.
On the other hand, the operator \scheme{(LAMBDA (x) x)} accepts higher-order arguments, but \scheme{(chaperone-operator (LAMBDA (x) x) integer/c)} creates a first-order operator.

In \chapcalc, a first-order chaperone cannot install chaperones on its arguments (as chaperones don't exist for simple values).

The pushdown control-flow analysis produces a finite graph of control states with edges labelled with symbols from the stack alphabet.

For each variant of continuation frame $\Gamma$, the stack alphabet contains the symbols $+\Gamma$ representing a \emph{push} of a $\Gamma$-frame and $-\Gamma$ representing a \emph{pop} of a $\Gamma$-frame.
The stack alphabet also contains the symbol $\epsilon$ which labels transitions between control states with no net stack change between them.

From the control graph, we can build a conservative approximation of the installed-by relation by considering states which are the target of a transition labelled $-\chak(f)\Gamma_{chap}(\ell,f)$.
At each of these states, we calculate a conservative set of labels of the youngest active chaperones at that control point.



We seed a set with the labels of qualifying errors (ones that directly disqualify a site from being removed)
and apply the relation to the set to build a transitive closure of it.
These sites cannot be removed.

We look for the special class of errors that occur when a guard does not chaperone its arguments.
We find all of the chaperone sites it installs and the transitive closure of it.
These sites cannot be demoted.

A particular program expression may appear where the 

Our concrete semantics brands each chaperone value at creation time with the label of its creation site and the label of the creation site of the chaperone in which dynamic extent of the application takes place using stack inspection. This makes access to the stack critical in our analysis.

Introspective pushdown control-flow analysis admits a description of possible stacks at a given program point with regular expressions. We include as parents all possible labels of guards. Thus, the abstraction of the parent label becomes a set of labels.

% but wait! how are the possible stacks affected by garbage collection?
% if a function cannot be invoked at a site, then its stack will not be the base
% for inner calls within that function.

% what I'm saying is:
% I have a chaperone that calls -> (a chaperone installer) in its negative guard.
% sometime later in the program, I have another chaperone that also calls -> in its negative guard.
% PDCFA determines that both stacks are possible?

Introspective pushdown control-flow analysis (IPDCFA) can provide a conservative approximation of possible stacks at each program point described with regular expressions. Then, we look at states with expressions \scheme{(chaperone-procedure f neg-wrap pos-wrap)} and the possible stacks at those particular states. If any of the stacks contain a chaperone activation frame, we conservatively assume that all chaperones created at this program point are children of that chaperone. Because we have a conservative approximation of possible stacks, it may be that multiple activation frames may be relevant (either through alternation or nested where it is absent in one branch). We assign all of the chaperone values as parents to chaperones created at this site, and, when we make our judgments, must ensure that the properties hold for all to discharge them.

We perform a pushdown control-

The set of possible sequences of stack frames at a particular program point is a regular language.
An introspective pushdown control-flow analysis provides us with a regular expression encoding this language.
A string in the language is a sequence of frames ordered from oldest to youngest.

We are interested in chaperone activation frames, a subset of all possible frames, and so a subset of the stack alphabet.
In particular, we are interested in the subset of youngest such frames.
Consider the set of strings--stack sequences--that comprise the language.
Filter the characters in each string so that only characters from the set of interest appear.
Disregard the empty string (and any strings that were fully-consumed by the filtering process).
Consider the set of all final characters in the remaining strings.
Each character in the set represents a chaperone activation frame, and is branded with the label of the active chaperone's creation site.
Thus, this set represents the possible creation sites of active chaperones.

We can perform the same operation on a regular expression by introducing a distinguished character $\bullet$ which represents a sequence of characters that have been filtered away.

Given a regular expression (either a character, a concatenation, a union, or a Kleene star), define $f:RE \longrightarrow RE$ as follows
$f(\bullet)=\bullet$

$f(c)=c$

$f(\bullet\cdot L_1)=L_1$

$f(L_0\cdot\bullet)=L_0$

$f(L_0\cdot L_1)=e\cdot L_1$

$f(\bullet^*)=\bullet$

$f(L_0^*)=L_0^*$

$f(\bullet\cup L_1)=L_1$

$f(L_0\cup\bullet)=L_0$

$f(L_0\cup L_1)=L_0\cup L_1$

Because $f$ ``absorbs'' holes, a hole will only occur if the entire language is replaced by the language that contains only the empty string.
We define $h$ to obtain the set of stack frames by the following:
$h(\bullet)=\emptyset$

$h(c)=\{c\}$

$h(L_0\cdot L_1)=h(L_0)\cup h(L_1)$ if $L_1$ is nullable; $h(L_1)$ otherwise.

$h(L_0\cup L_1)=h(L_0)\cup h(L_1)$

$h(L^*)=h(L)$

$g$ (the replacement function) is homomorphic in the regular combinators. 

%\section{Chaperone Erasure Theorem}

%If a well-behaved program (meaning a program in which chaperoning procedures do not cause side effects and chaperone application does not cause side effects) evaluates to v, then a program without the chaperones will evaluate to the same value.

%Selective chaperone erasure theorem: if none of the values that flow from a call site $c$ throw any exceptions and none of the chaperones installed by its wrappers throw exceptions, the chaperone can be erased (the call site (chaperone-operator f w) can be replaced with f) with no change in the meaning of the program.

%Proof by induction:
%It holds for any reduction rule which does not involve chaperones by the induction hypothesis.

%Consider the call site \scheme{(chaperone-operator f w)}. If none of the values which flow from this call site raise an exception, then we can substitute it with \scheme{f}.

%Call a chaperone \emph{well-behaved} if its application within a program never induces a type B error.

%Call a chaperone-installment site (chaperone-operator f w) good if all the values which f

%Call a chaperone good if it is well-behaved and its installing chaperone, if any, is also good.

%Chaperone promotion theorem: a good chaperone can be promoted to an impersonator. That is, if all the values that flow from a call site (chaperone-operator f w) are good, the replacement of its call site (chaperone-operator f w) to (impersonate-operator f w) as well as the the replacement of its installing chaperone will not change the meaning of the program. (All the values that flow from its call site must be well-behaved

%It is critical that the property hold transitively for the installing chaperones. If not, a chaperone could install an impersonator where it originally installed a chaperone, which would would result in an error that wasn't there before.

%fine-grained chaperone erasure theorem
%fine-grained chaperone promotion theorem
%introduce a flow analysis which can make judgements which satisfy the conditions of the theorem built on introspective pushdown systems.
%compare the performance of programs which have been analyzed
% it is not necessary that the tool automatically rewrite the program according to the theorem--only that it performs the analysis and perhaps makes the judgments for its application

conclusion describing limitations and intended direction


\section{Chaperone Discharge}

%We say a chaperoning function is \emph{well-behaved} if it only results in chaperones of its arguments.
%We say a chaperoning function \emph{f} is \emph{benign} for a particular set of values \emph{V} if it 
%exhibits no side effects when its arguments are contained in \emph{V}. [Think about side channels as 
%side effects a la the original impersonators paper. Also, we might want to consider V and chaperones of
%the elements of V.]

%Because chaperone invariants are enforced dynamically, chaperones incur a runtime cost above impersonators. 
%If, for a particular program, a chaperone is well-behaved, it can be replaced with an impersonator (which 
%does not enforce argument equality) (but must be customized to return chaperoned arguments, etc. As we prove facts about inner values and their ultimate flow, we can make more powerful judgements about the chaperones that wrapped them to begin with.).

%Because the contract system is implemented with chaperones, many chaperones perform no side-effects other than 
%a blame 

\section{Static Analysis}

Introspective pushdown control-flow analysis (IPDCFA) was developed to allow abstract garbage collection to apply to the standard pushdown control-flow analysis.
By transforming a pushdown system to a Dyck state graph, we obtain a finite graph of control states and a finite desciption of the possible stacks at that program point.
This provided a root set from which abstract garbage collection could work.

It also opened the door for static analysis of programming languages that require--or can be put in terms of--stack inspection.
Our analysis of chaperones requires that we determine the source label of all created chaperones and the source label of the chaperone which created it.
Essentially, we need to know the 

\section{Limitations}

\scheme{app-values} increases the expressiveness of the language.
(We do not have to specify the number of arguments to a function statically.)
The structure of a list is recursive.
We can untie the recursive definition by directing through the store; we took this approach with environments.
We could look into this, but that means the length of the list could vary.
That could \emph{really} destroy precision, but we need to investigate it further.

\emph{rest values} increase the expressiveness of the language. They are very related to \scheme{app-values}.
\scheme{chaperone-operator} as a primitive (as opposed to a form) increases the expressiveness of the language.

\section{Conclusion}

Interposition primitives exist for more than functions in Racket: boxes, vectors, hash tables, continuation mark keys, etc.

We omitted from \chapcalc a few primitives that exist in Racket that must be accounted for by our analysis.
A call \scheme{(chaperone-of? f g)} determines whether \scheme{f} is \scheme{equal?} to \scheme{g} modulo chaperones.
In other words, it determines whether \scheme{f} could be constructed from the parts of \scheme{g} and some chaperone installation.
This primitive presents no problem for chaperone discharge as \scheme{(chaperone-of? f f)} always evaluates to \scheme{#t}.
However, if a chaperone has been promoted to an impersonator and flows to the first argument position, the meaning of the program is changed, making the promotion unsound.
If chaperone values that both otherwise can and cannot be promoted flow to this position, we cannot promote the chaperones.
If only promoted or discharged chaperones flow to it, we can replace it with the corresponding \scheme{impersonator-of?} call.

We also must contend with the \scheme{chaperone?} and \scheme{impersonator?} predicates. We can apply similar reasoning to integrate them into our original analysis.
Given that Racket programmers are discouraged from using them, we don't expect them to regularly upend our analysis, but of course we must account for them.


\appendix
\section{Appendix Title}

This is the text of the appendix, if you need one.

\acks

Acknowledgments, if needed.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{paper}


% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright

%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...

%\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

