\documentclass{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% authoryear    To obtain author/year citation style instead of numeric.

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{slatex}

\mathchardef\mhyphen="2D
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{PLDI '14}{Month d--d, 2014, Edinburgh, Scotland} 
\copyrightyear{2014} 
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

%\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{banner above paper title}        % These are ignored unless
\preprintfooter{short description of paper}   % 'preprint' option specified.

\title{Static Discharge and Demotion of Low-Level, Higher-Order Contracts}
%\subtitle{Subtitle Text, if any}

\authorinfo{Kimball Germane\and Matthew Might}
           {University of Utah}

\begin{document}

\newcommand{\chapcalc}[0]{\ensuremath{\lambda_{\mathcal{C}}}}

% TODO:
% format everything
% revisit factorial at the end
% visit church encoded factorial
% visit the impact of domains
% motivate need for termination analysis
% figure out a way to present it as product and not sum of contributions
% take out Y combinator and church factorial fluff
% write related work section
% WRITE BETTER ABSTRACT
% 


\maketitle

\begin{abstract}
Dynamic contract checks---especially for higher-order values---take time and space to perform.
In practice, the cost of these checks can dominate the run-time cost of the executing the program.
It is therefore desirable to discharge them statically where possible.
However, implementation realities may mandate a shift in perspective as the view of contracts at low levels may vary drastically.
We focus on demodularized Racket programs in which dynamic procedure contracts are expressed in terms of higher-order interposition and present an analysis for whole programs to statically detect and discharge benign contracts.
Utilizing a combination of introspective pushdown control-flow analysis and termination analysis, we demonstrate cases in which our analysis significantly decreases the run-time burden of specification enforcement.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore, 
% you may leave them out
%\terms
%term1, term2

%\keywords
%keyword1, keyword2

%\cite{siek2009exploring}
%\cite{wadler2009well}

% behavioral contracts
% monitoring
% projection
% discharge
% demotion or promotion
% compliance
% chaperone vs. chaperoned operator
% 

\setspecialsymbol{->}{$\rightarrow$}

\setspecialsymbol{LAMBDA0}{$\lambda_0$}
\setspecialsymbol{LAMBDA1}{$\lambda_1$}
\setspecialsymbol{LAMBDA2}{$\lambda_2$}

\setspecialsymbol{LAMBDA}{$\lambda$}
\setspecialsymbol{GE}{$\ge$}
\setspecialsymbol{EPS}{$\epsilon$}

\setkeyword{define/contract}

\section{Introduction}

% what is the problem?
Higher-order behavioral contracts can take inordinate time and space to enforce.

%\newcommand{\mllam}[3]{\lambda #1:\mathtt{#2}.\,#3}
%\newcommand{\mlif}[3]{\mathtt{if}\,#1\,\mathtt{then}\,#2\,\mathtt{else}\,#3}

%Consider, for instance, the program
%\[
%\mathtt{even?}=\mllam{n}{Int}{\mlif{n=0}{\mathtt{true}}{5}}\\
%\lambda n:\mathtt{Int}.if n=0 then true else odd? (n - 1)\\
%even?=\lambda n:Int.if n=0 then true else odd? (n - 1)
%\]
%But we expect many contract projections to be benign.

Consider, for instance, the program
\begin{schemedisplay}
(define/contract (fact n a)
  (nonnegative-integer/c positive-integer/c . -> . positive-integer/c)
  (if (= n 0)
      a
      (fact (- n 1) (* n a))))
\end{schemedisplay}
which attaches dynamic domain and range contracts to the tail-recursive factorial.
This contracted procedure behaves as if it were written
\begin{schemedisplay}
(define (fact n a)
  (positive-integer/c
   ((LAMBDA (n a)
      (if (= n 0)
          a
          (fact (- n 1) (* n a))))
    (nonnegative-integer/c n)
    (positive-integer/c a))))
\end{schemedisplay}
where \scheme{positive-integer/c} and \scheme{nonnegative-integer/c} are procedures which raise an error if their argument does not belong to the domain reflected by the procedure's name.
Written in this way, it is apparent that \scheme{fac} is not tail-recursive.
Instead, the context grows with every recursive call so that \scheme{(fact 6 1)} reduces as
\begin{schemedisplay}
(fact 6 1)
(positive-integer/c (fact 5 6))
(positive-integer/c (positive-integer/c (fact 4 30)))
...
(positive-integer/c ... (positive-integer/c (fact 0 720)))
(positive-integer/c ... (positive-integer/c 720))
\end{schemedisplay}
whence the result will be validated six times---and \scheme{n} times for \scheme{(fact n 1)}.
The attachment of these contracts has transformed a constant-space algorithm into a linear-space one and, while the time complexity hasn't suffered asymptotically, the accumulated checks represent a real (and, in this case, unnecessary) cost.
Thus, a simple contract ascription can upset our performance expectations for even simple procedures.

As contract specifications become more elaborate, they become more susceptible to error.
In contract systems, such as Racket's~\cite{plt-tr1}, which allow arbitrary predicate procedures written in the source language itself to serve as specifications, this error is effected by the programmer.
It is only natural, then, to contract these procedures as well, an act which aides error diagnosis but compounds the run-time cost of contracts.
In these systems, execution time of the program proper can be dwarfed by that of the enforcement of its specification (in one case accounting for 96\% of total execution time) \cite{strickland2012chaperones}.

The moderation of these costs has been studied extensively.
Herman et al.~\cite{herman2010space} observed the potential accumulation of casts in the blame calculus---similar in principle to the accumulation of guards by our contracted \scheme{fact} procedure---and applied the coercion calculus of Henglein~\cite{henglein1994dynamic} to compact them.
Siek and Wadler~\cite{siek2010threesomes} consider the same problem and apply their own solution of \emph{threesomes}.
Siek et al.~\cite{siek2006gradual} explicate type systems which allow \emph{gradual typing} in which they provide a low-cost path from dynamically- to statically-checked invariants.
Flanagan and Knowles~\cite{flanagan2006hybrid} introduce \emph{hybrid type checking} in which static analysis is used to establish contract compliance statically where possible and insert dynamic checks where not.
%Using this final approach, a disciplined programmer enjoys the early safety guarantees and performance characteristics of statically-verified code or suffers the cost of belated error detection of dynamically-checked specifications.

Unfortunately, modular development can impede these analyses because the greatest amount of knowledge a module can have about its imports \emph{is} their behavioral contract.\footnote{Indeed, it can be less than this, as when the behavioral specification is not codified entirely within the program.}
For example, recognizing that contracts constitute total formal knowledge, Tobin-Hochstadt and Van Horn \cite{tobin2012higher} conduct an intra-module analysis which identifies extra-module references with opaque values that satisfy their contract.
% also, contracts are attached to values that flow across module boundaries.
Nevertheless, static analyses typically perform best when given whole programs.
For instance, the whole-program ML compiler MLton \cite{weeks2006whole} is able to perform thorough inter-procedural and inter-modular analysis and effect significant program optimizations.
We similarly expect the establishment of certain properties to become more accessible as code knowledge increases.
%We expect the emergence of the possibility of more properties being proved about the code as more knowledge about it becomes available.

We turn our attention to whole-program analysis of Racket \cite{plt-tr1}, a higher-order, dynamically-typed language, for the purpose of reducing the run-time burden of contracts.
Racket programs are organized into modules which consist of import and export declarations, definitions, and expressions.
Because Racket has rich facilities for syntactic extension, execution of code must be carefully controlled, especially since modules can be compiled separately \cite{flatt2002composable}.
Therefore, the quickest way to a whole program is by \emph{demodularizing} pre-compiled modules into a whole program in the Racket bytecode language (which, contrary to its name, is a fairly rich higher-order language).
At this level, contracts are manifest in terms of \emph{interposition} primitives.

Recent advances in higher-order program analysis \cite{earl2012introspective} provide perfectly precise return flow and allow the form of the stack to be approximated at each control point in the program.
The original purpose of this approximation was to provide an abstract garbage collector a conservative set of live frames.
We repurpose this capability to analyze a notion of dependence similar to that of Might and Prabhu~\cite{might2009interprocedural} allowing us to judge the safe removal of dynamic contracts \emph{even when the installation of other contracts depends on them}.
The expressiveness of Racket's contract language admits dynamic checks which diverge, so we must integrate a termination analysis based on Sereni's~\cite{sereni2007termination} that informs the discharge of dependently-installed contracts.

We proceed as follows:
We discuss interposition and its relationship to behavioral contracts in more depth in Section 2.
We introduce the syntax and semantics of \chapcalc, a core calculus with facilities for interposing higher-order values, in Section 3.
We present two theorems which establish the conditions for the safe removal or weakening of interposition in Section 4.
We present a static analysis which can judge when these conditions hold in Section 5.
We discuss the influence of parameters of the analysis on precision and performance in Section 6.
We discuss some Racket language features which require more care to integrate with the present analysis in Section 7.
We conclude by discussing the future application and direction of this work in Section 8.


\section{Interposition}

The implementation of familiar language features is sometimes accomplished through alien constructs.
In point of fact, behavioral contracts in Racket are manifest at run time by means of two interposition primitives: \emph{impersonators} and \emph{chaperones}.

An impersonator wraps a value and intercepts operations on it, potentially redirecting the operations arbitrarily.
In the case of higher-order values such as procedures, impersonators intercept arguments and can alter or replace them before passing them to the procedure they wrap.

For instance, the expression
\begin{schemedisplay}
(impersonate-procedure (LAMBDA1 (x) (+ x 2)) (LAMBDA0 (x) (+ x 1)))
\end{schemedisplay}
creates a \emph{procedure impersonator value} which, when applied to a single argument, first applies the \scheme{LAMBDA0} closure (the \emph{impersonating} procedure) to that argument and applies the \scheme{LAMBDA1} closure (the \emph{impersonated} procedure) to the result.
The net effect of applying this impersonator value, then, is to add three to the argument.

The impersonating procedure \scheme{LAMBDA0} can include a procedure value in addition to its results which will be applied to the results of application of the impersonated procedure \scheme{LAMBDA1}.
Modifying our previous example, the expression
\begin{schemedisplay}
(impersonate-procedure (LAMBDA1 (x) (+ x 2))
                       (LAMBDA0 (x) (values (LAMBDA2 (x) (+ x 3)) (+ x 1))))
\end{schemedisplay}
creates a procedure impersonator value which behaves identically to the first example up to the return of the impersonated procedure, at which point the \scheme{LAMBDA2} closure is applied to its result.
Operationally, applying the resultant procedure impersonator to an argument \scheme{y} is the same as \scheme{((LAMBDA2 (x) (+ x 3)) ((LAMBDA1 (x) (+ x 2)) ((LAMBDA0 (x) (+ x 1)) y)))}.
%The net effect of applying this impersonator value is to add six---not three---to the argument.

We will often refer to the impersonating procedure as the \emph{negative guard} as an error raised by it is construed as blaming the negative position (meaning that the context failed to satisfy the domain contract of the procedure); we refer to the additional value returned by the negative guard as the \emph{positive guard} for the same reason.
In cases where a positive guard is provided, the wrapper analogy is apt as values must pass through an impersonator barrier at both entry to and exit from the procedure.

Chaperones refine impersonators by trading behavioral freedom for reasonability~\cite{strickland2012chaperones}.
Well-behaved procedure chaperones cannot alter intercepted arguments arbitrarily; they may only install chaperones on them.
Chaperones share the ability of impersonators to perform side-effects.
In particular, they retain the ability to raise exceptions, the mechanism by which contract violations are signalled.

As an example of a realistic use of a chaperone, consider the factorial procedure for which a chaperone dynamically enforces the type of its argument and result\footnote{Of course, even without a chaperone, applying the factorial procedure to a non-numeric argument will provoke an error, but to a negative or non-integer, numeric argument will diverge. The chaperone here addresses both cases: it causes blame to be assigned at the procedure level, and encodes the specification sufficiently to avoid divergence.} expressed as
\begin{schemedisplay}
(chaperone-procedure
 (letrec ([fact (LAMBDA (n)
                  (if (= n 0)
                      1
                      (* n (fact (- n 1)))))])
   fact)
 (LAMBDA (n)
   (if (and (integer? n) (GE n 0))
       (values (LAMBDA (n)
                 (if (and (integer? n) (GE n 1))
                     n
                     (raise result error ...)))
               n)
       (raise argument error ...))))
\end{schemedisplay}
The chaperoning procedure is only shallowly installed in that only the initial argument and final result of a factorial application are scrutinized.
This is consistent with the way that chaperones are employed by the contract system: chaperones are attached to values typically only as they pass through module boundaries, and rarely to track intra-module blame.

Finally, we illustrate the rationale of a protocol in which the negative guard produces the positive guard instead of the user providing it to \scheme{chaperone-prodedure} directly.
Consider the installation of a chaperone on the square root function, \scheme{sqrt}, given by
\begin{schemedisplay}
(chaperone-procedure
 sqrt
 (LAMBDA (x)
   (if (and (real? x) (GE x 0))
       (values (LAMBDA (y)
                 (if (and (real? x) (< (abs (- (* y y) x)) EPS))
                     y
                     (raise positive error ...)))
               x)
       (raise negative error ...))))
\end{schemedisplay}
wherein the chaperoning procedure not only refines the domain contract of \scheme{sqrt} (from \scheme{number?} to non-negative \scheme{real?}) but checks its result against a correctness constraint.
In general, allowing the positive guard to be lexically embedded in the negative guard gives the former access to the arguments of the latter which, in turn, allows richer specifications to be expressed, such as dependent contracts \cite{findler2002contracts}.

\subsection{Run-time cost of impersonators and chaperones}

\subsection{Mapping from contracts to impersonators}



We can put the phases of creation, projection, and application of the contract lifecycle in correspondence with components of the impersonating lifecycle.

The contracted tail-recursive factorial procedure expressed as a chaperone is
\begin{schemedisplay}
(define fact (chaperone-procedure
             (LAMBDA (n a)
               (if (= n 0)
                   a
                   (fact (- n 1) (* n a))))
             (LAMBDA (n a)
               (if (and (nonnegative-integer? a)
                        (positive-integer? a))
                   (values (LAMBDA (a)
                             (if (positive-integer? a)
                                 a
                                 (raise positive blame ...)))
                           n a)
                   (raise negative blame ...)))))
\end{schemedisplay}

The creation time of a contract corresponds with the evaluation of the negative guard procedure expression (typically at installment time) and the positive guard procedure expression (at application time).
In the vast majority of cases, these guard expressions are simple $\lambda$-terms so their contribution to the overall cost of interposition is negligible.

The projection time of a contract corresponds with the installation of an impersonator on a procedure.
This is essentially an atomic operation.

The bulk of the run-time cost of interposition is accrued at application time which corresponds exactly to that of a contract.
The cost incurred is due to enforcement of the interposition protocol.
This entails that
\begin{itemize}
\item negative guards must return the same number of values as given (except for an optional positive guard);
\item the positive guard, if provided, must be a procedure;
\item the positive guard must accept the number of results produced by the impersonated procedure;
\item the positive guard must produce the same number of results as arguments given to it;
\end{itemize}
and, for chaperoning interposition,
\begin{itemize}
\item the negative guard must return only its arguments or chaperoned versions of them; and
\item the positive guard must do likewise.
\end{itemize}

Thus, we would prefer to remove all application costs due to interposition, but will accept merely removing the costs specific to chaperoning.

\section{Chaperone Calculus}

In order to explicate a static analysis of higher-order interposition, we define \chapcalc, or \emph{chaperone calculus}, an extension of the A-normalized $\lambda$-calculus with interposition facilities.

As only a moderate extension of the $\lambda$-calculus, \chapcalc\ lacks many Racket features, not the least of which is mutation.

%We will see, in addition, that counterparts to both \scheme{impersonate-procedure} and \scheme{chaperone-procedure} exist as tags of syntactic forms instead of first-class values as in Racket.
%Providing them as first-class entities would increase the expressive power [cite Felleisen] of \chapcalc\ and, in general, require a more powerful analysis.
%In practice, \scheme{impersonate-procedure} and \scheme{chaperone-procedure} are most often referenced directly by name and so treated more as syntactic tags.
%We will treat their \chapcalc\ counterparts as such specifically to simplify the presentation of the analysis, but discuss a strategy to integrate first-class uses of them in Section ?.
%In the actual analysis, we consider all call sites and add a condition for the sound discharge of a call site that \scheme{chaperone-operator} is the only values to flow to the operator position.

\subsection{\chapcalc\ Syntax}

The syntax of \chapcalc\ can be seen in figure \ref{fig:syntax}.

\chapcalc\ inherits application, abstraction, and variable terms from the $\lambda$-calculus.
It includes simple values from the domain of integers and booleans as well as a set of first-class primitive procedures which operate over these values.

The syntactic class \ae signifies \emph{atomic expressions} and includes $\lambda$-terms, variables, and the simple values of booleans, integers, and primitive procedures, which include \scheme{impersonate-operator} and \scheme{chaperone-operator}.
Expressions classified as such will never produce an error or diverge.

The syntactic class $c$ denotes procedure application sites which are formed by an atomic operator expression followed by a sequence of atomic operand expressions.

The syntatic class of expressions, denoted $e$, includes \scheme{let}, and \scheme{if} expressions.

Every term is annotated with a unique label $\ell$ to keep otherwise identical terms distinguishable, but labels will be made explicit only for application sites.


%The second subform of a \scheme{chaperone-operator} or \scheme{impersonate-operator} remains a proper expression to facilitate some of the blame semantics.

\newcommand{\vx}[0]{\mathbf{x}}

\newcommand{\appe}[2]{(#1\,#2)^\ell}
\newcommand{\lame}[2]{(\lambda\,(#1)\,#2)}
\newcommand{\chae}[2]{(\mathit{chaperone\mhyphen operator}\,#1\,#2)^\ell}
\newcommand{\impe}[2]{(\mathit{impersonate\mhyphen operator}\,#1\,#2)}
\newcommand{\lete}[3]{(\mathbf{let}\,((#1)\,#2)\,#3)}
\newcommand{\ife}[3]{(\mathbf{if}\,#1\,#2\,#3)}

\newcommand{\ande}[2]{(\mathrm{and}\,#1\,#2)}
\newcommand{\ore}[2]{(\mathrm{or}\,#1\,#2)}

\newcommand{\true}[0]{\mathrm{\#t}}
\newcommand{\false}[0]{\mathrm{\#f}}
\setlength{\tabcolsep}{1pt}
\begin{figure}
\label{fig:syntax}
%\begin{tabular}{rcl}
%c & = & $\appe{e}{e\,\dots}$ & application\\
%\end{tabular}

\newcommand{\stxclass}[4]{$#1\in\mathbf{#2}$ &::=& #3 & #4}
\newcommand{\stxclasscont}[2]{&$|$& #1 & #2}

%\begin{align*}
% \expr \in \syn{Exp} &\produces \letiform{\vv}{\call}{\expr} && \text{[non-tail call]}
% \\
% &\;\;\opor\;\; \call && \text{[tail call]}
% \\
% &\;\;\opor\;\; \aexpr && \text{[return]}
% \\
% \fexpr,\aexpr \in \syn{Atom} &\produces \vv \opor \lam && \text{[atomic expressions]}
% \\
% \lam \in \syn{Lam} &\produces \lamform{\vv}{\expr} && \text{[lambda terms]}
% \\
% \call \in \syn{Call} &\produces \appform{\fexpr}{\aexpr} && \text{[applications]}
% \\
% \vv \in \syn{Var} &\text{ is a set of identifiers} && \text{[variables]}
% \text.
%\end{align*}

\begin{tabular}{ r r l l }
\stxclass{c}{Call}{\scheme|(ae ae ...)|$^\ell$}{application}\\
\stxclass{e}{Exp}{\scheme|(let ((x ...) c) e)|}{let}\\
\stxclasscont{\scheme|(if ae e e)|}{if}\\
\stxclasscont{\scheme|ae|}{}\\
\stxclass{\mathit{ae}}{AExp}{$\mathit{lam}$ $|$ $p$ $|$ $x$ $|$ $i$ $|$ $b$}{atomic expressions}\\
\stxclass{\mathit{lam}}{Lam}{\scheme|(LAMBDA (x ...) e)|}{lambda terms}\\
\stxclass{p}{Prim}{\scheme|impersonate-operator| $|$ \scheme|<| $|$ \scheme|>| $|$ \scheme|=| $|$ \scheme|+| $|$ \scheme|-|}{primitives}\\
\stxclasscont{\scheme|chaperone-operator| $|$ \scheme|values| $|$ \scheme|raise|}{}\\
\stxclasscont{\scheme|not| $|$ \scheme|operator?| $|$ \scheme|integer?| $|$ \scheme|boolean?|}{}\\
\stxclass{x}{Var}{an infinite set of variables}{}\\
\stxclass{i}{Int}{$0\,|\,1\,|\,-1\,|\,2\,|\,-2\,|\,\dots$}{integers}\\
\stxclass{b}{Bool}{$\#t\,|\,\#f$}{booleans}
\end{tabular}

\caption{The syntax of \chapcalc.}
\end{figure}

A program is a term in the grammar with no free variables and in which all identifiers in the same binding form are pairwise distinct.




% results are:
% values: closures, chaperones, impersonators, primitives, integers, booleans
% errors: error, blame L, blame +L, blame -L

% (e e1 ... en),\rho,\sigma,\kappas
% v = A(e,\rho,\sigma), vi = A(ei,\rho,\sigma)
% case v
%   ((lambda s e'),\rho')
%   if s compatible with n
%     (e',\rho'',\sigma',\kappas) where \rho'' and \sigma' bind vis according to s
%     error
%   primitive
%   if primitive arity compatible with n
%     \delta(primitive,v1,...,vn)
%     error
%   (chaperone L f neg pos)
%   (lambda vs
%     (let ([vs' (app-values neg vs)])
%       (if (= (length vs)
%              (length vs'))
%           (if (and-map chaperone-of? vs' vs)
%               (let ([rs' (app-values f vs')])
%                 (if (arity-comp? pos rs')
%                     (let ([rs (app-values pos rs')])
%                       (if (= (length rs')
%                              (length rs))
%                           (if (and-map chaperone-of? rs rs')
%                               (app-values values rs)
%                               (error)) (blame + guard)
%                           (error))) (blame + guard)
%                     (error))) (blame + guard)
%               (error)) (blame - guard)
%           (error)))) (blame - guard)

\newcommand{\A}[3]{\mathcal{A}(#1,#2,#3)}

\newcommand{\dynbla}[1]{\mathrm{dynamic\mhyphen blame}(#1)}

\newcommand{\ks}[0]{\langle\gamma_1,\dots,\gamma_n\rangle}
\newcommand{\vv}[0]{\mathbf{v}}
\newcommand{\vvp}[0]{\mathbf{v'}}
\newcommand{\sexp}[4]{\mathbf{eval}(#1,#2,#3,#4)}
\newcommand{\sval}[3]{\mathbf{value}(#1,#2,#3)}
\newcommand{\sapp}[4]{\mathbf{apply}(#1,#2,\ell,#3,#4)}
\newcommand{\scha}[6]{\Sigma_d(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdimpz}[6]{\mathbf{imp_0}(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdimpo}[5]{\mathbf{imp_1}(#1,#2,#3,#4,#5)}
\newcommand{\sdchaz}[6]{\mathbf{chap_0}(#1,#2,#3,#4,#5,#6)}
\newcommand{\sdchao}[5]{\mathbf{chap_1}(#1,#2,#3,#4,#5)}
\newcommand{\serr}[3]{\mathbf{error}(#1,#2,#3)}
\newcommand{\sbla}[2]{\mathrm{blame}_{#1}(#2)}
\newcommand{\app}[4]{\mathrm{apply}(#1,#2,#3,#4)}
\newcommand{\red}[2]{\begin{align*}& #1\\\rr\, & #2\end{align*}}

\newcommand{\bind}[4]{\mathrm{bind}(#1,#2,#3,#4)}

\newcommand{\clo}[2]{(#1,#2)}
\newcommand{\cha}[2]{\mathrm{chaperone}(\ell,#1,#2)}
\newcommand{\imp}[2]{\mathrm{impersonator}(#1,#2)}

\newcommand{\chak}[1]{\mathrm{chap}_\kappa(\ell,#1)}
\newcommand{\chacwk}[2]{\mathrm{chap\mhyphen neg\mhyphen ults}_\kappa(\ell,#1,#2)}
\newcommand{\chacfk}[1]{\mathrm{chap\mhyphen fun\mhyphen ults}_\kappa(\ell,#1)}
\newcommand{\chacrk}[1]{\mathrm{chap\mhyphen pos\mhyphen ults}_\kappa(\ell,#1)}

\newcommand{\impk}[1]{\mathrm{imp}_\kappa(\ell,#1)}
\newcommand{\impcwk}[2]{\mathrm{imp\mhyphen neg\mhyphen ults}_\kappa(\ell,#1,#2)}
\newcommand{\impcfk}[1]{\mathrm{imp\mhyphen fun\mhyphen ults}_\kappa(\ell,#1)}
\newcommand{\impcrk}[1]{\mathrm{imp\mhyphen pos\mhyphen ults}_\kappa(\ell,#1)}


\newcommand{\letk}[3]{\mathrm{let}_\kappa(#1,#2,#3)}


\newcommand{\rr}{\longrightarrow}
\newcommand{\rrs}{\longrightarrow^{*}}

\setspecialsymbol{x_1}{$x_1$}
\setspecialsymbol{x_2}{$x_2$}
\setspecialsymbol{x_n}{$x_n$}
\setspecialsymbol{e_1}{$e_1$}
\setspecialsymbol{e_2}{$e_2$}
\setspecialsymbol{e_n}{$e_n$}
\setspecialsymbol{f_1}{$f_1$}
\setspecialsymbol{f_2}{$f_2$}
\setspecialsymbol{f_n}{$f_n$}
\setspecialsymbol{fp_1}{$f'_1$}
\setspecialsymbol{fp_2}{$f'_2$}
\setspecialsymbol{fp_n}{$f'_n$}
\setspecialsymbol{Y_n}{$Y_n$}

We define the \scheme{letrec} form in terms of the \scheme{let} form.

%A recursive definition of the form
%\begin{schemedisplay}
%(letrec ([(x_1 x_2 ... x_n) (values e_1 e_2 ... e_n)])
%  e)
%\end{schemedisplay}
%can be written
%\begin{schemedisplay}
%(let ([(x_1 x_2 ... x_n) (Y_n (LAMBDA (x_1 x_2 ... x_n) e_1)
%                              (LAMBDA (x_1 x_2 ... x_n) e_2)
%                              ...
%                              (LAMBDA (x_1 x_2 ... x_n) e_n))])
%  e)
%\end{schemedisplay}
%where \scheme{Y_n} is defined as
%\begin{schemedisplay}
%(LAMBDA (f_1 f_2 ... f_n)
%  ((LAMBDA (fp_1 fp_2 ... fp_n)
%     (values (fp_1 fp_1 fp_2 ... fp_n)
%             (fp_2 fp_1 fp_2 ... fp_n)
%             ...
%             (fp_n fp_1 fp_2 ... fp_n)))
%   (LAMBDA (fp_1 fp_2 ... fp_n)
%     (LAMBDA (x) ((f_1 (fp_1 fp_1 fp_2 ... fp_n)) x)))
%   (LAMBDA (fp_1 fp_2 ... fp_n)
%     (LAMBDA (x) ((f_2 (fp_2 fp_1 fp_2 ... fp_n)) x)))
%   ...
%   (LAMBDA (fp_1 fp_2 ... fp_n)
%     (LAMBDA (x) ((f_n (fp_n fp_1 fp_2 ... fp_n)) x)))))
%\end{schemedisplay}

\subsection{$\chapcalc$ Semantics}


We use boldface to denote a vector of objects in that category, i.e., $\mathbf{v}$ denotes a vector $\langle v_1,\dots,v_n\rangle$ for some natural number $n$.

We define the semantics of \chapcalc\ in terms of an abstract machine similar to Felleisen's CESK machine~\cite{felleisen1987calculus} to directly apply a particular static analysis.

With the introduction of chaperones and impersonators (and the incusion of primitive functions), we can no longer count on the operator of an application to be a closure.
Thus, we will treat these three categories of values as classes of \emph{operators} and will refer to them collectively as such.

Our machine is defined in terms of multiple state variants.
\begin{itemize}
\item An \emph{evaluation} state $\sexp{\ks}{\sigma}{\rho}{e}$ corresponds to a traditional CESK state.
(The order of the components is reversed, however, to aid factoring out common components from among the variants.)

%$\varsigma\in\mathrm{Kont}\times\mathrm{Sto}\times\mathrm{Env}\times\mathrm{Exp}$

\item A state $\sapp{\ks}{\sigma}{f}{\mathbf{v}}$ represents a point of application and dispatches on the operator type (closure, impersonator, or primitive).
\item A state $\sval{\ks}{\sigma}{\mathbf{v}}$ represents a point of return and dispatches on the type of the top continuation frame.
If the continuation is empty, the constituent values are the results of the program.
\item A state $\serr{\ks}{\sigma}{b}$, represents the arisal of an error and, as the result of the program, may include blame information.
\item Finally, we define a set of \emph{dummy} states which splits a transition which would otherwise pop and push a frame simulaneously into a sequence of two transitions which performs each separately.
(This eases further the transition to a pushdown system.)
\end{itemize}



%expression: forms + primitives + booleans + numbers + labels + variables
%value: primitive + boolean + number + closure + impersonator + chaperone
%semantics: stack frame + stack (sequence of frames) + store + address + environment as finite map
%$\Gamma^{*}$

%\begin{verbatim}
%\Sigma_e(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\hat{\rho},e)
%\Sigma_a(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\ell,\hat{f},\hat{\mathbf{v}})
%\Sigma_v(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\hat{\mathbf{v}})
%\Sigma_!(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},b)
%\Sigma_0(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\ell,\hat{f},\hat{w},\hat{\mathbf{v}})
%\Sigma_1(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\ell,\hat{w},\hat{\mathbf{v}})

%\hat{\sigma}\in \hat{Addr}\mapsto powerset(\hat{V})
%\hat{\rho}\in Var\mapsto\hat{Addr}
%\alpha\in\hat{Addr}
%f,w\in\hat{Op}=\hat{Clo}\cup\hat{Imp}\cup\hat{Prim}
%v\in\hat{V}=\hat{Op}\cup\hat{Bool}\cup\hat{Int}
%\end{verbatim}

%\begin{figure}
%\begin{align*}
%  c \in \sa{Conf} &= \syn{Exp} \times \sa{Env} \times \sa{Store} \times \sa{Kont} && %\text{[configurations]}
%  \\
%  \aenv \in \sa{Env} &= \syn{Var} \parto \sa{Addr} && \text{[environments]}
%  \\
%  \astore \in \sa{Store} &= \sa{Addr} \to \Pow{\sa{Clo}} && \text{[stores]}
  % \\
  % \aden \in \sa{Den} &= \Pow{\sa{Clo}} && \text{[denotable values]}
%  \\
%  \aclo \in \sa{Clo} &= \syn{Lam} \times \sa{Env} && \text{[closures]}
%  \\
%  \acont \in \sa{Kont} &= \sa{Frame}^* && \text{[continuations]}
%  \\
%  \Gamma \in \sa{Frame} &= \syn{Var} \times \syn{Exp} \times \sa{Env}  && \text{[stack frames]}
%  \\
%  \alpha \in \sa{Addr} &\text{ is a \emph{finite} set of addresses} && \text{[addresses]}
%  \text.
%\end{align*}
%\caption{The abstract configuration-space.}
%\label{fig:abs-conf-space}
%\end{figure}



\begin{verbatim}
\sigma\in\Sigma = e Kont x Store x Env x Exp
                | v Kont x Store x Val*
                | a Kont x Store x Lab x Val x Val*
           Kont = Frame*
          Frame = let Var* x Env x Exp
                | imp-neg Lab x Val x Val* [get rid of labels?]
                | imp-ope Lab x Val x Val*
                | imp-pos Lab x Val x Val*
                | chap-neg Lab x Val x Val*
                | chap-ope Lab x Val
                | chap-pos Lab x Val*
          Store = Addr -> Val
            Env = Var -> Addr
           Addr = infinite set of addresses
            Lab = infinite set of labels
            Val = Bool U Int U Op
           Bool = #t | #f
            Int = 0 | 1 | -1 | ...
             Op = Clo U Imp U Prim
            Clo = Lam x Env
            Imp = i Lab x Op x Op
                | c Lab x Op x Op
           Prim = + | - | = | < | >
                | not | values
                | chaperone-operator
                | impersonate-operator
                | boolean? | integer? | operator?
 	    Lam = (LAMBDA (x_1 x_2 ... x_n) e)
\end{verbatim}

The relation $\mathrm{chaperone\mhyphen of?}(v,v')$ holds when parts of $v$ can be derived from corresponding parts of $v'$ through \scheme{chaperone-operator}.

It holds if any of the following hold.
(This definition is not given in terms of sequential pattern matching. Two chaperones satisfy the relation if they meet the conditions of the first clause \emph{or} the second clause.)
\begin{verbatim}
chaperone-of? (chaperone f w) (chaperone f' w')
if (chaperone-of? f f') and (chaperone-of? w w')
;or (chaperone-of? f (chaperone f' w'))
chaperone-of? (chaperone f w) f'
if (chaperone-of? f f')
chaperone-of? (e_LAMBDA,\rho) (e_LAMBDA',\rho')
if e_LAMBDA=e_LAMBDA' and \rho=\rho'
\end{verbatim}

We lift $\mathrm{chaperone\mhyphen of?}$ element-wise over vectors.


A program is injected into a machine state with the function $\mathcal{I} : e\rightarrow\Sigma$ defined as $\mathcal{I}(p)=\sexp{\langle\rangle}{\perp}{\perp}{p}$.

The reduction relation is defined first in terms of the class of machine state.

\newcommand{\Aeval}[1]{\mathcal{A}(\sigma,\rho,#1)}

In the following reductions, $\mathcal{A}$ is defined by
\begin{align*}
\Aeval{\lambda}
\end{align*}
\begin{verbatim}
A(\sigma,\rho,lam)=(lam,\rho)
A(\sigma,\rho,x)=\sigma(\rho(x))
A(\sigma,\rho,i)=i (int)
A(\sigma,\rho,t)=t (bool)
A(\sigma,\rho,p)=p (prim)
\end{verbatim}

\subsubsection{application}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\appe{\ae_f}{\ae_1\,\dots\,\ae_n}}}{\sapp{\ks}{\sigma}{f}{\langle v_1,\dots,v_n\rangle}}

\noindent
where $f=\A{\sigma}{\rho}{\ae_f}$ and $v_i=\A{\sigma}{\rho}{\ae_i}$ for $i=1,\dots,n$.

\subsubsection{let}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\lete{x_1\,\dots\, x_n}{e_0}{e_1}}}{\sexp{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\rho}{e_0}}

\noindent
where $\vx=\langle x_1,\dots,x_n\rangle$.

\red{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\sexp{\ks}{\sigma'}{\rho'}{e_1}}

\noindent
where $(\sigma',\rho')=\bind{\sigma}{\rho}{\vx}{\vv}$ if $|\vx|=|\vv|$

\red{\sval{\letk{\rho}{\vx}{e_1}::\ks}{\sigma}{\vv}}{\dynbla{\ks}} if $|\vx|\ne|\vv|$

\subsubsection{if}

\red{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}{\sexp{\ks}{\sigma}{\rho}{e_c}}
if $v_t\ne\false$
where $v_t=\A{\sigma}{\rho}{\ae_t}$.

\red{\sexp{\ks}{\sigma}{\rho}{\ife{\ae_t}{e_c}{e_a}}}{\sexp{\ks}{\sigma}{\rho}{e_a}}
if $v_t=\false$
where $v_t=\A{\sigma}{\rho}{\ae_t}$.

\subsection{apply}

\emph{apply} states serve as the branching point for dispatch on the operator.

\subsubsection{closure}

The application of a closure operator proceeds straightforwardly by extending its environment and evaluating its body.

\red{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}{\sexp{\ks}{\sigma'}{\rho'}{e}}
if $|\vx|=|\vv|$ where $\vx=\langle x_1,\dots,x_n\rangle$ and $(\sigma',\rho')=\bind{\sigma}{\rho}{\vx}{\vv}$

If the number of values applied is incompatible with the arity of the closure, blame is assigned dynamically.

\red{\sapp{\ks}{\sigma}{\clo{\lame{x_1\,\dots\,x_n}{e}}{\rho}}{\vv}}{\dynbla{\ks}}
if $|\vx|\ne|\vv|$ where $\vx=\langle x_1,\dots,x_n\rangle$

\subsubsection{impersonator}

Impersonator application recurs on its guard and augments the context to complete the interposition when its guard returns.
The enlarged context is annotated with the label of the applied chaperone (which itself is the label of its installment site).

\red{\sapp{\ks}{\sigma}{\cha{f}{w}}{\vv}}{\sapp{\chacwk{f}{\vv}::\ks}{\sigma}{w}{\vv}}

When the results of its wrapper are obtained, the next state is determined by the results.
If an additional result is provided and it is an operator, it is situated to intercept procedure results.

If the number of results obtained is the same as the number of arguments given, the interposition ceases and the function can be evaluated in tail position with respect to the chaperone application.

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sapp{\ks}{\sigma}{f}{\vvp}}

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}
if $|\vv|=|\vvp|$ and $\mathrm{operator?}(w)$.

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{3}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{operator?}(w)$ does not hold.

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{4}{\ell}}
if $|\vv|\ne|\vvp|$ and $|\vv|+1\ne|\vvp|$.

\red{\sdimpz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}{\sapp{\impcfk{w}::\ks}{\sigma}{f}{\vvp}}

\red{\sval{\impcfk{w}::\ks}{\sigma}{\vv}}{\sdimpo{\ks}{\sigma}{w}{\vv}{\ell}}

\red{\sdimpo{\ks}{\sigma}{w}{\vv}{\ell}}{\app{\impcrk{\vv}::\ks}{\sigma}{w}{\vv}}




\red{\sval{\impcrk{\vv}::\ks}{\sigma}{\vvp}}{\sval{\ks}{\sigma}{\vvp}}
if $|\vv|=|\vvp|$

\red{\sval{\impcrk{\vv}::\ks}{\sigma}{\vvp}}{\serr{\ks}{\sigma}{?}}
if $|\vv|\ne|\vvp|$

[That the number of arguments received is the same as the number given is ensured.]



\subsubsection{chaperone}

Chaperone application recurs on its guard and augments the context to complete the interposition when its guard returns.
The enlarged context is annotated with the label of the applied chaperone (which itself is the label of its installment site).

\red{\sapp{\ks}{\sigma}{\cha{f}{w}}{\vv}}{\sapp{\chacwk{f}{\vv}::\ks}{\sigma}{w}{\vv}}

When the results of its wrapper are obtained, the next state is determined by the results.
If an additional result is provided and it is an operator, it is situated to intercept function results.

If the number of results obtained is the same as the number of arguments given, the interposition ceases and the function can be evaluated in tail position with respect to the chaperone application.

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sapp{\ks}{\sigma}{f}{\vvp}}
if $|\vv|=|\vvp|$ and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{1}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold.

--

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}
if $|\vv|=|\vvp|$, $\mathrm{operator?}(w)$, and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{3}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{operator?}(w)$ does not hold.

\red{\sval{\chacwk{w}{\vv}::\ks}{\sigma}{w::\vvp}}{\sbla{1}{\ell}}
if $|\vv|=|\vvp|$ and $\mathrm{operator?}(w)$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold.

--

\red{\sval{\chacwk{f}{\vv}::\ks}{\sigma}{\vvp}}{\sbla{4}{\ell}}
if $|\vv|\ne|\vvp|$ and $|\vv|+1\ne|\vvp|$

\red{\sdchaz{\ks}{\sigma}{f}{\vvp}{\ell}{w}}{\sapp{\chacfk{w}::\ks}{\sigma}{f}{\vvp}}

\red{\sval{\chacfk{w}::\ks}{\sigma}{\vv}}{\sdchao{\ks}{\sigma}{w}{\vv}{\ell}}

\red{\sdchao{\ks}{\sigma}{w}{\vv}{\ell}}{\app{\chacrk{\vv}::\ks}{\sigma}{w}{\vv}}




\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sval{\ks}{\sigma}{\vvp}}
if $|\vv|=|\vvp|$ and $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$

\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sbla{7}{\ell}}
if $|\vv|=|\vvp|$ but $\mathrm{chaperone\mhyphen of?}(\vvp,\vv)$ does not hold

\red{\sval{\chacrk{\vv}::\ks}{\sigma}{\vvp}}{\sbla{6}{\ell}}
if $|\vv|\ne|\vvp|$

\begin{verbatim}
+ L <n0,n1> = [n0+n1]
+ L <n0,n1> -> uparrow if not integer? n0 or not integer? n1 (type)
+ L <n0,...,nn> -> uparrow (arity)

< L <n0,n1> = #t if <n0 < n1>
< L <n0,n1> = #f if not <n0 < n1>
type
arity
+ 2 integer integer ->
> 2 integer integer -> bool
< 2 integer integer -> bool
= 2 integer integer -> bool
not 1 bool -> bool
values 0+ any ... -> any ...
chaperone-operator 2 operator operator -> operator
  and arity of operators identical
chaperone-operator L <f0,f1>
if arity(f1) includes arity(f0)
  chap(L,f0,f1)
impersonate-operator 2 ...

integer? 1 any -> bool
boolean? 1 any -> bool
operator? 1 any -> bool

raise 0+ any ... -> uparrow
\end{verbatim}

The \scheme{values} primitive is distinct.
It takes any number of arguments and returns that same number.
Its arity is taken to be equal to the arity of any other operator, including itself.
Thus, the installation \scheme{(chaperone-operator values values)} is legal, if superfluous).

\begin{verbatim}
bind(\sigma,\rho,x,v)=(\sigma',\rho') where \sigma'=\sigma[a->v], \rho'=\rho[x->a], and  a=alloc(x)
\end{verbatim}

The reduction relation is defined as the union of each given relation.
[show it doesn't get stuck somewhere else?]
\begin{itemize}
\item If $I(p)\longrightarrow^{*}\sval{\langle\rangle}{\sigma}{\mathbf{v}}$, the program evaluates to the values $\mathbf{v}$ which we write as $p\Downarrow\mathbf{v}$.
\item If $I(p)\longrightarrow^{*}\serr{\langle\gamma_1,\dots,\gamma_n\rangle}{\sigma}{b}$, $p$ the program results in an error with blame $b$ and we write $p\Uparrow b$.
\item If, for all $\varsigma$ such that $I(p)\longrightarrow^{*}\varsigma$, there exists $\varsigma'$ such that $\varsigma\longrightarrow\varsigma'$, then $p$ diverges and we write $p\Uparrow$.
\end{itemize}


and remember to define a program resulting in a blame error, diverging, etc.

\section{Chaperone Discharge and Demotion}

\subsection{Expectation that many dynamic checks are unnecessary}

Programs that can result in an error are incorrect; the purpose of blame assignment is to facilitate the act of correcting the program.
We expect a program to result in a blame assignment only rarely.
We have similar expections for a program to result in divergence, and that specifically at the hand of a chaperoned value.
In fact, we expect correct programs never to exhibit such behavior, and while chaperones serve the reality of incorrect programs, the frequency of their complaints diminishes in the long run as the programmer applies their feedback.
The nature of the programming cycle indicates that there may be some chaperones which, situated within a particular program, do not influence the behavior of the program and also that the proportion of chaperoned values in such a position may increase as the program is maintained.

Strickland et al.~\cite{strickland2012chaperones} present a chaperone erasure theorem for a calculus with vector-manipulation primitives.
This theorem establishes that a program with chaperoned values which evaluates successfully will exhibit the same behavior with all the chaperones erased--that is, with chaperone installment removed from the program.
The chaperone erasure theorem, then, makes a statement about the influence chaperones have on the meaning of programs.
We present theorems which build on this conceptual result by giving the conditions under which a chaperone installation can be omitted without changing the meaning of the program.

\subsection{Intuition behind sound discharge}

The conditions necessary for the sound discharge of a chaperone are more easily constructed by considering the conditions sufficient for a chaperone to be meaningful.
If we can enumerate a complete set of these conditions in the sense that any meaningful chaperone must meet at least one of the conditions, we obtain the soundness conditions by complement.

A chaperone \emph{cannot} be discharged if
\begin{enumerate}
\item the negative guard causes an error to be raised,
\item the negative guard diverges,
\item the negative guard does not return the same number of results as arguments given (or one extra),
\item the extra result, if provided, is not a procedure,
\item the results of the negative guard are not, at most, chaperones of the arguments,
\item the positive guard does not accept the number of results produced by the chaperoned procedure,
\item the positive guard causes an error to be raised,
\item the positive guard diverges,
\item the positive guard does not return the same number of results as arguments given, or
\item the results of the positive guard are not, at most, chaperones of the arguments.
\end{enumerate}

For a given program execution, if neither a chaperone nor its installation raises an error or diverges, it is a candidate for \emph{discharge}, or the [omission/removal] of its installation.
It is only a candidate because its application may cause a chaperone to be installed and that chaperone may not be well-behaved.
In this case, discharging the original chaperone would prevent a meaningful chaperone from being created which would make discharge unsound.
Then, intuitively, a chaperone can be discharged if it will not raise an error or diverge  \emph{and} any chaperones it installs can be discharged.

We choose to discharge a chaperone by replacing the \scheme{chaperone-operator} operator with \scheme{(LAMBDA (x y) x)}; discharge is accomplished by simply failing to install the chaperone at all.

This immediately raises two issues.
First, multiple chaperone installations may occur at a given application site during program execution, so we cannot, in all circumstances, selectively prevent the creation of a single chaperone.
Second, chaperone installation may not be the only operation performed by an application site.
We address both by analyzing application sites and then only those in which \scheme{chaperone-operator} is the only operator, which we refer to as \emph{chaperone-installation sites}.
The conditions to discharge a given site are stronger than that of a chaperone installed at that site: instead of demonstrating that a single chaperone satisfies a property, we must demonstrate that every chaperone created at that site satisfies that property \emph{and} that in every chaperone installation at that site, the chaperoning procedure has the same arity as the to-be-chaperoned procedure.

When put in these terms, it is clear that chaperone installment at a particular site can be discharged only if it meets these conditions for every possible execution.
These conditions seem onerous.
Indeed, in Racket, users typically access chaperone installation through a library wrapper so all chaperones in the entire program share the same installation site.
This, in turn, means that a given chaperone can be safely discharged only if \emph{all} chaperones in all executions of the program can be safely discharged.
%In other words, the program must be correct up to the encoded specification.
Fortunately, with access to the whole program, we may inline definitions which allows us to multiply the number of installment sites in the program.

\subsection{Intuition behind demotion}

Much of the run-time overhead of chaperones is shared by impersonators.
Nevertheless, the enforcement of invariants specific to chaperones is somewhat costly --- specifically, the enforcement that chaperone guards at most install chaperones on their arguments.
The conditions to \emph{demote} the set of chaperones installed at a particular site to impersonators (by replacing the \scheme{chaperone-operator} operator with \scheme{impersonate-operator}) are immediately weaker than to discharge the site entirely: we need to demonstrate only that the guards of chaperones installed there do not arbitrarily modify their arguments (conditions 5 and 10 above) for it to be a candidate for demotion.
If one of a site's chaperones is installed on the argument of a chaperone guard, demoting it to install merely an impersonator will make an otherwise well-behaved chaperone not so.

For instance, the program
\begin{schemedisplay}
(let ([sabotage (chaperone-operator
                 (LAMBDA (f) f)
                 (LAMBDA (f) (chaperone-operator f (LAMBDA (x) (raise)))))])
  (let ([g (sabotage (LAMBDA (x) x))])
    (g 1)))
\end{schemedisplay}
defines a chaperoned procedure \scheme{sabotage} which wraps higher-order arguments to fail on application, defines \scheme{g} by applying \scheme{sabotage} to the identity function, and applies \scheme{g} to \scheme{1}, which raises an error.
At no point does \scheme{g} violate chaperone-specific restrictions, so it is tempting to alter its installation site (within the guard of \scheme{sabotage}) to merely impersonate the first argument.
If done, however, the program would fail at the earlier point when \scheme{sabotage} is called which certainly differs in meaning.

This observation provides us with the intuition behind sound site demotion: a chaperone may be demoted if neither of its guards do more than install chaperones on their arguments for all program executions and the chaperone which guard installed it, if any, can be and is demoted. 
We once again lift the conditions to chaperone-installment sites so that a chaperone-installment site can be demoted if all chaperones installed there in any program execution can be demoted and the installment sites of any installing chaperones can be and are demoted.

%We use a straightforward pushdown analysis to determine which states can result in error.
%We use a simple divergence analysis to determine which guards will always terminate.
%With those, we can determine which chaperones can be removed without introducing an error or divergence into the program.


\subsection{More formal notion of discharge and demotion}

Formally, the discharge or demotion of a chaperone-installment site is defined in terms of simple program transformers.

\begin{definition}
A \emph{discharge transformation} $D_\ell : P\rightarrow P$ is a program transformation which replaces the operator of an application site labelled $\ell$ with \scheme{(LAMBDA (x y) x)}.
\end{definition}

\begin{definition}
A \emph{demotion transformation} $E_\ell : P\rightarrow P$ is a program transformation which replaces the operator of an application site labelled $\ell$ with \scheme{impersonate-operator}.
\end{definition}

A sound approximation of conditions 1 and 7 is the idea of dependence (similar to that of Might~\cite{might2009interprocedural}).

\begin{definition}
A chaperoned operator is \emph{active} at a control point if evaluation is within the dynamic extent of its negative or positive guard.
\end{definition}

Chaperone guards may themselves invoke chaperoned operators, so there may be more than one active chaperone at any given time.

\begin{definition}
A chaperoned operator $c_{\ell_1}$ \emph{depends} on a chaperoned operator $c_{\ell_0}$ if $c_{\ell_0}$ is active at the point that the chaperone $c_{\ell_1}$ is installed.
\end{definition}

Let $H_c(c_{\ell_1},c_{\ell_0})$ if $c_{\ell_1}$ depends on $c_{\ell_0}$.

\begin{definition}
A chaperone-installment site $s_{\ell_1}$ \emph{depends} on a chaperoned operator $c_{\ell_0}$ if a some chaperone $c_{\ell_1}$ depends on $c_{\ell_0}$.
\end{definition}

Let $H_s(s_{\ell_1},c_{\ell_0})$ if $s_{\ell_1}$ depends on $c_{\ell_0}$.

\begin{definition}
An error $e$ \emph{depends} on a chaperoned operator $c_\ell$ if $c_\ell$  is active at the point $e$ is raised.
\end{definition}

Let $H_e(e,c_\ell)$ if $e$ depends on $c_\ell$.

\begin{definition}
An error $e$ \emph{depends} on a chaperone installation site $s_\ell$ if \scheme{chaperone-operator} raises $e$ at $s_\ell$.
\end{definition}

Let $H_e(e,s_\ell)$ if $e$ depends on $s_\ell$.

%We call the most-recently-activated chaperone the \emph{youngest} chaperone.
%At evaluation time of a chaperone-installment site, we say that the youngest chaperone is \emph{dependent} on the site.
%Because a given chaperone-installment site may be evaluated multiple times during program execution and from multiple control paths, a chaperone creation site may have several dependent chaperones.

\subsection{Soundness of discharge and demotion}

The sound discharge or demotion of a chaperone-installment site does change the meaning of the program.
In terms of \chapcalc, a discharge is not sound if a divergent program (by error or otherwise) converges after discharge, or vice versa.
Additionally, a sound discharge preserves an equivalence of the resultant values or blame.

\begin{definition}
A program transformation $F$ \emph{preserves meaning} of a program $p$ when it holds that
\begin{itemize}
\item if $p\Downarrow\mathbf{v}$, then $F(p)\Downarrow\mathbf{v'}$ where $\mathrm{chaperone\mhyphen of?}(\mathbf{v},\mathbf{v'})$,
\item if $p\Uparrow b$, then $F(p)\Uparrow b$, and
\item if $p\Uparrow$, then $F(p)\Uparrow$.
\end{itemize}
\end{definition}

(We extend the $\mathrm{chaperone\mhyphen of?}$ relation with reflexivity over primitive values.)

\begin{definition}[Transformation Soundness]
A program transformation $F$ is sound for a program $p$ if it preserves the meaning of $p$.
\end{definition}

\begin{definition}
A chaperoned operator $c_\ell$ is \emph{well-behaved} with respect to a program $p$ if it exhibits none of the conditions of that long list.
\end{definition}

Let $G(c_\ell)$ hold if $c_\ell$ is well-behaved.

\begin{definition}
A chaperone $c_{\ell_0}$ is \emph{dischargeable} with respect to a program $p$ if it is well-behaved and for each dependent chaperone $c_{\ell_0}$, $c_{\ell_0}$ is dischargeable.
\end{definition}

Transitive, reflexive closure of $H_c$ is $\bar{H_c}$,
then $c_{\ell_0}$ is dischargeable if for all $c_{\ell_1}$ such that $\bar{H_c}(c_{\ell_1},c_{\ell_0})$, $G(c_{\ell_1})$.

\begin{definition}
A chaperone installation site is \emph{dischargeable} with respect to a program $p$ if all chaperones installed there are well-behaved and all dependent chaperone sites of chaperones installed there are dischargeable.
\end{definition}

\begin{theorem}
If a chaperone-installment site labelled $\ell$ is dischargeable with respect to a program $p$, then $D_\ell$ is sound for $p$.
\end{theorem}

\begin{proof}
By induction on the reduction relation.
Suppose $p\rrs v$.
Then none of the chaperone guards (or any guard, for that matter) must raise an error.
Then there is nothing to worry about.
That is, $D_\ell(p)\rrs v$, where we make no distinction between an operator and a chaperone of it.

Suppose $p\Uparrow b$. 
Then an error must be raised while a chaperone (with $b$ derived from its label) is active.
Then that chaperone depends on the error.
Then that chaperone-installment site will not be a candidate for deletion.
It is not dischargeable.
Then it's not labelled $\ell$.
Since this is true for every dependent non-dischargeable site (that it's not labelled $\ell$), then $D_\ell(p)\Uparrow b$.

Suppose $p\Uparrow$.
If the installation or application of a chaperone could cause divergence, it won't be dischargeable.
Then the chaperone site labelled $\ell$ must not cause divergence.
Then $D_\ell(p)\Uparrow$.
\end{proof}

\begin{definition}
A chaperoned operator is \emph{good0} with respect to a program $p$ if it does not raise a chaperone error.
\end{definition}

\begin{definition}
A chaperone-installment site is soundly \emph{demotable} with respect to a program $p$ if it can be [demoted] and all chaperone installation sites of all chaperones it depends on are soundly demoted.
\end{definition}

\begin{lemma}
If a chaperone-installment site labelled $\ell$ is demotable with respect to a program $p$, then $E_\ell$ will not introduce any errors in $p$.

That is,
\begin{itemize}
\item if $p\Downarrow\mathbf{v}$, then $E_\ell(p)\not\Uparrow b$ for any $b$,
\item if $p\Uparrow b$, then $E_\ell(p)\not\Uparrow b'$ for $b\ne b'$, and
\item if $p\Uparrow$, then $E_\ell(p)\not\Uparrow b$ for any $b$.
\end{itemize}
\end{lemma}

\begin{proof}
Suppose $p\rrs v$.
Then no error is thrown in regular execution.
Because we will not demote a site unless there is no possibility that its result is used by a chaperone, demoting the site will not introduce an error.
Therefore, $E_\ell(p)\rrs v$ where we make no distinction between an operator and an impersonator of it.

\end{proof}

\begin{theorem}
If a chaperone-installment site labelled $\ell$ is demotable with respect to a program $p$, then $E_\ell$ is sound for $p$.
\end{theorem}

\begin{proof}
Suppose $p\rrs v$.
Then no error is thrown in regular execution.
Because we will not demote a site unless there is no possibility that its result is used by a chaperone, demoting the site will not introduce an error.
Therefore, $E_\ell(p)\rrs v$ where we make no distinction between an operator and an impersonator of it.

%Suppose $p\Uparrow b$.

\end{proof}

[Is this the right math?]

Let $c_\ell$ denote a chaperone installed at the site $\ell$.
Let $P_0(c_\ell)$ denote that $c_\ell$ is well-behaved.
Let $R(c_{\ell_0},c_{\ell_1})$ if $c_{\ell_0}$ depends on $c_{\ell_1}$.
Let $\bar{R}$ be the transitive, reflexive closure of $R$.
A chaperone $c_{\ell_0}$ is dischargeable if $\forall c_\ell$ such that $\bar{R}(c_\ell,c_{\ell_0})$, $P_0(c_\ell)$.
A chaperone-installment site with label $\ell$ is dischargeable if all chaperones $c_{\ell_0}$ are dischargeable for $\ell_0=\ell$.
%For a chaperone-installment site with label $\ell$, let $P_0(\ell)$ hold when $\forall c_\ell

\section{Static Analysis}

We use two static analysis techniques in tandem to determine whether chaperone-installment sites in \chapcalc\ programs are dischargeable or demotable.

First, we use abstract interpretation via introspective pushdown analysis~\cite{earl2012introspective} to soundly approximate the both the error and creation dependence relations.
Using the flow information available from this same analysis, we perform termination analysis on $lambda$-terms used in guard procedures.

Because \chapcalc\ lacks any inductively-defined datatypes, the portion of the dynamic call graph rooted at a guard procedure is likely a tree.
This is not so in Racket, where such datatypes are common.
For instance, the \scheme{(listof integer?)} contract is checked recursively on the structure of the list.
A more powerful analysis, such as a higher-order size-change termination analysis~\cite{sereni2007termination}, would be fruitful in that context but is unnecessary here.

\subsection{A Worked Example}

\begin{schemedisplay}
(let ([(->) ( (neg pos) ( (f) (chaperone-operator f ( (v) (values pos (neg v))))))])
  (let ([(any/c) ( (x) x)])
    (let ([(any) values])
      (let ([(boolean/c) ( (p)
                           (if (not (boolean? p))
                               (raise)
                               p))])
        (let ([(nat/c) ( (n)
                         (if (or (not (integer? n))
                                 (< n 0))
                             (raise)
                             n))])
          (let ([(church/c) (-> (-> any/c any)
                                (-> any/c any))])
            (letrec ([(n->f) ((-> nat/c church/c)
                              ( (n)
                                (if (= n 0)
                                    ( (f) ( (x) x))
                                    (let ([(n-1) (n->f (- n 1))])
                                      ( (f)
                                        (let ([(fn-1) (n-1 f)])
                                          ( (x) (f (fn-1 x)))))))))])
              (let ([(f->n) ((-> church/c nat/c)
                             ( (c)
                               ((c ( (x) (+ x 1))) 0)))])
                (let ([(c:*) ((-> church/c (-> church/c church/c))
                              ( (n1)
                                ( (n2)
                                  ( (f)
                                    (n1 (n2 f))))))])
                  (let ([(c:zero?) ((-> church/c boolean/c)
                                    ( (c) ((c ( (x) #f)) #t)))])
                    (let ([(c:sub1) ((-> church/c church/c)
                                     ( (n)
                                       ( (f)
                                         (let ([(X) ( (g) ( (h) (h (g f))))])
                                           ( (x)
                                             (((n X)
                                               ( (u) x))
                                              ( (u) u)))))))])
                      (letrec ([(c:!) ((-> church/c church/c)
                                       ( (n)
                                         (if (c:zero? n)
                                             ( (f) f)
                                             ((c:* n) (c:! (c:sub1 n))))))])
                        (f->n (c:! (n->f 6)))))))))))))))
\end{schemedisplay}

\subsubsection{Abstract Domains}

Because higher-order contracts often refine domains, the choice of abstraction function can have significant ramifications for the precision of the analysis.
For instance, an analysis of the program
\begin{schemedisplay}
(letrec ([(fact) (values (LAMBDA (n)
                          (let ([test0 (= n 0)])
                            (if test0
                                1
                                (let ([(n-1) (- n 1)])
                                  (let ([(rec) (fact n-1)])
                                    (* n rec)))))))])
  (let ([(fact) (-> fact nonnegative? positive?)])
    (fact 5)))
\end{schemedisplay}
using a singleton domain [?] for integers will fail to discharge the chaperone.
A domain which distinguishes values coincident with the edges of the contract would be able to.

We follow Might's strategy of lifting abstractions component-, element- member-, and point-wise across the structure of machine states~\cite{van2010abstracting}.

\begin{verbatim}
\Sigma_e(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\hat{\rho},e)
\Sigma_a(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\ell,\hat{f},\hat{\mathbf{v}})
\Sigma_v(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\hat{\mathbf{v}})
\Sigma_!(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},b)
\Sigma_0(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\ell,\hat{f},\hat{w},\hat{\mathbf{v}})
\Sigma_1(\langle\hat{\gamma},\dots\rangle,\hat{\sigma},\ell,\hat{w},\hat{\mathbf{v}})

\hat{\sigma}\in \hat{Addr}\mapsto powerset(\hat{V})
\hat{\rho}\in Var\mapsto\hat{Addr}
\alpha\in\hat{Addr}
f,w\in\hat{Op}=\hat{Clo}\cup\hat{Imp}\cup\hat{Prim}
v\in\hat{V}=\hat{Op}\cup\hat{Bool}\cup\hat{Int}
\end{verbatim}

\begin{verbatim}
A(\sigma,\rho,lam)={(lam,\rho)}
A(\sigma,\rho,x)=\sigma(\rho(x))
A(\sigma,\rho,i)={\alpha(i)} (int)
A(\sigma,\rho,t)={t} (bool)
A(\sigma,\rho,p)={p} (prim)
\end{verbatim}

\begin{verbatim}
bind(\sigma,\rho,x,v)=(\sigma',\rho') where \sigma'=\sigma[a->v], \rho'=\rho[x->a], and  a=alloc(x)
\end{verbatim}

The abstraction function $\alpha$ allows us to tune our analysis, much like the parameter $k$ in $k$-CFA.
In general, the precision of the analysis increases as the abstract primitive domain underlying $\alpha$ coincides more closely with the particular contracts of the program.

\subsubsection{application}

\noindent
\red{\sexp{\ks}{\sigma}{\rho}{\appe{\ae_f}{\ae_1\,\dots\,\ae_n}}}{\sapp{\ks}{\sigma}{f}{\langle v_1,\dots,v_n\rangle}}

\noindent
where $f\in\A{\sigma}{\rho}{\ae_f}$ and $v_i\in\A{\sigma}{\rho}{\ae_i}$ for $i=1,\dots,n$.

Like closures, there is circularity in the definition of operators in \chapcalc, which induces an infinite space.
$\mathrm{Lab}\times\mathrm{Operator}\times\mathrm{Operator}\subset\mathrm{operator}$
We finitize the space by directing the components of a procedure impersonator or chaperone through the store.
For allocation, we synthesize a variable for each component unique to each call site.
\begin{verbatim}
\ell_f
\ell_w
\end{verbatim}

\subsection{Termination Analysis}

We take most of this from \cite{sereni2007termination}.
Sereni says an avenue of future work is to integrate with Might's gamma CFA.
We could also integrate it with pushdown analysis?
We need to build up the dynamic call graph in both analyses.
The garbage collection is sound so we may be able to extend the TA to it (and hopefully for pushdown too).
We don't care about the whole program; we only care about guard expressions.
We use flow analysis to determine which lambda terms can flow to a guard.
We do a flow analysis on all the free variables to see what could go where.
We may be able to radically decrease the size of the call graph (in some cases) since we don't care about the whole program.

The application of a chaperone guard will not diverge if the dynamic call graph rooted at that call is finite and does not contain any cycles.
One of the conditions for a chaperone-installment site to be dischargeable is that the obviation of the pertinent guard applications does not change the behavior of the program.
A guard can change the behavior of the program in one of two ways:
First, it can signal a contract violation by means of an exception.
The program halts and produces a blame assignment as a result.
Clearly, if a guard would have thrown an error, and in so doing halted the program, the omission of the guard application changes the behavior---and meaning---of the program.
Second, a guard can diverge.
A chaperone-installment site can be discharged, then, if none of the guards there raise an error or diverge and the chaperone-installment sites of any dependent chaperones can also be discharged.

But consider
\begin{schemedisplay}
(letrec ([(even? odd?) (values (LAMBDA (n)
			         (let ([(test) (= n 0)])
			           (if test
			               #t
			               (let ([n-1 (- n 1)])
			                 (odd? n-1)))))
			       (LAMBDA (n)
			         (let ([(test) (= n 0)])
			           (if test
			               #f
			               (let ([n-1 (- n 1)])
			                 (even? n-1))))))])
  (let ([f (chaperone-operator (LAMBDA (n) (+ n 1))
                               (LAMBDA (n)
                                 (let ([(test) (even? n)])
                                   (if test
                                       (values (LAMBDA (n)
                                                 (let ([(test) (odd? n)])
                                                   (if test
                                                       n
                                                       (raise))))
                                               n)
                                       (raise)))))])
    (f 2)))
\end{schemedisplay}
where we rely on our previous definition of \scheme{letrec}.
Even though this program results in a value, our analysis cannot discharge the chaperone since the call graph rooted at each guard procedure has a cycle in it.
It \emph{could} be done with appeal to the size-change termination property (adapted since the standard ordering on integers is not well-founded).
Our analysis can demote the chaperone to an impersonator, though.

%Consider the analysis of the program
%\begin{schemedisplay}
%(let ([(f) (chaperone-operator (LAMBDA (x) x)
%                               (LAMBDA (x)
%                                 (let ([(test) (integer? x)])
%                                   (if test
%                                       x
%                                       (raise)))))])
%  (f 1))
%\end{schemedisplay}
%\begin{verbatim}
%[]
%[(let)]
%[]
%[(chap)]
%\end{verbatim}              

We first perform an introspective pushdown analysis on \chapcalc\ programs.
The abstract semantics are fairly straightforward.
Structural abstraction proceeds component-wise, point-wise, etc.
Like Might and Van Horn~\cite{van2010abstracting} with closures, we must untie the recursive definition of chaperones and impersonators.
We don't need it for the operators themselves since they are atomic expressions, and so cannot refer to themselves.
We do it for the guard procedure by using the label of the site as the abstract address (or deriving it therefrom).

We can build up the dependence relation by looking at the stack frames possible at each point of error or construction in the program.
We determine construction points in the program by looking at value states (points of return) and examining the top frame at that point (to see if it's a chaperone construction frame).
We take the union over all the sets of frames dependent on errors.
We build the construction dependence relation also.
We can then determine whether any of the installment site labels are safe to remove.
But before that, we look at all operators that can flow to the guard of a chaperone.
We are interested in whether they can diverge or not.
With lambda terms, we look at whether they can diverge.
With chaperones or impersonators, we look at whether any of the constituent operators can diverge.
Primitives cannot diverge.

We could look more precisely at dependence and distinguish between positive and negative guards more.
We could find instances where the positive guard could be discharged with values. Then the negative guard could be discharged if the positive guard could be and it itself was well-behaved.
Then a chaperone or impersonator with a guard values can be discharged.
A chaperone-installment site can discharge the positive guard if none of the positive guards of its constituents are relied on by errors.



\section{Limitations}

Our calculus has an impoverished value domain, so our termination judgments of guards are nearly complete in practice as a result of only a simple flow analysis.
(Because, in practice, guards are not recursive themselves or any procedures in the call graph. Essentially, call graphs for guard procedures are trees.)
Contracts on compound data complicate matters because the data may be defined inductively which makes recursive checking natural.
We can accomodate this in particular by integrating size-change analysis~\cite{lee2001size} into our abstract interpretation.
This would be novel as higher-order size-change analysis~\cite{sereni2007termination} has heretofore been applied only to variants of $k$-CFA~\cite{shivers1991control}.

\scheme{app-values} increases the expressiveness of the language.
(We do not have to specify the number of arguments to a function statically.)
The structure of a list is recursive.
We can untie the recursive definition by directing through the store; we took this approach with environments.
We could look into this, but that means the length of the list could vary.
That could \emph{really} destroy precision, but we need to investigate it further.

\emph{rest values} increase the expressiveness of the language. They are very related to \scheme{app-values}.
\scheme{chaperone-operator} as a primitive (as opposed to a form) increases the expressiveness of the language.

Our analysis applies equally well if we extend the language with more referentially transparent primitives or macro-expressible constructs such as \scheme{and} and \scheme{or} forms.
We can even add an error-catching facility but we must be careful in our analysis.

In Racket, the \scheme{chaperone-of?} relation is accessible through a predicate procedure.
However, its presence in Racket has different implications than its introduction to \chapcalc, which can use it to determine whether two procedures are intensionally equivalent.
(In Racket, its use in that fashion is restricted to determining whether two references indicate the same procedure.)

Chaperones are intended to be treated like the original value.
% box?, procedure?, etc. will respond the same way
% they evaluate equal? to the values they wrap, but not eq?
Procedure chaperones are considered to have the same arity of the procedures they wrap.
The \scheme{chaperone?} predicate is designated as the single way to detect chaperones at runtime, though its use is discouraged.

\subsection{Handling \emph{handle}}

Exception handlers prevent certain errors from escaping a particular dynamic extent.
Consider the program
\begin{schemedisplay}
(handle
  (chaperone-operator + (raise) (raise))
  -)
\end{schemedisplay}
wherein an error is always raised and the handler always triggered.
Even though an exception never escapes the dynamic extent of the \scheme{handle} expression, replacing the \scheme{chaperone-operator} application with its first argument results in a different program. 
This means that we must consider whether a \scheme{chaperone-operator} application ever raises an error, and not simply if that error escapes a delimited extent.
% being able to catch errors means that errors can change the meaning of a program arbitrarily--even if it results in a value.
% this means that we need to preserve errors
% chaperone-of? within the language can change the behavior, right? if it was a chaperone before, removing the chaperone makes it still chaperone-of? it's chaperone? that makes it possible to detect changes, but that is discouraged, and we will leave it out of our language.

chaperone and impersonator properties

\section{Related Work}

\section{Conclusion}

Interposition primitives exist for more than functions in Racket: boxes, vectors, hash tables, continuation mark keys, etc.

We omitted from \chapcalc a few primitives that exist in Racket that must be accounted for by our analysis.
A call \scheme{(chaperone-of? f g)} determines whether \scheme{f} is \scheme{equal?} to \scheme{g} modulo chaperones.
In other words, it determines whether \scheme{f} could be constructed from the parts of \scheme{g} and some chaperone installation.
This primitive presents no problem for chaperone discharge as \scheme{(chaperone-of? f f)} always evaluates to \scheme{#t}.
However, if a chaperone has been promoted to an impersonator and flows to the first argument position, the meaning of the program is changed, making the promotion unsound.
If chaperone values that both otherwise can and cannot be promoted flow to this position, we cannot promote the chaperones.
If only promoted or discharged chaperones flow to it, we can replace it with the corresponding \scheme{impersonator-of?} call.

We also must contend with the \scheme{chaperone?} and \scheme{impersonator?} predicates. We can apply similar reasoning to integrate them into our original analysis.
Given that Racket programmers are discouraged from using them, we don't expect them to regularly upend our analysis, but of course we must account for them.

\section{Next}

Not changing complexity, the time factor is less pernicious, but it is hard not to think of the waste effected by the application of a sequence of idempotent operators.

Now the programmer wants to define his own contract predicates \scheme{even?} and \scheme{odd?}. Aware of the cost of contracts on tail-recursive functions, he opts against their use.
\begin{schemedisplay}
(define (even? n)
  (if (= n 0)
      #t
      (odd? (- n 1))))
      
(define (odd? n)
  (if (= n 1)
      #t
      (even? (- n 1))))
\end{schemedisplay}
for use in the definition
\begin{schemedisplay}
(define/contract (partial-succ n)
  (odd? . -> . even?)
  (+ n 1))
\end{schemedisplay}
which calculates the successor only for odd numbers.

What is the result of the call \scheme{(partial-succ 0)}?
The programmer hopes a contract violation will be detected with blame assigned to the caller.
Instead, his program never halts.

Now suppose the programmer recruits \scheme{odd?} and \scheme{even?} as contract predicates but, as happens with , fails to implement odd? correctly inst


%It takes time to determine compliance of first-order values as first-order contracts can be arbitrary predicates.
%Additionally, functions may ascribe contracts to their higher-order arguments which themselves do similarly, even recursively.

%There isn't much a calculus can do to solve the time issue, especially in the face of dependent contracts.

%Because contract compliance of higher-order values cannot be determined in general at ascription time, compliance checks must be attached to values to be performed later.
%These attachments may accumulate, even changing the asymptotic space complexity of the program \cite{herman2010space} unless otherwise handled (again see \cite{herman2010space} or, for example, \cite{siek2010threesomes}).

%This space issue is well-known and a few different approaches have been taken to deal with it:
%Herman's coercion calculus, Wadler and Sieks' threesome calculus, the space-efficient contracts author
%These do well to soundly preserve the asymptotic space complexity of the program and perhaps the time as well.




%The motivation for this was to provide an abstract garbage collector a set of live frames, disregarding any stack structure latent in the control flow graph.

%This description alone is enough to allow us to reason statically about features based on stack inspection, such as security checks [cite] and dynamic binding [cite].
%We will use it to approximate blame on a misbehaving program.
%After considering all possible sources of such blame, a straightforward analysis allows us to alter contract sites, shifting some of the dynamic burden to the static.

% thus, in order to soundly discharge contracts from the original program, we must soundly discharge impersonators and chaperones.
%The implementation of familiar language features is sometimes accomplished through alien constructs.
% (Because the feature must be situated particularly within the already existing features of the language.)
%Contracts are a common feature of dynamically-typed languages.
%Higher-order contracts \cite{findler2002contracts} increase the domain of contracts to higher-order values.
%Of course, codomain compliance of a higher-order contract cannot be decided at attachment time.
%Instead, contracts are decomposed and positioned to intercept the arguments and results of application--the earliest possible time that contract compliance can be determined.
%This \emph{de facto} wrapping of deferred contract checks imposes space and time overhead.
%Wadler and his cronies and Herman and his cronies \cite{wadler2009well,herman2010space} show how the accumulation of wrappers can grow unbounded and offer various solutions to ameliorate this.
%Determining contract compliance can make up a significant portion of reduction.

%Higher-order contracts \cite{findler2002contracts} are now familiar constructs of languages but their implementation in Racket, which must cope with other language features--perhaps incidentally, is in terms of value wrappers.
% \emph{impersonators} and \emph{chaperones}.
%In Racket, data contracts are implemented at the bytecode level using interposition primitives--that is, values are wrapped and these wrappers intercept arguments and results.
%Because functions are data in a higher-order language, special care has been given to enforcing safe and sound function contracts.
%Of course, codomain contract compliance cannot be decided.
%In consequence, codomain contract checks are deferred until the function actually delivers a value.

%Nevertheless, analysis tools have access to more of certain kinds of information after compilation and so have the potential to prove more and different properties about programs.
%Specifically, analysis tools for Racket have access to the whole program after module compilation through a \emph{demodularization} process.

%Racket program lifecycle--the tipping of various types of information

% a static analysis defines a class of program transformations
% if the analysis is sound, the transformation is meaning-preserving
% are these two preceding statements true?

%This goal can be sought at each of the various stages of the Racket program lifecycle.
%Initially, programs are organized into modules, and dynamic behavior can be gleaned from contract declarations at module boundaries.\cite{tobin2012higher}
%Each module is compiled in isolation to bytecode; the bytecode compiler performs optimizations which rely on at most basic flow analysis are performed (constant-folding, 
%``The bytecode compiler applies all standard optimizations, such as constant propagation, constant folding, inlining, and dead-code elimination.''
%The journey to this stage discards high-level information and doesn't acquire much new information, so analysis here is probably fruitless.

%Racket modules are compiled to bytecode. This

%implementation of contracts within racket using interposition

%talk about blame and the method Racket uses to assign blame--the compilation process, etc.


%\appendix
%\section{Appendix Title}

%This is the text of the appendix, if you need one.

%\acks

%These are the acks.

% We recommend abbrvnat bibliography style.

\bibliographystyle{abbrvnat}
\bibliography{paper}


% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright

%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...

%\end{thebibliography}


\end{document}

%                       Revision History
%                       -------- -------
%  Date         Person  Ver.    Change
%  ----         ------  ----    ------

%  2013.06.29   TU      0.1--4  comments on permission/copyright notices

